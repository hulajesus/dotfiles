SCRIPT  /Users/jesushula/.yadr/vim/bundle/vim-easytags/autoload/xolox/easytags/filetypes.vim
Sourced 1 time
Total time:   0.002001
 Self time:   0.001811

count  total (s)   self (s)
                            " Vim script
                            " Author: Peter Odding <peter@peterodding.com>
                            " Last Change: November 13, 2014
                            " URL: http://peterodding.com/code/vim/easytags/
                            
                            " This submodule of the vim-easytags plug-in translates between back and forth
                            " between Vim file types and Exuberant Ctags languages. This is complicated by
                            " a couple of things:
                            "
                            "  - Vim allows file types to be combined like `filetype=c.doxygen'.
                            "
                            "  - Some file types need to be canonicalized, for example the `htmldjango'
                            "    Vim file type should be treated as the `html' Exuberant Ctags language.
                            
                            " Whether we've run Exuberant Ctags to discover the supported file types.
    1              0.000012 let s:discovered_filetypes = 0
                            
                            " List of supported Vim file types.
    1              0.000002 let s:supported_filetypes = []
                            
                            " Mapping of Exuberant Ctags languages to Vim file types and vice versa.
    1              0.000046 let g:xolox#easytags#filetypes#ctags_to_vim = {}
    1              0.000039 let g:xolox#easytags#filetypes#vim_to_ctags = {}
                            
                            " Mapping of Vim file types to canonical file types.
    1              0.000002 let s:canonical_filetypes = {}
                            
                            " Mapping of canonical Vim file types to their groups.
    1              0.000003 let s:filetype_groups = {}
                            
    1              0.000008 function! xolox#easytags#filetypes#add_group(...) " {{{1
                              " Define a group of Vim file types whose tags should be stored together.
                              let canonical_filetype = tolower(a:1)
                              let other_filetypes = map(a:000[1:], 'tolower(v:val)')
                              let s:filetype_groups[canonical_filetype] = other_filetypes
                              for ft in other_filetypes
                                let s:canonical_filetypes[ft] = canonical_filetype
                              endfor
                            endfunction
                            
    1              0.000005 function! xolox#easytags#filetypes#add_mapping(vim_filetype, ctags_language) " {{{1
                              " Map an Exuberant Ctags language to a Vim file type and vice versa.
                              let vim_filetype = tolower(a:vim_filetype)
                              let ctags_language = tolower(a:ctags_language)
                              let g:xolox#easytags#filetypes#ctags_to_vim[ctags_language] = vim_filetype
                              let g:xolox#easytags#filetypes#vim_to_ctags[vim_filetype] = ctags_language
                            endfunction
                            
    1              0.000004 function! xolox#easytags#filetypes#to_vim(ctags_language) " {{{1
                              " Translate an Exuberant Ctags language to a Vim file type.
                              let ctags_language = tolower(a:ctags_language)
                              return get(g:xolox#easytags#filetypes#ctags_to_vim, ctags_language, ctags_language)
                            endfunction
                            
    1              0.000003 function! xolox#easytags#filetypes#to_ctags(vim_filetype) " {{{1
                              " Translate a Vim file type to an Exuberant Ctags language.
                              let vim_filetype = tolower(a:vim_filetype)
                              return get(g:xolox#easytags#filetypes#vim_to_ctags, vim_filetype, vim_filetype)
                            endfunction
                            
    1              0.000003 function! xolox#easytags#filetypes#canonicalize(vim_filetype_value) " {{{1
                              " Select a canonical, supported Vim file type given a value of &filetype.
                              call s:discover_supported_filetypes()
                              " Split the possibly combined Vim file type into individual file types.
                              for filetype in split(tolower(a:vim_filetype_value), '\.')
                                " Canonicalize the Vim file type.
                                let filetype = get(s:canonical_filetypes, filetype, filetype)
                                if index(s:supported_filetypes, filetype) >= 0
                                  return filetype
                                endif
                              endfor
                              return ''
                            endfunction
                            
    1              0.000004 function! xolox#easytags#filetypes#find_ctags_aliases(canonical_vim_filetype) " {{{1
                              " Find Exuberant Ctags languages that correspond to a canonical, supported Vim file type.
                              if has_key(s:filetype_groups, a:canonical_vim_filetype)
                                let filetypes = [a:canonical_vim_filetype]
                                call extend(filetypes, s:filetype_groups[a:canonical_vim_filetype])
                                return map(filetypes, 'xolox#easytags#filetypes#to_ctags(v:val)')
                              else
                                return [xolox#easytags#filetypes#to_ctags(a:canonical_vim_filetype)]
                              endif
                            endfunction
                            
    1              0.000006 function! s:discover_supported_filetypes() " {{{1
                              " Initialize predefined groups & mappings and discover supported file types.
                              if !s:discovered_filetypes
                                " Discover the file types supported by Exuberant Ctags?
                                let command_line = xolox#easytags#ctags_command()
                                if !empty(command_line)
                                  let starttime = xolox#misc#timer#start()
                                  let command_line .= ' --list-languages'
                                  for line in xolox#misc#os#exec({'command': command_line})['stdout']
                                    if line =~ '\[disabled\]$'
                                      " Ignore languages that have been explicitly disabled using `--languages=-Vim'.
                                      continue
                                    elseif line =~ '^\w\S*$'
                                      call add(s:supported_filetypes, xolox#easytags#filetypes#to_vim(xolox#misc#str#trim(line)))
                                    elseif line =~ '\S'
                                      call xolox#misc#msg#warn("easytags.vim %s: Failed to parse line of output from ctags --list-languages: %s", g:xolox#easytags#version, string(line))
                                    endif
                                  endfor
                                  let msg = "easytags.vim %s: Retrieved %i supported languages in %s."
                                  call xolox#misc#timer#stop(msg, g:xolox#easytags#version, len(s:supported_filetypes), starttime)
                                endif
                                " Add file types supported by language specific programs.
                                call extend(s:supported_filetypes, keys(xolox#misc#option#get('easytags_languages', {})))
                                " Don't run s:discover_supported_filetypes() more than once.
                                let s:discovered_filetypes = 1
                              endif
                            endfunction
                            
                            " }}}1
                            
                            " Define the default file type groups. It's important that C normalizes to C++
                            " because of the following points:
                            "
                            "  - Vim and Exuberant Ctags consistently treat *.h files as C++. I guess this
                            "    is because A) the filename extension is ambiguous and B) C++ is a
                            "    superset of C so the mapping makes sense.
                            "
                            "  - Because of the above point, when you use file type specific tags files
                            "    and you're editing C source code you'll be missing everything defined in
                            "    your *.h files. Depending on your programming style those tags might be
                            "    redundant or they might not be.
                            "
                            " To solve this dilemma the vim-easytags plug-in groups the C and C++ file
                            " types together and tells Exuberant Ctags to treat it all as C++ because C++
                            " is a superset of C.
    1   0.000216   0.000147 call xolox#easytags#filetypes#add_group('cpp', 'c')
    1   0.000059   0.000016 call xolox#easytags#filetypes#add_group('html', 'htmldjango')
                            
                            " Define the default file type mappings.
    1   0.000097   0.000067 call xolox#easytags#filetypes#add_mapping('cpp', 'c++')
    1   0.000038   0.000013 call xolox#easytags#filetypes#add_mapping('cs', 'c#')
    1   0.000039   0.000016 call xolox#easytags#filetypes#add_mapping(exists('g:filetype_asp') ? g:filetype_asp : 'aspvbs', 'asp')
                            
                            " vim: ts=2 sw=2 et

SCRIPT  /Users/jesushula/.yadr/vim/bundle/vim-misc/autoload/xolox/misc/str.vim
Sourced 1 time
Total time:   0.000178
 Self time:   0.000178

count  total (s)   self (s)
                            " String handling.
                            "
                            " Author: Peter Odding <peter@peterodding.com>
                            " Last Change: September 17, 2014
                            " URL: http://peterodding.com/code/vim/misc/
                            
    1              0.000017 function! xolox#misc#str#slug(s) " {{{1
                              " Convert a string to a "slug" - something that can be safely used in
                              " filenames and URLs without worrying about quoting/escaping of special
                              " characters.
                              return join(split(tolower(a:s), '\W\+'), '-')
                            endfunction
                            
    1              0.000006 function! xolox#misc#str#ucfirst(s) " {{{1
                              " Uppercase the first character in a string (the first argument).
                              return substitute(a:s, '^.', '\U\0', '')
                            endfunction
                            
    1              0.000006 function! xolox#misc#str#unescape(s) " {{{1
                              " Remove back slash escapes from a string (the first argument).
                              return substitute(a:s, '\\\(\_.\)', '\1', 'g')
                            endfunction
                            
    1              0.000004 function! xolox#misc#str#compact(s) " {{{1
                              " Compact whitespace in a string (the first argument).
                              return join(split(a:s), " ")
                            endfunction
                            
    1              0.000004 function! xolox#misc#str#trim(s) " {{{1
                              " Trim all whitespace from the start and end of a string (the first
                              " argument).
                              return substitute(a:s, '^\_s*\(.\{-}\)\_s*$', '\1', '')
                            endfunction
                            
    1              0.000006 function! xolox#misc#str#indent(text, num_spaces) " {{{1
                              " Indent all lines in a multi-line string (the first argument) with a
                              " specific number of *space characters* (the second argument, an integer).
                              let lines = split(a:text, "\n")
                              let indent = repeat(' ', a:num_spaces)
                              let [idx, limit] = [0, len(lines)]
                              while idx < limit
                                if lines[idx] =~ '\S'
                                  let lines[idx] = indent . lines[idx]
                                endif
                                let idx += 1
                              endwhile
                              return join(lines, "\n")
                            endfunction
                            
    1              0.000005 function! xolox#misc#str#dedent(text) " {{{1
                              " Remove common whitespace from a multi line string.
                              let lines = split(a:text, "\n")
                              " First we need to determine the common indentation of all non-empty lines.
                              for line in lines
                                if line =~ '\S'
                                  let indent = matchstr(line, '^\s*')
                                  if !exists('common_indent')
                                    let common_indent = indent
                                  elseif len(indent) < len(common_indent)
                                    let common_indent = indent
                                  endif
                                endif
                              endfor
                              " Now we will strip the common indentation.
                              let [idx, limit] = [0, len(lines)]
                              let pattern = '^' . common_indent
                              while idx < limit
                                let lines[idx] = substitute(lines[idx], pattern, '', '')
                                let idx += 1
                              endwhile
                              return join(lines, "\n")
                            endfunction
                            
                            " vim: ts=2 sw=2 et

SCRIPT  /Users/jesushula/.yadr/vim/bundle/vim-easytags/autoload/xolox/easytags/utils.vim
Sourced 1 time
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
                            " Vim script
                            " Author: Peter Odding <peter@peterodding.com>
                            " Last Change: June 20, 2014
                            " URL: http://peterodding.com/code/vim/easytags/
                            
                            " Utility functions for vim-easytags.
                            
    1              0.000011 function! xolox#easytags#utils#canonicalize(pathname)
                              if !empty(a:pathname)
                                return xolox#misc#path#absolute(xolox#easytags#utils#resolve(a:pathname))
                              endif
                              return a:pathname
                            endfunction
                            
    1              0.000004 function! xolox#easytags#utils#resolve(pathname)
                              if !empty(a:pathname) && xolox#misc#option#get('easytags_resolve_links', 0)
                                return resolve(a:pathname)
                              endif
                              return a:pathname
                            endfunction

SCRIPT  /Users/jesushula/.yadr/vim/bundle/vim-misc/autoload/xolox/misc/async.vim
Sourced 1 time
Total time:   0.000775
 Self time:   0.000756

count  total (s)   self (s)
                            " Asynchronous Vim script evaluation.
                            "
                            " Author: Peter Odding <peter@peterodding.com>
                            " Last Change: September 17, 2014
                            " URL: http://peterodding.com/code/vim/misc/
                            "
                            " The `xolox#misc#async#call()` function builds on top of `xolox#misc#os#exec()`
                            " to support asynchronous evaluation of Vim scripts. The first (and for now
                            " only) use case is my [vim-easytags][] plug-in which has a bunch of
                            " conflicting requirements:
                            "
                            " 1. I want the [vim-easytags][] plug-in to be as portable as possible.
                            "    Ideally everything is implemented in Vim script because that's the only
                            "    thing I can rely on to be available for all potential users of the
                            "    plug-in!
                            "
                            " 2. Because of point one I've been forced to implement tags file reading,
                            "    parsing, (fold case) sorting and writing in Vim script. This is fine for
                            "    small tags files but once they grow to a couple of megabytes it becomes
                            "    annoying because Vim is unresponsive during tags file updates (key
                            "    presses are fortunately buffered due to Vim's input model but that
                            "    doesn't make it a nice user experience :-).
                            "
                            " 3. I could (and did in the past) come up with all sorts of hacks to speed
                            "    things up without switching away from Vim script, but none of them are
                            "    going to solve the fundamental problem that Vim's unresponsive hiccups
                            "    become longer as tags files grow larger.
                            "
                            " By now it should be clear where this is heading: _Why not handle tags file
                            " updates in a Vim process that runs in the background without blocking the
                            " Vim process that the user is interacting with?_ It turns out that there are
                            " quite a few details to take care of, but with those out of the way, it might
                            " just work! I'm actually hoping to make asynchronous updates the default mode
                            " in [vim-easytags][]. This means I need this functionality to be as
                            " portable and robust as possible.
                            "
                            " **Status:** This code has seen little testing so I wouldn't trust it too
                            " much just yet. On the other hand, as I said, my intention is to make this
                            " functionality as portable and robust as possible. You be the judge :-).
                            "
                            " [vim-easytags]: http://peterodding.com/code/vim/easytags/
                            
    1              0.000015 if !exists('g:xolox#misc#async#counter')
                              " Increasing integer number used to match asynchronous responses to the
                              " requests that generated them.
    1              0.000083   let g:xolox#misc#async#counter = 1
    1              0.000003 endif
                            
    1              0.000004 if !exists('g:xolox#misc#async#requests')
                              " Queue of asynchronous requests that haven't received a response yet.
    1              0.000043   let g:xolox#misc#async#requests = {}
    1              0.000002 endif
                            
    1              0.000008 function! xolox#misc#async#call(options) " {{{1
                              " Call a Vim script function asynchronously by starting a hidden Vim process
                              " in the background. Once the function returns the hidden Vim process
                              " terminates itself. This function takes a single argument which is a
                              " dictionary with the following key/value pairs:
                              "
                              "  - **function** (required): The name of the Vim function to call inside
                              "    the child process (a string). I suggest using an [autoload][] function
                              "    for this, see below.
                              "
                              "  - **arguments** (optional): A list of arguments to pass to the function.
                              "    This list is serialized to a string using [string()][] and deserialized
                              "    using [eval()][].
                              "
                              "  - **callback** (optional): The name of a Vim function to call in the
                              "    parent process when the child process has completed (a string).
                              "
                              "  - **clientserver** (optional): If this is true (1) the child process will
                              "    notify the parent process when it has finished (the default is true).
                              "    This works using Vim's client/server support which is not always
                              "    available. As a fall back Vim's [CursorHold][] automatic command is
                              "    also supported (although the effect is not quite as instantaneous :-).
                              "
                              " This functionality is experimental and non trivial to use, so consider
                              " yourself warned :-).
                              "
                              " **Limitations**
                              "
                              " I'm making this functionality available in [vim-misc][] because I think it
                              " can be useful to other plug-ins, however if you are going to use it you
                              " should be aware of the following limitations:
                              "
                              "  - Because of the use of multiple processes this functionality is only
                              "    suitable for 'heavy' tasks.
                              "
                              "  - The function arguments are serialized to a string which is passed to
                              "    the hidden Vim process as a command line argument, so the amount of
                              "    data you can pass will be limited by your operating environment.
                              "
                              "  - The hidden Vim process is explicitly isolated from the user in several
                              "    ways (see below for more details). This is to make sure that the hidden
                              "    Vim processes are fast and don't clobber the user's editing sessions in
                              "    any way.
                              "
                              " **Changes to how Vim normally works**
                              "
                              " You have to be aware that the hidden Vim process is initialized in a
                              " specific way that is very different from your regular Vim editing
                              " sessions:
                              "
                              "  - Your [vimrc][] file is ignored using the `-u NONE` command line option.
                              "
                              "  - Your [gvimrc][] file (if you even knew it existed ;-) is ignored using
                              "    the `-U NONE` command line option.
                              "
                              "  - Plug-in loading is skipped using the `--noplugin` command line option.
                              "
                              "  - Swap files (see [swap-file][]) are disabled using the `-n` command line
                              "    option. This makes sure asynchronous Vim processes don't disturb the
                              "    user's editing session.
                              "
                              "  - Your [viminfo][] file is ignored using the `-i NONE` command line
                              "    option. Just like with swap files this makes sure asynchronous Vim
                              "    processes don't disturb the user's editing session.
                              "
                              "  - No-compatible mode is enabled using the `-N` command line option
                              "    (usually the existence of your vimrc script would have achieved the
                              "    same effect but since we disable loading of your vimrc we need to spell
                              "    things out for Vim).
                              "
                              " **Use an auto-load function**
                              "
                              " The function you want to call is identified by its name which has to be
                              " defined, but I just explained above that all regular initialization is
                              " disabled for asynchronous Vim processes, so what gives? The answer is to
                              " use an [autoload][] function. This should work fine because the
                              " asynchronous Vim process 'inherits' the value of the ['runtimepath'][]
                              " option from your editing session.
                              "
                              " ['runtimepath']: http://vimdoc.sourceforge.net/htmldoc/options.html#'runtimepath'
                              " [autoload]: http://vimdoc.sourceforge.net/htmldoc/eval.html#autoload
                              " [CursorHold]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#CursorHold
                              " [eval()]: http://vimdoc.sourceforge.net/htmldoc/eval.html#eval()
                              " [gvimrc]: http://vimdoc.sourceforge.net/htmldoc/gui.html#gvimrc
                              " [string()]: http://vimdoc.sourceforge.net/htmldoc/eval.html#string()
                              " [swap-file]: http://vimdoc.sourceforge.net/htmldoc/recover.html#swap-file
                              " [vim-misc]: http://peterodding.com/code/vim/misc/
                              " [viminfo]: http://vimdoc.sourceforge.net/htmldoc/starting.html#viminfo
                              " [vimrc]: http://vimdoc.sourceforge.net/htmldoc/starting.html#vimrc
                              let unique_number = g:xolox#misc#async#counter
                              let g:xolox#misc#async#counter += 1
                              let request = {'function': a:options['function']}
                              let request['arguments'] = get(a:options, 'arguments', [])
                              let request['starttime'] = xolox#misc#timer#start()
                              let request['number'] = unique_number
                              let callback = get(a:options, 'callback')
                              if !empty(callback)
                                let request['callback'] = callback
                              endif
                              if get(a:options, 'clientserver', 1) && !empty(v:servername)
                                let request['servername'] = v:servername
                              else
                                let temporary_file = tempname()
                                let request['temporary_file'] = temporary_file
                              endif
                              let vim_command = printf('let &rtp = %s | call xolox#misc#async#inside_child(%s)', string(&rtp), string(request))
                              call xolox#misc#msg#debug("vim-misc %s: Generated asynchronous Vim command #%i: %s", g:xolox#misc#version, unique_number, vim_command)
                              let quoted_program = xolox#misc#escape#shell(xolox#misc#os#find_vim('vim'))
                              let quoted_command = xolox#misc#escape#shell(vim_command)
                              let shell_command = printf('%s -u NONE -U NONE --noplugin -n -N -i NONE --cmd %s', quoted_program, quoted_command)
                              call xolox#misc#msg#debug("vim-misc %s: Generated asynchronous shell command #%i: %s", g:xolox#misc#version, unique_number, shell_command)
                              call xolox#misc#os#exec({'command': shell_command, 'async': 1})
                              let g:xolox#misc#async#requests[unique_number] = request
                            endfunction
                            
    1              0.000007 function! xolox#misc#async#inside_child(request) " {{{1
                              " Entry point inside the hidden Vim process that runs in the background.
                              " Invoked indirectly by `xolox#misc#async#call()` because it runs a command
                              " similar to the following:
                              "
                              "     vim --cmd 'call xolox#misc#async#inside_child(...)'
                              "
                              " This function is responsible for calling the user defined function,
                              " capturing exceptions and reporting the results back to the parent Vim
                              " process using Vim's client/server support or a temporary file.
                              try
                                let response = {'number': a:request['number']}
                                let starttime = xolox#misc#timer#start()
                                try
                                  " Call the user defined function and store its result.
                                  let response['result'] = call(a:request['function'], a:request['arguments'])
                                catch
                                  " Intercept errors raised by the user defined function.
                                  let response['exception'] = v:exception
                                  let response['throwpoint'] = v:throwpoint
                                endtry
                                " Record the elapsed time.
                                let response['elapsed_time'] = xolox#misc#timer#convert(starttime)
                                " Communicate the results back to the master Vim process.
                                let servername = get(a:request, 'servername', '')
                                if !empty(servername)
                                  " Actively notify the parent process using Vim's client/server support?
                                  call remote_expr(servername, printf('xolox#misc#async#callback_to_parent(%s)', string(response)))
                                else
                                  " 'Passively' notify the parent process by creating the expected
                                  " temporary file.
                                  call xolox#misc#persist#save(a:request['temporary_file'], response)
                                endif
                              finally
                                " Make sure we terminate this hidden Vim process.
                                quitall!
                              endtry
                            endfunction
                            
    1              0.000004 function! xolox#misc#async#callback_to_parent(response) " {{{1
                              " When Vim was compiled with client/server support this function (in the
                              " parent process) will be called by `xolox#misc#async#inside_child()` (in
                              " the child process) after the user defined function has returned. This
                              " enables more or less instant callbacks after running an asynchronous
                              " function.
                              let unique_number = a:response['number']
                              let request = g:xolox#misc#async#requests[unique_number]
                              call xolox#misc#timer#stop("vim-misc %s: Processing asynchronous callback #%i after %s ..", g:xolox#misc#version, unique_number, request['starttime'])
                              call remove(g:xolox#misc#async#requests, unique_number)
                              let callback = get(request, 'callback')
                              if !empty(callback)
                                call call(callback, [a:response])
                              endif
                            endfunction
                            
    1              0.000011 function! xolox#misc#async#periodic_callback() " {{{1
                              " When client/server support is not being used the vim-misc plug-in
                              " improvises: It uses Vim's [CursorHold][] event to periodically check if an
                              " asynchronous process has written its results to one of the expected
                              " temporary files. If a response is found the temporary file is read and
                              " deleted and then `xolox#misc#async#callback_to_parent()` is called to
                              " process the response.
                              "
                              " [CursorHold]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#CursorHold
                              if !empty(g:xolox#misc#async#requests)
                                let num_processed = 0
                                call xolox#misc#msg#debug("vim-misc %s: Checking for asynchronous responses (%i responses not yet received) ..", g:xolox#misc#version, len(g:xolox#misc#async#requests))
                                for unique_number in sort(keys(g:xolox#misc#async#requests))
                                  let request = g:xolox#misc#async#requests[unique_number]
                                  let temporary_file = get(request, 'temporary_file', '')
                                  if !empty(temporary_file) && getfsize(temporary_file) > 0
                                    try
                                      call xolox#misc#msg#debug("vim-misc %s: Found asynchronous response by %s in %s ..", g:xolox#misc#version, request['function'], temporary_file)
                                      call xolox#misc#async#callback_to_parent(xolox#misc#persist#load(temporary_file))
                                      let num_processed += 1
                                    finally
                                      call delete(temporary_file)
                                    endtry
                                  endif
                                endfor
                                call xolox#misc#msg#debug("vim-misc %s: Processed %i asynchronous responses (%i responses not yet received).", g:xolox#misc#version, num_processed, len(g:xolox#misc#async#requests))
                              endif
                            endfunction
                            
                            " }}}1
                            
                            " The interval in the options below is set to one (1) although the default
                            " value for &updatetime is four seconds. Because vim-misc never modifies
                            " &updatetime the interval will effectively default to four seconds unless the
                            " user has set &updatetime to a lower value themselves.
    1   0.000057   0.000038 call xolox#misc#cursorhold#register({'function': 'xolox#misc#async#periodic_callback', 'interval': 1})
                            
                            " vim: ts=2 sw=2 et

SCRIPT  /Users/jesushula/.yadr/vim/bundle/zoomwin-vim/autoload/ZoomWin.vim
Sourced 1 time
Total time:   0.002527
 Self time:   0.002527

count  total (s)   self (s)
                            " ZoomWin:	Brief-like ability to zoom into/out-of a window
                            " Author:	Charles Campbell
                            "			original version by Ron Aaron
                            " Date:		Mar 09, 2014 
                            " Version:	25n	ASTRO-ONLY
                            " History: see :help zoomwin-history {{{1
                            " GetLatestVimScripts: 508 1 :AutoInstall: ZoomWin.vim
                            
                            " ---------------------------------------------------------------------
                            " Load Once: {{{1
    1              0.000066 if &cp || exists("g:loaded_ZoomWin")
                             finish
                            endif
    1              0.000005 if v:version < 702
                             echohl WarningMsg
                             echo "***warning*** this version of ZoomWin needs vim 7.2"
                             echohl Normal
                             finish
                            endif
    1              0.000026 let s:keepcpo        = &cpo
    1              0.000029 let g:loaded_ZoomWin = "v25n"
    1              0.000010 if !exists("g:zoomwin_localoptlist")
    1              0.000030  let s:localoptlist   = ["ai","ar","bh","bin","bl","bomb","bt","cfu","ci","cin","cink","cino","cinw","cms","com","cpt","diff","efm","eol","ep","et","fenc","fex","ff","flp","fo","ft","gp","imi","ims","inde","inex","indk","inf","isk","key","kmp","lisp","mps","ml","ma","mod","nf","ofu","oft","pi","qe","ro","sw","sn","si","sts","spc","spf","spl","sua","swf","smc","syn","ts","tx","tw","udf","wfh","wfw","wm"]
    1              0.000002 else
                             let s:localoptlist   = g:zoomwin_localoptlist
                            endif
    1              0.000068 set cpo&vim
                            "DechoTabOn
                            
                            " =====================================================================
                            "  Functions: {{{1
                            
                            " ---------------------------------------------------------------------
                            " ZoomWin#ZoomWin: toggles between a single-window and a multi-window layout {{{2
                            "          The original version was by Ron Aaron.
    1              0.000017 fun! ZoomWin#ZoomWin()
                            "  let g:decho_hide= 1		"Decho
                              let lzkeep = &lz
                              set lz
                            "  call Dfunc("ZoomWin#ZoomWin() winbufnr(2)=".winbufnr(2))
                            
                              " if the vim doesn't have +mksession, only a partial zoom is available {{{3
                              if !has("mksession")
                               if !exists("s:partialzoom")
                                echomsg "missing the +mksession feature; only a partial zoom is available"
                            	let s:partialzoom= 0
                               endif
                               if v:version < 630
                               	echoerr "***sorry*** you need an updated vim, preferably with +mksession"
                               elseif s:partialzoom
                               	" partial zoom out
                            	let s:partialzoom= 0
                            	exe s:winrestore
                               else
                               	" partial zoom in
                            	let s:partialzoom= 1
                            	let s:winrestore = winrestcmd()
                            	res
                               endif
                               let &lz = lzkeep
                            "   call Dret("ZoomWin#ZoomWin : partialzoom=".s:partialzoom)
                               return
                              endif
                            
                              " Close certain windows and save user settings {{{3
                              call s:ZoomWinPreserve(0)
                              call s:SaveUserSettings()
                            
                              if winbufnr(2) == -1
                                " there's only one window - restore to multiple-windows mode (zoom out) {{{3
                            "	call Decho("there's only one window - restore to multiple windows")
                            
                                if exists("s:sessionfile") && filereadable(s:sessionfile)
                            	  " save position in current one-window-only
                            "	  call Decho("save position in current one-window-only in sponly  (s:sessionfile<".s:sessionfile.">)")
                                  let sponly     = s:SavePosn(0)
                                  let s:origline = line(".")
                                  let s:origcol  = virtcol(".")
                            	  let s:swv      = deepcopy(getwinvar(winnr(),""),1)
                            	  sil! unlet key value
                            	  for [key,value] in items(s:swv)
                            	   exe "sil! unlet w:".key
                            	   sil! unlet key value
                            	  endfor
                            
                                  " source session file to restore window layout
                            	  let ei_keep = &ei
                            	  set ei=all noswf bh=hide
                            	  exe 'sil! so '.fnameescape(s:sessionfile)
                                  let v:this_session= s:sesskeep
                            	  let winrestore = winrestcmd()
                            	  " restore any and all window variables
                            	  call s:RestoreWinVars()
                            
                                  if exists("s:savedposn1")
                                    " restore windows' positioning and buffers
                            "		call Decho("restore windows, positions, buffers")
                            		noautocmd windo call s:RestorePosn(s:savedposn{winnr()})|unlet s:savedposn{winnr()}
                                    call s:GotoWinNum(s:winkeep)
                            		execute winrestore
                                    unlet s:winkeep
                                  endif
                            
                            	  if exists("s:swv")
                            	   " restore window variables which possibly were modified while in one-window mode
                                   for [key,value] in items(s:swv)
                            		sil! call setwinvar(winnr(),key,value)
                            		sil! unlet key value
                            	   endfor
                            	  endif
                            
                            	  if line(".") != s:origline || virtcol(".") != s:origcol
                            	   " If the cursor hasn't moved from the original position,
                            	   " then let the position remain what it was in the original
                            	   " multi-window layout.
                            "	   call Decho("restore position using sponly")
                                   call s:RestorePosn(sponly)
                            	  endif
                            
                            	  " delete session file and variable holding its name
                            "	  call Decho("delete session file<".s:sessionfile.">")
                            "      call delete(s:sessionfile)
                                  unlet s:sessionfile
                            	  let &ei  = ei_keep
                                endif
                            
                            	" I don't know why -- but netrw-generated windows end up as [Scratch] even though the bufname is correct.
                            	" Following code fixes this.  Without the if..[Scratch] test, though, when one attempts to write a file
                            	" one gets an E13.  Thus, only [Scratch] windows will be affected by this windo command.
                            	let curwin= winnr()
                            	let winrestore = winrestcmd()
                            	noautocmd windo if bufname(winbufnr(winnr())) == '[Scratch]'|exe "sil! file ".fnameescape(bufname(winbufnr(winnr())))|endif
                            	exe curwin."wincmd w"
                            
                            	" Restore local window settings
                            	call s:RestoreWinSettings()
                            	execute winrestore
                            
                            	" zoomwinstate used by g:ZoomWin_funcref()
                            	let zoomwinstate= 0
                            
                               else " there's more than one window - go to only-one-window mode (zoom in){{{3
                            "	call Decho("there's multiple windows - goto one-window-only")
                            
                                let s:winkeep    = winnr()
                                let s:sesskeep   = v:this_session
                            
                            	" doesn't work with the command line window (normal mode q:)
                             	if &bt == "nofile" && expand("%") == (v:version < 702 ? 'command-line' : '[Command Line]')
                            	 echoerr "***error*** ZoomWin#ZoomWin doesn't work with the ".expand("%")." window"
                                 let &lz= lzkeep
                            "     call Dret("ZoomWin#ZoomWin : ".expand('%')." window error")
                            	 return
                            	endif
                            
                            	" disable all events (autocmds)
                            "	call Decho("disable events")
                                let ei_keep= &ei
                            	set ei=all
                            	let winrestore = winrestcmd()
                            
                            	" Save local window settings
                            	call s:SaveWinSettings()
                            
                            	" save all window variables
                            	call s:SaveWinVars()
                            
                                " save window positioning commands
                            "	call Decho("save window positioning commands")
                            	noautocmd windo let s:savedposn{winnr()}= s:SavePosn(1)
                                call s:GotoWinNum(s:winkeep)
                            	execute winrestore
                            
                                " set up name of session file
                                let s:sessionfile= tempname()
                            "	call Decho("s:sessionfile<".s:sessionfile.">")
                            
                                " save session
                            "	call Decho("save session")
                                let ssop_keep = &ssop
                            	let &ssop     = 'blank,help,winsize,folds,globals,localoptions,options'
                            	exe 'mksession! '.fnameescape(s:sessionfile)
                            	let keepyy= @@
                            	let keepy0= @0
                            	let keepy1= @1
                            	let keepy2= @2
                            	let keepy3= @3
                            	let keepy4= @4
                            	let keepy5= @5
                            	let keepy6= @6
                            	let keepy7= @7
                            	let keepy8= @8
                            	let keepy9= @9
                                set lz ei=all bh=
                            	if v:version >= 700
                            	 let curwin = winnr()
                            
                            	 try
                            	  exe "keepalt keepmarks new! ".fnameescape(s:sessionfile)
                            	 catch /^Vim\%((\a\+)\)\=:E/
                            	  let seswin = -1
                            	  windo if winheight(winnr()) > 1 | let seswin= winnr() | endif
                            	  if seswin < 0
                            	   echoerr "Too many windows (not enough room)"
                                   sil! call delete(s:sessionfile)
                                   unlet s:sessionfile
                                   let &lz= lzkeep
                            "       call Dret("ZoomWin#ZoomWin : too many windows")
                                   return
                            	  endif
                            	  exe seswin."wincmd w"
                            	  exe "keepalt keepmarks new! ".fnameescape(s:sessionfile)
                            	 endtry
                            	 " modify the session (so that it merely restores window layout)
                                 sil! keepjumps keepmarks v/wincmd\|split\|resize/d
                            	 " save modified session
                            	 " wipe out session window and buffer
                            	 " restore cursor to the window that was current before editing the session file
                                 keepalt w!
                                 keepalt bw!
                            	 exe curwin."wincmd w"
                            	else
                            	 exe "new! ".fnameescape(s:sessionfile)
                                 v/wincmd\|split\|resize/d
                                 w!
                                 bw!
                                endif
                            	let @@= keepyy
                            	let @0= keepy0
                            	let @1= keepy1
                            	let @2= keepy2
                            	let @3= keepy3
                            	let @4= keepy4
                            	let @5= keepy5
                            	let @6= keepy6
                            	let @7= keepy7
                            	let @8= keepy8
                            	let @9= keepy9
                                call histdel('search', -1)
                                let @/ = histget('search', -1)
                            
                                " restore user's session options and restore event handling
                            "	call Decho("restore user session options and event handling")
                                set nolz
                                let &ssop = ssop_keep
                            	let curwin= winnr()
                                sil! only!
                                let &ei   = ei_keep
                                echomsg expand("%")
                            	call s:RestoreOneWinSettings(curwin)
                            
                            	" zoomwinstate used by g:ZoomWin_funcref()
                            	let zoomwinstate= 1
                              endif
                            
                              " restore user option settings {{{3
                              call s:RestoreUserSettings()
                            
                              " Re-open certain windows {{{3
                              call s:ZoomWinPreserve(1)
                              
                              " call user's optional funcref (callback) functions
                              if exists("g:ZoomWin_funcref")
                               if type(g:ZoomWin_funcref) == 2
                            	call g:ZoomWin_funcref(zoomwinstate)
                               elseif type(g:ZoomWin_funcref) == 3
                                for Fncref in g:ZoomWin_funcref
                                 if type(Fncref) == 2
                            	  call Fncref(zoomwinstate)
                                 endif
                                endfor
                               endif
                              endif
                            
                              let &lz= lzkeep
                            "  call Dret("ZoomWin#ZoomWin")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " SavePosn: this function sets up a savedposn variable that {{{2
                            "          has the commands necessary to restore the view
                            "          of the current window.
    1              0.000013 fun! s:SavePosn(savewinhoriz)
                            "  call Dfunc("SavePosn(savewinhoriz=".a:savewinhoriz.") file<".expand("%").">")
                              let swline = line(".")
                              if swline == 1 && getline(1) == ""
                               " empty buffer
                               let savedposn= "silent b ".winbufnr(0)
                            "   call Dret("SavePosn savedposn<".savedposn.">")
                               return savedposn
                              endif
                              let swcol = col(".")
                              if swcol >= col("$")
                               let swcol= swcol + virtcol(".") - virtcol("$")  " adjust for virtual edit (cursor past end-of-line)
                              endif
                              let swwline   = winline()-1
                              let swwcol    = virtcol(".") - wincol()
                            "  call Decho("swline #".swline)
                            "  call Decho("swcol  #".swcol)
                            "  call Decho("swwline#".swwline)
                            "  call Decho("swwcol #".swwcol)
                            
                              let savedposn = "sil! b ".winbufnr(0)
                              let savedposn = savedposn."|".swline
                              let savedposn = savedposn."|sil! norm! 0z\<cr>"
                              if swwline > 0
                               let savedposn= savedposn.":sil! norm! ".swwline."\<c-y>\<cr>"
                              endif
                            
                              if a:savewinhoriz
                               if swwcol > 0
                                let savedposn= savedposn.":sil! norm! 0".swwcol."zl\<cr>"
                               endif
                               let savedposn= savedposn.":sil! call cursor(".swline.",".swcol.")\<cr>"
                            
                               " handle certain special settings for the multi-window savedposn call
                               "   bufhidden buftype buflisted
                               let settings= ""
                               if &bh != ""
                            "	call Decho("special handling: changing buf#".bufnr("%")."'s bh=".&bh." to hide")
                               	let settings="bh=".&bh
                            	setl bh=hide
                               endif
                               if !&bl
                            "	call Decho("special handling: changing buf#".bufnr("%")."'s bl=".&bl." to bl")
                               	let settings= settings." nobl"
                            	setl bl
                               endif
                               if &bt != ""
                            "	call Decho("special handling: changing buf#".bufnr("%")."'s bt=".&bt.' to ""')
                               	let settings= settings." bt=".&bt
                            	setl bt=
                               endif
                               if settings != ""
                               	let savedposn= savedposn.":setl ".settings."\<cr>"
                               endif
                            
                              else
                               let savedposn= savedposn.":sil! call cursor(".swline.",".swcol.")\<cr>"
                              endif
                            "  call Dret("SavePosn savedposn<".savedposn."> : buf#".bufnr("%")." bh=".&bh." bl=".&bl." bt=".&bt)
                              return savedposn
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:RestorePosn: this function restores noname and scratch windows {{{2
    1              0.000009 fun! s:RestorePosn(savedposn)
                            "  call Dfunc("RestorePosn(savedposn<".a:savedposn.">) win#".winnr()." scb=".&scb)
                              if &scb
                               setl noscb
                            "   try " Decho
                                exe a:savedposn
                            "   catch /^Vim\%((\a\+)\)\=:E/   " Decho
                            "	call Decho("error occurred") " Decho
                            "   endtry " Decho
                               setl scb
                              else
                            "   try " Decho
                                exe a:savedposn
                            "   catch /^Vim\%((\a\+)\)\=:E/   " Decho
                            "	call Decho("error occurred") " Decho
                            "   endtry                        " Decho
                              endif
                            "  call Dret("RestorePosn")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " CleanupSessionFile: if you exit Vim before cleaning up the {{{2
                            "                     supposed-to-be temporary session file
    1              0.000009 fun! ZoomWin#CleanupSessionFile()
                            "  call Dfunc("ZoomWin#CleanupSessionFile()")
                              if exists("s:sessionfile") && filereadable(s:sessionfile)
                            "   call Decho("sessionfile exists and is readable; deleting it")
                               sil! call delete(s:sessionfile)
                               unlet s:sessionfile
                              endif
                            "  call Dret("ZoomWin#CleanupSessionFile")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " GotoWinNum: this function puts cursor into specified window {{{2
    1              0.000005 fun! s:GotoWinNum(winnum)
                            "  call Dfunc("GotoWinNum(winnum=".a:winnum.") winnr=".winnr())
                              if a:winnum != winnr()
                               exe a:winnum."wincmd w"
                              endif
                            "  call Dret("GotoWinNum")
                            endfun
                            
                            
                            " ---------------------------------------------------------------------
                            " ZoomWinPreserve:  This function, largely written by David Fishburn, {{{2
                            "   allows ZoomWin to "preserve" certain windows:
                            "
                            "   	TagList, by Yegappan Lakshmanan
                            "   	  http://vim.sourceforge.net/scripts/script.php?script_id=273
                            "
                            "   	WinManager, by Srinath Avadhanula
                            "   	  http://vim.sourceforge.net/scripts/script.php?script_id=95
                            "
                            "  It does so by closing the associated window upon entry to ZoomWin
                            "  and re-opening it upon exit by using commands provided by the
                            "  utilities themselves.
    1              0.000005 fun! s:ZoomWinPreserve(open)
                            "  call Dfunc("ZoomWinPreserve(open=".a:open.")")
                            
                              if a:open == 0
                            
                               " Close Taglist
                               if exists('g:zoomwin_preserve_taglist') && exists('g:loaded_taglist')
                                   " If taglist window is open then close it.
                                   let s:taglist_winnum = bufwinnr(g:TagList_title)
                                   if s:taglist_winnum != -1
                                       " Close the window
                                       exec "sil! Tlist"
                                   endif
                               endif
                            
                               " Close Winmanager
                               if exists('g:zoomwin_preserve_winmanager') && exists('g:loaded_winmanager')
                                   " If the winmanager window is open then close it.
                                   let s:is_winmgr_vis = IsWinManagerVisible()
                                   if s:is_winmgr_vis == 1
                                       exec "WMClose"
                                   endif
                               endif
                            
                              else
                            
                               " Re-open Taglist
                               if exists('g:zoomwin_preserve_taglist') && exists('g:loaded_taglist')
                                   " If taglist window was open, open it again
                                   if s:taglist_winnum != -1
                                       exec "sil! Tlist"
                                   endif
                               endif
                            
                               " Re-Open Winmanager
                               if exists('g:zoomwin_preserve_winmanager') && exists('g:loaded_winmanager')
                                   " If the winmanager window is open then close it.
                                   if s:is_winmgr_vis == 1
                                       exec "WManager"
                                   endif
                               endif
                              endif
                            
                            "  call Dret("ZoomWinPreserve")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:SaveWinVars: saves a copy of all window-variables into the script variable s:swv_#, {{{2
                            "                where # is the current window number, for all windows.
    1              0.000004 fun! s:SaveWinVars()
                            "  call Dfunc("s:SaveWinVars()")
                              noautocmd windo let s:swv_{winnr()}= deepcopy(getwinvar(winnr(),""),1)|let s:swvmatches_{winnr()}= getmatches()
                            "  call Dret("s:SaveWinVars")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:RestoreWinVars: restores window variables for all windows {{{2
    1              0.000003 fun! s:RestoreWinVars()
                            "  call Dfunc("s:RestoreWinVars()")
                            "  windo call Decho(string(s:swv_{winnr()}))
                              noautocmd windo if exists("s:swv_{winnr()}")     |sil! unlet s:key s:value     |for [s:key,s:value] in items(s:swv_{winnr()})|call setwinvar(winnr(),s:key,s:value)|exe "sil! unlet s:key s:value"|endfor|call setmatches(s:swvmatches_{winnr()})|unlet s:swvmatches_{winnr()}|unlet s:swv_{winnr()}|endif
                            "  call Dret("s:RestoreWinVars")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:SaveUserSettings: save user options, set to zoomwin-safe options.  {{{2
                            "                     Force window minimum height/width to be >= 1
    1              0.000004 fun! s:SaveUserSettings()
                            "  call Dfunc("s:SaveUserSettings()")
                            
                              let s:keep_hidden = &hidden
                              let s:keep_shm    = &shm
                              let s:keep_siso   = &siso
                              let s:keep_so     = &so
                              let s:keep_ss     = &ss
                              let s:keep_wfh    = &wfh
                              let s:keep_write  = &write
                              if has("clipboard")
                            "   call Decho("@* save    before: s:keep_star=".@*)
                               let s:keep_star   = @*
                            "   call Decho("@* save    after : s:keep_star=".@*)
                              endif
                              let s:keep_swf    = &swf
                            
                              if v:version < 603
                               if &wmh == 0 || &wmw == 0
                                let s:keep_wmh = &wmh
                                let s:keep_wmw = &wmw
                                sil! set wmh=1 wmw=1
                               endif
                              endif
                              set hidden write nowfh so=0 siso=0 ss=0 shm+=A
                            "  call Dret("s:SaveUserSettings")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:RestoreUserSettings: restore user option settings {{{2
    1              0.000003 fun! s:RestoreUserSettings()
                            "  call Dfunc("s:RestoreUserSettings()")
                            "  call Decho("restore user option settings")
                              let &hidden= s:keep_hidden
                              let &shm   = s:keep_shm
                              let &siso  = s:keep_siso
                              let &so    = s:keep_so
                              let &ss    = s:keep_ss
                              let &wfh   = s:keep_wfh
                              let &write = s:keep_write
                              if has("clipboard") && exists("s:keep_star")
                            "   call Decho( "@* restore before: s:keep_star=".@*)
                               let @*     = s:keep_star
                            "   call Decho("@* restore after : s:keep_star=".@*)
                              endif
                              let &swf   = s:keep_swf
                              if v:version < 603
                               if exists("s:keep_wmw")
                                let &wmh= s:keep_wmh
                                let &wmw= s:keep_wmw
                               endif
                              endif
                            "  call Dret("s:RestoreUserSettings")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:SaveWinSettings: saves all windows' local settings {{{2
    1              0.000004 fun! s:SaveWinSettings()
                            "  call Dfunc("s:SaveWinSettings() curwin#".winnr())
                              if exists("s:localoptlist") && !empty(s:localoptlist)
                               let curwin= winnr()
                               for localopt in s:localoptlist
                                noautocmd windo exe "let s:swv_".localopt."_{winnr()}= &".localopt
                               endfor
                               exe "noautocmd ".curwin."wincmd w"
                              endif
                            "  call Dret("s:SaveWinSettings : &bt=".&bt." s:swv_bt_".curwin."=".s:swv_bt_{curwin})
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:RestoreWinSettings: restores all windows' local settings {{{2
    1              0.000003 fun! s:RestoreWinSettings()
                            "  call Dfunc("s:RestoreWinSettings() bh=".&bh." bt=".&bt." bl=".&bl)
                              if exists("s:localoptlist") && !empty(s:localoptlist)
                               let curwin= winnr()
                               for localopt in s:localoptlist
                                exe 'noautocmd windo if exists("s:swv_'.localopt.'_{winnr()}")|if &'.localopt.'!=# s:swv_'.localopt.'_{winnr()}|let &'.localopt.'= s:swv_'.localopt.'_{winnr()}|endif|unlet s:swv_'.localopt.'_{winnr()}|endif'
                               endfor
                               exe "noautocmd ".curwin."wincmd w"
                              endif
                            "  call Dret("s:RestoreWinSettings : bh=".&bh." bt=".&bt." bl=".&bl)
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:RestoreOneWinSettings: assumes that s:SaveWinSettings() was called previously; this function restores the specified window's local settings {{{2
    1              0.000005 fun! s:RestoreOneWinSettings(wnum)
                            "  call Dfunc("s:RestoreOneWinSettings(wnum=".a:wnum.") s:swv_bt_".a:wnum."=".s:swv_bt_{a:wnum}." bh=".&bh." bt=".&bt." bl=".&bl)
                              if exists("s:localoptlist") && !empty(s:localoptlist)
                               for localopt in s:localoptlist
                            "    call Decho('windo if exists("s:swv_'.localopt.'_{a:wnum}")|let &'.localopt.'= s:swv_'.localopt.'_{a:wnum}|unlet s:swv_'.localopt.'_{a:wnum}|endif')
                                exe 'noautocmd windo if exists("s:swv_'.localopt.'_{a:wnum}")|if &'.localopt.'!=# s:swv_'.localopt.'_{a:wnum}|let &'.localopt.'= s:swv_'.localopt.'_{a:wnum}|endif|unlet s:swv_'.localopt.'_{a:wnum}|endif'
                               endfor
                              endif
                            "  call Dret("s:RestoreOneWinSettings : bh=".&bh." bt=".&bt." bl=".&bl)
                            endfun
                            
                            " =====================================================================
                            "  Restore: {{{1
    1              0.000021 let &cpo= s:keepcpo
    1              0.000004 unlet s:keepcpo
                            
                            " ---------------------------------------------------------------------
                            "  Modelines: {{{1
                            " vim: ts=4 fdm=marker

FUNCTION  xolox#misc#os#exec()
Called 2 times
Total time:   0.113173
 Self time:   0.002052

count  total (s)   self (s)
                              " Execute an external command (hiding the console on Microsoft Windows when
                              " my [vim-shell plug-in] [vim-shell] is installed).
                              "
                              " Expects a dictionary with the following key/value pairs as the first
                              " argument:
                              "
                              " - **command** (required): The command line to execute
                              " - **async** (optional): set this to 1 (true) to execute the command in the
                              "   background (asynchronously)
                              " - **stdin** (optional): a string or list of strings with the input for the
                              "   external command
                              " - **check** (optional): set this to 0 (false) to disable checking of the
                              "   exit code of the external command (by default an exception will be
                              "   raised when the command fails)
                              "
                              " Returns a dictionary with one or more of the following key/value pairs:
                              "
                              " - **command** (always available): the generated command line that was used
                              "   to run the external command
                              " - **exit_code** (only in synchronous mode): the exit status of the
                              "   external command (an integer, zero on success)
                              " - **stdout** (only in synchronous mode): the output of the command on the
                              "   standard output stream (a list of strings, one for each line)
                              " - **stderr** (only in synchronous mode): the output of the command on the
                              "   standard error stream (as a list of strings, one for each line)
                              "
                              " [vim-shell]: http://peterodding.com/code/vim/shell/
    2              0.000003   try
                            
                                " Unpack the options.
    2              0.000008     let cmd = a:options['command']
    2              0.000010     let async = get(a:options, 'async', 0)
                            
                                " We need to know in a couple of places whether we are on Windows.
    2   0.000046   0.000020     let is_win = xolox#misc#os#is_win()
                            
                                " Use vim-shell so we don't pop up a console window on Windows? If the
                                " caller specifically asks us *not* to use vim-shell, we'll respect that
                                " choice; this is very useful for automated tests :-).
    2              0.000009     if get(a:options, 'use_dll', 1) == 0
                                  let use_dll = 0
                                else
    2   0.006629   0.000023       let use_dll = xolox#misc#os#can_use_dll()
    2              0.000002     endif
                            
                                " Decide whether to redirect the standard output and standard error
                                " streams to temporary files.
    2              0.000010     let redirect_output = !async && (use_dll || !is_win)
                            
                                " Write the input for the external command to a temporary file?
    2              0.000013     if has_key(a:options, 'stdin') && use_dll
                                  let tempin = tempname()
                                  if type(a:options['stdin']) == type([])
                                    let lines = a:options['stdin']
                                  else
                                    let lines = split(a:options['stdin'], "\n")
                                  endif
                                  call writefile(lines, tempin)
                                  let cmd .= ' < ' . xolox#misc#escape#shell(tempin)
                                endif
                            
                                " Redirect the standard output and/or standard error streams of the
                                " external process to temporary files? (only in synchronous mode)
    2              0.000010     if redirect_output
    1              0.000016       let tempout = tempname()
    1              0.000002       let temperr = tempname()
    1   0.000084   0.000018       let cmd = printf('(%s) 1>%s 2>%s', cmd, xolox#misc#escape#shell(tempout), xolox#misc#escape#shell(temperr))
    1              0.000001     endif
                            
                                " Use vim-shell or system() to execute the external command?
    2              0.000002     if use_dll
                                  call xolox#misc#msg#debug("vim-misc %s: Executing external command using compiled DLL: %s", g:xolox#misc#version, cmd)
                                  let exit_code = xolox#shell#execute_with_dll(cmd, async)
                                else
                            
                                  " Enable asynchronous mode (very platform specific).
    2              0.000002       if async
    1              0.000001         if is_win
                                      " As pointed out in issue 17 [1] the use of `:!start' on Windows
                                      " requires characters like `!', `%' and `#' to be escaped with a
                                      " backslash [2]. Vim's shellescape() function knows how to escape
                                      " these special characters however the use of `:!start' is an
                                      " implementation detail of xolox#misc#os#exec() so I don't want to
                                      " bother callers (who perform the shell escaping) with such a
                                      " specific implementation detail. This is why I resort to manually
                                      " escaping characters documented to have a special meaning [2].
                                      "
                                      " [1] https://github.com/xolox/vim-misc/issues/17
                                      " [2] All characters interpreted specially in shell command lines
                                      "     executed from Vim's command mode, refer to `:help :!' for
                                      "     details.
                                      let cmd = printf('start /b %s', escape(cmd, "\\\n!%#"))
                                    elseif has('unix')
    1              0.000011           let cmd = printf('(%s) &', cmd)
    1              0.000001         else
                                      call xolox#misc#msg#warn("vim-misc %s: I don't know how to execute the command %s asynchronously on your platform! Falling back to synchronous mode...", g:xolox#misc#version, cmd)
                                    endif
    1              0.000001       endif
                            
                                  " On UNIX we explicitly execute the command line using 'sh' instead of
                                  " the default shell, because we assume that standard output and standard
                                  " error can be redirected separately, but (t)csh does not support this
                                  " (and it might be the default shell).
    2              0.000004       if has('unix')
    2   0.000049   0.000019         call xolox#misc#msg#debug("vim-misc %s: Generated shell expression: %s", g:xolox#misc#version, cmd)
    2   0.000252   0.000021         let cmd = printf('sh -c %s', xolox#misc#escape#shell(cmd))
    2              0.000002       endif
                            
                                  " Let the user know what's happening (in case they're interested).
    2              0.000003       if async && is_win
                                    call xolox#misc#msg#debug("vim-misc %s: Executing external command using !start command: %s", g:xolox#misc#version, cmd)
                                    silent execute '!' . cmd
                                  else
    2   0.000034   0.000014         call xolox#misc#msg#debug("vim-misc %s: Executing external command using system() function: %s", g:xolox#misc#version, cmd)
    2              0.000005         let arguments = [cmd]
    2              0.000005         if has_key(a:options, 'stdin')
                                      if type(a:options['stdin']) == type([])
                                        call add(arguments, join(a:options['stdin'], "\n"))
                                      else
                                        call add(arguments, a:options['stdin'])
                                      endif
                                    endif
    2   0.104959   0.000940         let stdout = call('system', arguments)
    2              0.000027         let exit_code = v:shell_error
    2              0.000006       endif
                            
    2              0.000003     endif
                            
                                " Return the results as a dictionary with one or more key/value pairs.
    2              0.000031     let result = {'command': cmd}
    2              0.000006     if !async
    1              0.000005       let result['exit_code'] = exit_code
                                  " Get the standard output of the command.
    1              0.000002       if redirect_output
    1   0.000136   0.000052         let result['stdout'] = s:readfile(tempout, 'standard output', a:options['command'])
    1              0.000004       elseif exists('stdout')
                                    let result['stdout'] = split(stdout, "\n")
                                  else
                                    let result['stdout'] = []
                                  endif
                                  " Get the standard error of the command.
    1              0.000006       if exists('temperr')
    1   0.000053   0.000014         let result['stderr'] = s:readfile(temperr, 'standard error', a:options['command'])
    1              0.000002       else
                                    let result['stderr'] = []
                                  endif
                                  " If we just executed a synchronous command and the caller didn't
                                  " specifically ask us *not* to check the exit code of the external
                                  " command, we'll do so now. The idea here is that it should be easy
                                  " to 'do the right thing'.
    1              0.000008       if get(a:options, 'check', 1) && exit_code != 0
                                    " Prepare an error message with enough details so the user can investigate.
                                    let msg = printf("vim-misc %s: External command failed with exit code %d!", g:xolox#misc#version, result['exit_code'])
                                    let msg .= printf("\nCommand line: %s", result['command'])
                                    " If the external command reported an error, we'll include it in our message.
                                    if !empty(result['stderr'])
                                      " This is where we would normally expect to find an error message.
                                      let msg .= printf("\nOutput on standard output stream:\n%s", join(result['stderr'], "\n"))
                                    elseif !empty(result['stdout'])
                                      " Exuberant Ctags on Windows XP reports errors on standard output :-x.
                                      let msg .= printf("\nOutput on standard error stream:\n%s", join(result['stdout'], "\n"))
                                    endif
                                    throw msg
                                  endif
    1              0.000001     endif
    2              0.000005     return result
                            
                              finally
                                " Cleanup any temporary files we created.
    8              0.000033     for name in ['tempin', 'tempout', 'temperr']
    6              0.000027       if exists(name)
    2              0.000189         call delete({name})
    2              0.000004       endif
    6              0.000008     endfor
    2              0.000011   endtry
                            

FUNCTION  <SNR>237_resetomnicomplete()
Called 2 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    2              0.000010   if exists("+completefunc") && &completefunc == 'syntaxcomplete#Complete'
                                if exists("g:loaded_syntax_completion")
                                  " Ugly but necessary, until we have our own completion
                                  unlet g:loaded_syntax_completion
                                  silent! delfunction syntaxcomplete#Complete
                                endif
                              endif

FUNCTION  <SNR>158_NERDTreeCacheDirtyDir()
Called 117 times
Total time:   0.011513
 Self time:   0.009196

count  total (s)   self (s)
                                " cache dirty dir
  117   0.003267   0.000950     let l:dirtyPath = s:NERDTreeTrimDoubleQuotes(a:pathStr)
  117              0.000707     if l:dirtyPath =~# '\.\./.*'
                                    return
                                endif
  117              0.001613     let l:dirtyPath = substitute(l:dirtyPath, '/[^/]*$', '/', '')
  182              0.002788     while l:dirtyPath =~# '.\+/.*' && has_key(b:NERDTreeCachedGitDirtyDir, fnameescape(l:dirtyPath)) == 0
   65              0.000591         let b:NERDTreeCachedGitDirtyDir[fnameescape(l:dirtyPath)] = 'Dirty'
   65              0.000768         let l:dirtyPath = substitute(l:dirtyPath, '/[^/]*/$', '/', '')
   65              0.000106     endwhile

FUNCTION  <SNR>272_GetFiletype()
Called 2 times
Total time:   0.000350
 Self time:   0.000350

count  total (s)   self (s)
    2              0.000009     let ft = a:0 >= 1 && !empty(a:1) ? a:1 : &filetype
    2              0.000005     let poss = a:0 >= 2 ? a:2 : [-1, 1, 0]
    6              0.000009     for pos in poss
    4              0.000013         Tlibtrace 'tcomment', ft, pos
    4              0.000004         if pos == -1
    2              0.000004             let rv = ft
    2              0.000002         else
    2              0.000018             let fts = split(ft, '^\@!\.')
                                        " TLogVAR fts
                                        " let ft = substitute(ft, '\..*$', '', '')
    2              0.000007             let rv = get(fts, pos, ft)
                                        " TLogVAR fts, rv
    2              0.000002         endif
    4              0.000079         let fts_rx = '^\%('. join(map(keys(g:tcomment#filetype_map), 'escape(v:val, ''\'')'), '\|') .'\)$'
    4              0.000012         Tlibtrace 'tcomment', fts_rx
    4              0.000030         if rv =~ fts_rx
                                        for [ft_rx, ftrv] in items(g:tcomment#filetype_map)
                                            " TLogVAR ft_rx, ftrv
                                            if rv =~ ft_rx
                                                let rv = substitute(rv, ft_rx, ftrv, '')
                                                Tlibtrace 'tcomment', ft_rx, rv
                                                Tlibtrace 'tcomment', rv
                                                return rv
                                            endif
                                        endfor
                                    endif
    4              0.000004     endfor
    2              0.000006     Tlibtrace 'tcomment', ft
    2              0.000003     return ft

FUNCTION  gitgutter#all()
Called 3 times
Total time:   0.019628
 Self time:   0.000853

count  total (s)   self (s)
   10   0.000254   0.000156   for buffer_id in gitgutter#utility#dedup(tabpagebuflist())
    7              0.000351     let file = expand('#' . buffer_id . ':p')
    7              0.000028     if !empty(file)
    7   0.018829   0.000152       call gitgutter#process_buffer(buffer_id, 0)
    7              0.000010     endif
    7              0.000029   endfor

FUNCTION  gitgutter#utility#highlight_name_for_change()
Called 20 times
Total time:   0.000256
 Self time:   0.000256

count  total (s)   self (s)
   20              0.000041   if a:text ==# 'added'
                                return 'GitGutterLineAdded'
                              elseif a:text ==# 'removed'
                                return 'GitGutterLineRemoved'
                              elseif a:text ==# 'removed_first_line'
                                return 'GitGutterLineRemovedFirstLine'
                              elseif a:text ==# 'modified'
   20              0.000028     return 'GitGutterLineModified'
                              elseif a:text ==# 'modified_removed'
                                return 'GitGutterLineModifiedRemoved'
                              endif

FUNCTION  gitgutter#utility#command_in_directory_of_file()
Called 8 times
Total time:   0.000234
 Self time:   0.000096

count  total (s)   self (s)
    8   0.000228   0.000090   return 'cd '.gitgutter#utility#shellescape(gitgutter#utility#directory_of_file()).' && '.a:cmd

FUNCTION  <SNR>272_Strdisplaywidth()
Called 2 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    2              0.000008         return call('strdisplaywidth', a:000)

FUNCTION  ale#engine#InitBufferInfo()
Called 4 times
Total time:   0.000087
 Self time:   0.000087

count  total (s)   self (s)
    4              0.000046     if !has_key(g:ale_buffer_info, a:buffer)
                                    " job_list will hold the list of jobs
                                    " loclist holds the loclist items after all jobs have completed.
                                    " new_loclist holds loclist items while jobs are being run.
                                    let g:ale_buffer_info[a:buffer] = {   'job_list': [],   'loclist': [],   'new_loclist': [],}
                                endif

FUNCTION  <SNR>124_IncludeMarks()
Called 1404 times
Total time:   0.067932
 Self time:   0.067932

count  total (s)   self (s)
 1404              0.012141 	if exists('b:showmarks_include') && exists('b:showmarks_previous_include') && b:showmarks_include != b:showmarks_previous_include
                            		" The user changed the marks to include; hide all marks; change the
                            		" included mark list, then show all marks.  Prevent infinite
                            		" recursion during this switch.
                            		if exists('s:use_previous_include')
                            			" Recursive call from ShowMarksHideAll()
                            			return b:showmarks_previous_include
                            		elseif exists('s:use_new_include')
                            			" Recursive call from ShowMarks()
                            			return b:showmarks_include
                            		else
                            			let s:use_previous_include = 1
                            			call <sid>ShowMarksHideAll()
                            			unlet s:use_previous_include
                            			let s:use_new_include = 1
                            			call <sid>ShowMarks()
                            			unlet s:use_new_include
                            		endif
                            	endif
                            
 1404              0.004488 	if !exists('g:showmarks_include')
                            		let g:showmarks_include = s:all_marks
                            	endif
 1404              0.004263 	if !exists('b:showmarks_include')
                            		let b:showmarks_include = g:showmarks_include
                            	endif
                            
                            	" Save this include setting so we can detect if it was changed.
 1404              0.004269 	let b:showmarks_previous_include = b:showmarks_include
                            
 1404              0.002329 	return b:showmarks_include

FUNCTION  xolox#misc#escape#shell()
Called 8 times
Total time:   0.000583
 Self time:   0.000497

count  total (s)   self (s)
                              " Takes a single string argument and converts it into a quoted command line
                              " argument.
                              "
                              " I was going to add a long rant here about Vim's ['shellslash' option]
                              " [shellslash], but really, it won't make any difference. Let's just suffice
                              " to say that I have yet to encounter a single person out there who uses
                              " this option for its intended purpose (running a UNIX style shell on
                              " Microsoft Windows).
                              "
                              " [shellslash]: http://vimdoc.sourceforge.net/htmldoc/options.html#'shellslash'
    8   0.000120   0.000034   if xolox#misc#os#is_win()
                                try
                                  let ssl_save = &shellslash
                                  set noshellslash
                                  return shellescape(a:string)
                                finally
                                  let &shellslash = ssl_save
                                endtry
                              else
    8              0.000348     return shellescape(a:string)
                              endif

FUNCTION  xolox#easytags#filetypes#to_vim()
Called 47 times
Total time:   0.000449
 Self time:   0.000449

count  total (s)   self (s)
                              " Translate an Exuberant Ctags language to a Vim file type.
   47              0.000197   let ctags_language = tolower(a:ctags_language)
   47              0.000206   return get(g:xolox#easytags#filetypes#ctags_to_vim, ctags_language, ctags_language)

FUNCTION  <SNR>138_ShowCurrentSearchIndex()
Called 1 time
Total time:   0.000329
 Self time:   0.000023

count  total (s)   self (s)
                                " NB: function saves and restores @/ and direction
                                " this used to cause me many troubles
                            
    1   0.000285   0.000013     call s:CountCurrentSearchIndex(a:force, a:cmd) " -> s:Msg, s:Highlight
                            
    1              0.000002     if s:Msg != ""
    1   0.000039   0.000005         call s:ScheduleEcho(s:Msg, s:Highlight )
    1              0.000000     endif

FUNCTION  xolox#easytags#session_is_loading()
Called 2 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    2              0.000012   return exists('g:SessionLoad')

FUNCTION  250()
Called 1156 times
Total time:   0.001739
 Self time:   0.001739

count  total (s)   self (s)
 1156              0.001393     return self._ignoreEnabled == 1

FUNCTION  gitgutter#utility#dedup()
Called 3 times
Total time:   0.000098
 Self time:   0.000098

count  total (s)   self (s)
    3              0.000092   return filter(sort(a:list), 'index(a:list, v:val, v:key + 1) == -1')

FUNCTION  <SNR>247_AllowedToCompleteInBuffer()
Called 756 times
Total time:   0.032419
 Self time:   0.032419

count  total (s)   self (s)
  756              0.006747   let buffer_filetype = getbufvar( a:buffer, '&filetype' )
                            
  756              0.006622   if empty( buffer_filetype ) || getbufvar( a:buffer, '&buftype' ) ==# 'nofile' || buffer_filetype ==# 'qf'
   47              0.000064     return 0
                              endif
                            
  709              0.002513   if exists( 'b:ycm_largefile' )
                                return 0
                              endif
                            
  709              0.005081   let whitelist_allows = has_key( g:ycm_filetype_whitelist, '*' ) || has_key( g:ycm_filetype_whitelist, buffer_filetype )
  709              0.003631   let blacklist_allows = !has_key( g:ycm_filetype_blacklist, buffer_filetype )
                            
  709              0.001604   return whitelist_allows && blacklist_allows

FUNCTION  <SNR>272_StartPosRx()
Called 1 time
Total time:   0.000030
 Self time:   0.000009

count  total (s)   self (s)
                                " TLogVAR a:comment_mode, a:line, a:col
                                " if a:comment_mode =~# 'I'
                                "     return s:StartLineRx(a:line) . s:StartColRx(a:comment_mode, a:col)
                                " else
    1   0.000026   0.000005         let rv = s:StartColRx(a:comment_mode, a:col)
                                " endif
                                " TLogVAR rv
    1              0.000001     return rv

FUNCTION  <SNR>247_OnBufferUnload()
Called 4 times
Total time:   0.016313
 Self time:   0.016166

count  total (s)   self (s)
                              " Expanding <abuf> returns the unloaded buffer number as a string but we want
                              " it as a true number for the getbufvar function.
    4   0.000199   0.000052   if !s:AllowedToCompleteInBuffer( str2nr( expand( '<abuf>' ) ) )
    2              0.000002     return
                              endif
                            
    2              0.000091   let deleted_buffer_file = expand( '<afile>:p' )
    2              0.016000   exec s:python_command "ycm_state.OnBufferUnload(" . "vim.eval( 'deleted_buffer_file' ) )"

FUNCTION  <SNR>267_channel_id()
Called 31 times
Total time:   0.000668
 Self time:   0.000668

count  total (s)   self (s)
   31              0.000595   return ch_info(a:channel)['id']

FUNCTION  <SNR>242_expand()
Called 28 times
Total time:   0.007471
 Self time:   0.004555

count  total (s)   self (s)
   28              0.000109   let components = []
   28              0.000044   let expanded = []
   28              0.000043   let indices = []
   28              0.000049   let previndex = -1
   28   0.004041   0.001125   let xs = s:flatten_twice(s:map(deepcopy(a:components), 'map(v:val, "s:convert(v:val, ''" . v:key . "'')")'))
  126              0.000267   for [component, expand, index] in xs
   98              0.000202     if previndex != index
   56              0.000174       call add(indices, index)
   56              0.000122       call add(components, [])
   56              0.000121       call add(expanded, [])
   56              0.000044     endif
   98              0.000354     call extend(components[-1], component)
   98              0.000602     call extend(expanded[-1], repeat([expand], len(component)))
   98              0.000216     let previndex = index
   98              0.000081   endfor
   28              0.000141   call add(indices, string(len(a:components)))
   28              0.000064   return [components, expanded, indices]

FUNCTION  <SNR>206_TrimTrailingWhitespace()
Called 1 time
Total time:   0.000449
 Self time:   0.000449

count  total (s)   self (s)
                                " don't lose user position when trimming trailing whitespace
    1              0.000019     let s:view = winsaveview()
    1              0.000003     try
    1              0.000409         %s/\s\+$//e
    1              0.000002     finally
    1              0.000010         call winrestview(s:view)
    1              0.000002     endtry

FUNCTION  <SNR>272_GuessCommentMode()
Called 2 times
Total time:   0.000151
 Self time:   0.000116

count  total (s)   self (s)
                                " TLogVAR a:comment_mode, a:supported_comment_modes
    2              0.000016     let special = substitute(a:comment_mode, '\c[^ukc]', '', 'g')
    2              0.000007     let cmode = tolower(a:comment_mode)
    2              0.000016     let ccmodes = split(tolower(a:supported_comment_modes), '\zs')
    2              0.000014     let ccmodes = filter(ccmodes, 'stridx(cmode, v:val) != -1')
    2              0.000015     let guess = substitute(a:comment_mode, '\w\+', 'G', 'g')
                                " TLogVAR ccmodes, guess
    2              0.000008     if a:comment_mode =~# '[BR]'
                                    let rv = !empty(ccmodes) ? a:comment_mode : guess
                                elseif a:comment_mode =~# '[I]'
                                    let rv = !empty(ccmodes) ? a:comment_mode : ''
                                else
    2              0.000004         let rv = guess
    2              0.000002     endif
    2   0.000046   0.000011     return s:AddModeExtra(rv, special, 0, 1)

FUNCTION  <SNR>119_repo_head_ref()
Called 1204 times
Total time:   0.111013
 Self time:   0.092778

count  total (s)   self (s)
 1204   0.051788   0.041470   if !filereadable(self.dir('HEAD'))
                                return ''
                              endif
 1204   0.054635   0.046718   return readfile(self.dir('HEAD'))[0]

FUNCTION  ctrlp#utils#writecache()
Called 1 time
Total time:   0.000119
 Self time:   0.000097

count  total (s)   self (s)
    1   0.000040   0.000018 	if isdirectory(ctrlp#utils#mkdir(a:0 ? a:1 : s:cache_dir))
    1              0.000076 		sil! cal writefile(a:lines, a:0 >= 2 ? a:2 : ctrlp#utils#cachefile())
    1              0.000001 	en

FUNCTION  <SNR>272_EndColRx()
Called 2 times
Total time:   0.000038
 Self time:   0.000029

count  total (s)   self (s)
                                " TLogVAR a:comment_mode, a:lnum, a:pos
    2              0.000005     let line = getline(a:lnum)
    2   0.000023   0.000014     let cend = s:Strdisplaywidth(line)
                                " TLogVAR cend
    2              0.000004     if a:pos == 0 || a:pos >= cend
    2              0.000002         return '\$'
                                else
                                    if a:comment_mode =~? 'i' && a:comment_mode =~# 'o'
                                        let mod = '>'
                                    else
                                        let mod = ''
                                    endif
                                    " TLogVAR &selection, mod
                                    return '\%'. mod . a:pos .'v'
                                endif

FUNCTION  gitgutter#sign#update_signs()
Called 7 times
Total time:   0.008937
 Self time:   0.000559

count  total (s)   self (s)
    7   0.003875   0.000078   call gitgutter#sign#find_current_signs()
                            
    7              0.000085   let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
    7   0.002278   0.000099   let obsolete_signs = gitgutter#sign#obsolete_gitgutter_signs_to_remove(new_gitgutter_signs_line_numbers)
                            
    7              0.000030   let flicker_possible = s:remove_all_old_signs && !empty(a:modified_lines)
    7              0.000010   if flicker_possible
                                call gitgutter#sign#add_dummy_sign()
                              endif
                            
    7   0.000302   0.000067   call gitgutter#sign#remove_signs(obsolete_signs, s:remove_all_old_signs)
    7   0.002254   0.000087   call gitgutter#sign#upsert_new_gitgutter_signs(a:modified_lines)
                            
    7              0.000012   if flicker_possible
                                call gitgutter#sign#remove_dummy_sign(0)
                              endif

FUNCTION  <SNR>272_EndPosRx()
Called 1 time
Total time:   0.000024
 Self time:   0.000008

count  total (s)   self (s)
                                " TLogVAR a:comment_mode, a:lnum, a:col
                                " if a:comment_mode =~# 'I'
                                "     return s:EndLineRx(a:lnum) . s:EndColRx(a:col)
                                " else
    1   0.000022   0.000006         return s:EndColRx(a:comment_mode, a:lnum, a:col)
                                " endif

FUNCTION  gitgutter#async#handle_diff_job_vim()
Called 16 times
Total time:   0.014128
 Self time:   0.000491

count  total (s)   self (s)
   16   0.001114   0.000272   call gitgutter#debug#log('channel: '.a:channel.', line: '.a:line)
                            
   16   0.012983   0.000188   call s:accumulate_job_output(s:channel_id(a:channel), a:line)

FUNCTION  tcomment#GetCommentDef()
Called 2 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    2              0.000008     if exists('b:tcomment_def_'. a:name)
                                    return b:tcomment_def_{a:name}
                                else
    2              0.000006         return get(s:definitions, a:name, a:0 >= 1 ? a:1 : '')
                                endif

FUNCTION  <SNR>168_check_cfile()
Called 1 time
Total time:   0.002601
 Self time:   0.002298

count  total (s)   self (s)
    1              0.000001   if a:have_args
                                return ''
                              endif
    1              0.000003   let silent = a:silent || a:filter_tags
    1   0.000023   0.000005   if xolox#misc#option#get('easytags_autorecurse', 0)
                                let cdir = xolox#easytags#utils#resolve(expand('%:p:h'))
                                if !isdirectory(cdir)
                                  if silent | return '' | endif
                                  throw "The directory of the current file doesn't exist yet!"
                                endif
                                return cdir
                              endif
    1   0.002414   0.002210   let cfile = xolox#easytags#utils#resolve(expand('%:p'))
    1              0.000018   if cfile == '' || !filereadable(cfile)
                                if silent | return '' | endif
                                throw "You'll need to save your file before using :UpdateTags!"
                              elseif g:easytags_ignored_filetypes != '' && &ft =~ g:easytags_ignored_filetypes
                                if silent | return '' | endif
                                throw "The " . string(&ft) . " file type is explicitly ignored."
                              elseif empty(xolox#easytags#filetypes#canonicalize(&ft))
                                if silent | return '' | endif
                                throw "Exuberant Ctags doesn't support the " . string(&ft) . " file type!"
                              endif
    1              0.000001   return cfile

FUNCTION  <SNR>267_job_started()
Called 8 times
Total time:   0.000200
 Self time:   0.000200

count  total (s)   self (s)
    8              0.000018   if a:0  " vim
    8              0.000108     let s:jobs[a:id] = {'output': [], 'buffer': a:1}
    8              0.000012   else    " nvim
                                let s:jobs[a:id] = 1
                              endif

FUNCTION  <SNR>158_NERDTreeGetIndicator()
Called 581 times
Total time:   0.010903
 Self time:   0.010903

count  total (s)   self (s)
  581              0.001885     if exists('g:NERDTreeIndicatorMapCustom')
  581              0.002202         let l:indicator = get(g:NERDTreeIndicatorMapCustom, a:statusKey, '')
  581              0.000994         if l:indicator !=# ''
   97              0.000127             return l:indicator
                                    endif
  484              0.000335     endif
  484              0.001707     let l:indicator = get(s:NERDTreeIndicatorMap, a:statusKey, '')
  484              0.000708     if l:indicator !=# ''
                                    return l:indicator
                                endif
  484              0.000414     return ''

FUNCTION  tcomment#Comment()
Called 1 time
Total time:   0.004246
 Self time:   0.000756

count  total (s)   self (s)
    1   0.000075   0.000029     let comment_mode0  = s:AddModeExtra((a:0 >= 1 ? a:1 : 'G'), g:tcommentModeExtra, a:beg, a:end)
    1              0.000004     let comment_mode   = comment_mode0
    1              0.000006     let comment_anyway = a:0 >= 2 ? (a:2 == '!') : 0
                                " TLogVAR a:beg, a:end, comment_mode, comment_anyway, a:000
                                " save the cursor position
    1              0.000006     if exists('w:tcomment_pos')
                                    let s:current_pos = copy(w:tcomment_pos)
                                else
    1              0.000007         let s:current_pos = getpos('.')
    1              0.000002     endif
                                " echom "DBG current_pos=" string(s:current_pos)
    1              0.000005     let cursor_pos = getpos("'>")
                                " TLogVAR cursor_pos
    1              0.000003     let s:cursor_pos = []
    1              0.000008     if comment_mode =~# 'i'
                                    let blnum = line("'<")
                                    if blnum == line("'>")
                                        if virtcol('.') <= indent(blnum)
                                            let i_mode = 'G'
                                        else
                                            let i_mode = 'I'
                                        endif
                                    else
                                        let i_mode = 'G'
                                    endif
                                    let comment_mode = substitute(comment_mode, '\Ci', i_mode, 'g')
                                    " TLogVAR 1, comment_mode
                                endif
    1   0.000156   0.000028     let [lbeg, cbeg, lend, cend] = s:GetStartEnd(a:beg, a:end, comment_mode)
                                " TLogVAR lbeg, cbeg, lend, cend, virtcol('$')
    1              0.000004     if comment_mode ==? 'I' && comment_mode0 =~# 'i' && lbeg == lend && cend >= virtcol('$') - 1
                                    let comment_mode = substitute(comment_mode, '\CI', cbeg <= 1 ? 'G' : 'R', 'g')
                                    " TLogVAR comment_mode
                                endif
    1   0.000021   0.000012     let mode_extra = s:GetTempOption('mode_extra', '')
                                " TLogVAR mode_extra
    1              0.000003     if !empty(mode_extra)
                                    let comment_mode = s:AddModeExtra(comment_mode, mode_extra, lbeg, lend)
                                    " TLogVAR "mode_extra", comment_mode
                                    unlet s:temp_options.mode_extra
                                endif
                                " get the correct commentstring
    1              0.000004     let cdef = copy(g:tcommentOptions)
                                " TLogVAR 1, cdef
    1              0.000003     if exists('b:tcommentOptions')
                                    let cdef = extend(cdef, copy(b:tcommentOptions))
                                    " TLogVAR 2, cdef
                                endif
    1              0.000002     if a:0 >= 3 && type(a:3) == 4
                                    call extend(cdef, a:3)
                                    " TLogVAR 3, cdef
                                else
    1   0.002501   0.000014         let cdef0 = s:GetCommentDefinition(lbeg, lend, comment_mode)
                                    " TLogVAR 4.1, cdef, cdef0
    1              0.000004         call extend(cdef, cdef0)
                                    " TLogVAR 4.2, cdef
    1              0.000001         let ax = 3
    1              0.000003         if a:0 >= 3 && a:3 != '' && stridx(a:3, '=') == -1
                                        let ax = 4
                                        let cdef.begin = a:3
                                        if a:0 >= 4 && a:4 != '' && stridx(a:4, '=') == -1
                                            let ax = 5
                                            let cdef.end = a:4
                                        endif
                                    endif
                                    " TLogVAR ax, a:0, a:000
    1              0.000002         if a:0 >= ax
                                        " let cdef = extend(cdef, s:ParseArgs(lbeg, lend, comment_mode, a:000[ax - 1 : -1]))
                                        let cdef = s:ExtendCDef(lbeg, lend, comment_mode, cdef, s:ParseArgs(lbeg, lend, comment_mode, a:000[ax - 1 : -1]))
                                        " TLogVAR 5, cdef
                                    endif
    1              0.000006         if !empty(get(cdef, 'begin', '')) || !empty(get(cdef, 'end', ''))
                                        let cdef.commentstring = s:EncodeCommentPart(get(cdef, 'begin', '')) . '%s' . s:EncodeCommentPart(get(cdef, 'end', ''))
                                    endif
    1              0.000002         let comment_mode = cdef.mode
                                    " TLogVAR 2, comment_mode
    1              0.000001     endif
    1              0.000002     if empty(comment_mode)
                                    echohl WarningMsg
                                    echo "TComment: Comment mode is not supported for the current filetype"
                                    echohl NONE
                                    return
                                endif
    1              0.000003     if exists('s:temp_options')
                                    let cdef = s:ExtendCDef(lbeg, lend, comment_mode, cdef, s:temp_options)
                                    " TLogVAR 6, cdef
                                    " echom "DBG s:temp_options" string(s:temp_options)
                                    unlet s:temp_options
                                endif
                                " TLogVAR 7, cdef
    1              0.000002     if has_key(cdef, 'whitespace')
                                    call s:SetWhitespaceMode(cdef)
                                endif
    1              0.000014     if !empty(filter(['count', 'cbeg', 'cend', 'cmid'], 'has_key(cdef, v:val)'))
                                    call s:RepeatCommentstring(cdef)
                                endif
                                " echom "DBG" string(a:000)
    1   0.000047   0.000012     let cms0 = s:BlockGetCommentRx(cdef)
                                " TLogVAR cms0
                                "" make whitespace optional; this conflicts with comments that require some 
                                "" whitespace
    1              0.000009     let cmt_check = substitute(cms0, '\([	 ]\)', '\1\\?', 'g')
                                "" turn commentstring into a search pattern
                                " TLogVAR cmt_check
    1   0.000048   0.000009     let cmt_check = s:Printf1(cmt_check, '\(\_.\{-}\)')
                                " TLogVAR cdef, cmt_check
    1              0.000002     let s:cdef = cdef
                                " set comment_mode
                                " TLogVAR comment_mode
    1   0.000205   0.000015     let [lbeg, lend, uncomment] = s:CommentDef(lbeg, lend, cmt_check, comment_mode, cbeg, cend)
                                " TLogVAR lbeg, lend, cbeg, cend, uncomment, comment_mode, comment_anyway
    1              0.000001     if uncomment
                                    if comment_mode =~# 'C' || comment_anyway
                                        let comment_do = 'c'
                                    else
                                        let comment_do = 'u'
                                    endif
                                else
    1              0.000003         if comment_mode =~# 'U'
                                        let comment_do = 'u'
                                    elseif comment_mode =~# 'K'
                                        let comment_do = 'k'
                                    else
    1              0.000001             let comment_do = 'c'
    1              0.000000         endif
    1              0.000000     endif
                                " TLogVAR comment_anyway, comment_mode, mode_extra, comment_do
                                " " echom "DBG" string(s:cdef)
    1              0.000004     if comment_do ==# 'c' && comment_mode !~# 'I'
    1              0.000004         let cbeg = get(s:cdef, 'col', cbeg)
    1              0.000000     endif
                                " TLogVAR cbeg
                                " go
                                " TLogVAR comment_mode
    1              0.000002     if comment_mode =~# 'B'
                                    " We want a comment block
                                    call s:CommentBlock(lbeg, lend, cbeg, cend, comment_mode, comment_do, cmt_check, s:cdef)
                                else
                                    " We want commented lines
                                    " final search pattern for uncommenting
    1              0.000004         let cmt_check   = '\V\^\(\s\{-}\)'. cmt_check .'\$'
                                    " let cmt_check   = escape(cmt_check, '"/\')
                                    " final pattern for commenting
    1   0.000021   0.000010         let cmt_replace = s:GetCommentReplace(s:cdef, cms0)
                                    " TLogVAR cmt_replace
                                    " TLogVAR comment_mode, lbeg, cbeg, lend, cend
    1              0.000002         let s:processline_lnum = lbeg
    1   0.000033   0.000009         let end_rx = s:EndPosRx(comment_mode, lend, cend)
    1              0.000002         let postfix_rx = end_rx == '\$' ? '' : '\.\*\$'
    1   0.000040   0.000010         let prefix_rx = '\^\.\{-}' . s:StartPosRx(comment_mode, lbeg, cbeg)
    1              0.000008         let comment_rx = '\V' . '\('. prefix_rx . '\)' .'\(' .'\(\_.\{-}\)' . end_rx .'\)' .'\(' . postfix_rx . '\)'
                                    " TLogVAR comment_rx, prefix_rx, end_rx, postfix_rx
                                    " let @x = comment_rx " DBG
    4              0.000009         for lnum in range(lbeg, lend)
    3              0.000009             let line0 = getline(lnum)
                                        " TLogVAR line0
    3              0.000064             let lmatch = matchlist(line0, comment_rx)
                                        " TLogVAR lmatch
    3              0.000009             if empty(lmatch) && g:tcomment#blank_lines >= 2
                                            let lline0 = s:Strdisplaywidth(line0)
                                            " TLogVAR lline0, cbeg
                                            if lline0 < cbeg
                                                let line0 = line0 . repeat(' ', cbeg - lline0)
                                                let lmatch = [line0, line0, '', '', '']
                                                " TLogVAR 'padded', line0, lmatch
                                            endif
                                        endif
    3              0.000006             if !empty(lmatch)
    3   0.000526   0.000035                 let [part1, ok] = s:ProcessLine(comment_do, lmatch[2], cmt_check, cmt_replace)
                                            " TLogVAR part1, ok
    3              0.000004                 if ok
    3              0.000013                     let line1 = lmatch[1] . part1 . lmatch[4]
    3              0.000004                     if comment_do ==# 'u'
                                                    if g:tcomment#rstrip_on_uncomment > 0
                                                    if g:tcomment#rstrip_on_uncomment == 2 || line1 !~ '\S'
                                                        let line1 = substitute(line1, '\s\+$', '', '')
                                                    endif
                                                    endif
                                                endif
                                                " TLogVAR line1
    3              0.000026                     call setline(lnum, line1)
    3              0.000003                 endif
    3              0.000002             endif
    3              0.000002         endfor
    1              0.000001         if comment_do ==# 'u'
                                        let postprocess_uncomment = get(cdef, 'postprocess_uncomment', '')
                                        if !empty(postprocess_uncomment)
                                            exec printf(postprocess_uncomment, lbeg, lend)
                                        endif
                                    endif
    1              0.000000     endif
                                " reposition cursor
                                " TLogVAR 3, comment_mode
                                " echom "DBG s:cursor_pos" string(s:cursor_pos)
    1              0.000002     if !empty(s:cursor_pos)
                                    let cursor_pos = s:cursor_pos
                                endif
    1              0.000003     if comment_mode =~ '>'
                                    call setpos('.', cursor_pos)
                                    if comment_mode !~ 'i' && comment_mode =~ '>>'
                                        norm! l^
                                    endif
                                elseif comment_mode =~ '#'
                                    call setpos('.', cursor_pos)
                                    if exists('w:tcomment_pos')
                                        let w:tcomment_pos = cursor_pos
                                    endif
                                else
    1              0.000004         call setpos('.', s:current_pos)
    1              0.000001     endif
    1              0.000003     unlet! s:cursor_pos s:current_pos s:cdef

FUNCTION  gitgutter#sign#find_current_signs()
Called 7 times
Total time:   0.003797
 Self time:   0.003781

count  total (s)   self (s)
    7   0.000047   0.000031   let bufnr = gitgutter#utility#bufnr()
    7              0.000023   let gitgutter_signs = {}  " <line_number (string)>: {'id': <id (number)>, 'name': <name (string)>}
    7              0.000014   let other_signs = []      " [<line_number (number),...]
    7              0.000016   let dummy_sign_placed = 0
                            
    7              0.000032   redir => signs
    7              0.000101     silent execute "sign place buffer=" . bufnr
    7              0.000024   redir END
                            
   24              0.000246   for sign_line in filter(split(signs, '\n')[2:], 'v:val =~# "="')
                                " Typical sign line:  line=88 id=1234 name=GitGutterLineAdded
                                " We assume splitting is faster than a regexp.
   17              0.000285     let components  = split(sign_line)
   17              0.000128     let name        = split(components[2], '=')[1]
   17              0.000110     if name =~# 'GitGutterDummy'
                                  let dummy_sign_placed = 1
                                else
   17              0.000139       let line_number = str2nr(split(components[0], '=')[1])
   17              0.000064       if name =~# 'GitGutter'
   17              0.000128         let id = str2nr(split(components[1], '=')[1])
                                    " Remove orphaned signs (signs placed on lines which have been deleted).
                                    " (When a line is deleted its sign lingers.  Subsequent lines' signs'
                                    " line numbers are decremented appropriately.)
   17              0.000052         if has_key(gitgutter_signs, line_number)
                                      execute "sign unplace" gitgutter_signs[line_number].id
                                    endif
   17              0.000087         let gitgutter_signs[line_number] = {'id': id, 'name': name}
   17              0.000014       else
                                    call add(other_signs, line_number)
                                  endif
   17              0.000012     end
   17              0.000011   endfor
                            
    7              0.000244   call setbufvar(bufnr, 'gitgutter_dummy_sign', dummy_sign_placed)
    7              0.000076   call setbufvar(bufnr, 'gitgutter_gitgutter_signs', gitgutter_signs)
    7              0.000051   call setbufvar(bufnr, 'gitgutter_other_signs', other_signs)

FUNCTION  lightline#update()
Called 7 times
Total time:   0.018690
 Self time:   0.000700

count  total (s)   self (s)
    7              0.000014   if s:_
                                call lightline#init()
                                call lightline#colorscheme()
                              endif
    7              0.000039   if !s:lightline.enable.statusline
                                return
                              endif
    7              0.000028   let w = winnr()
    7   0.018098   0.000108   let s = winnr('$') == 1 ? [lightline#statusline(0)] : [lightline#statusline(0), lightline#statusline(1)]
   25              0.000056   for n in range(1, winnr('$'))
   18              0.000224     call setwinvar(n, '&statusline', s[n!=w])
   18              0.000084     call setwinvar(n, 'lightline', n!=w)
   18              0.000014   endfor

FUNCTION  xolox#session#auto_unlock()
Called 1 time
Total time:   0.000085
 Self time:   0.000042

count  total (s)   self (s)
                              " Automatically unlock all sessions when Vim quits. Normally called by the
                              " [VimLeavePre] [] automatic command event.
                              "
                              " [VimLeavePre]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#VimLeavePre
    1   0.000057   0.000014   if xolox#session#locking_enabled()
    1              0.000003     let i = 0
    1              0.000005     while i < len(s:lock_files)
                                  let lock_file = s:lock_files[i]
                                  if delete(lock_file) == 0
                                    call remove(s:lock_files, i)
                                  else
                                    let i += 1
                                  endif
                                endwhile
    1              0.000001   endif

FUNCTION  <SNR>272_GetTempOption()
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000005     if exists('s:temp_options') && has_key(s:temp_options, a:name)
                                    return s:temp_options[a:name]
                                else
    1              0.000002         return a:default
                                endif

FUNCTION  gitgutter#sign#remove_signs()
Called 7 times
Total time:   0.000235
 Self time:   0.000217

count  total (s)   self (s)
    7   0.000068   0.000050   let bufnr = gitgutter#utility#bufnr()
    7              0.000029   if a:all_signs && s:supports_star && empty(getbufvar(bufnr, 'gitgutter_other_signs'))
                                let dummy_sign_present = getbufvar(bufnr, 'gitgutter_dummy_sign')
                                execute "sign unplace * buffer=" . bufnr
                                if dummy_sign_present
                                  execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . bufnr
                                endif
                              else
    7              0.000018     for id in a:sign_ids
                                  execute "sign unplace" id
                                endfor
    7              0.000007   endif

FUNCTION  <SNR>247_OnVimLeave()
Called 1 time
Total time:   0.027396
 Self time:   0.027396

count  total (s)   self (s)
    1              0.027395   exec s:python_command "ycm_state.OnVimLeave()"

FUNCTION  <SNR>161_WinLeaveHandler()
Called 7 times
Total time:   0.000674
 Self time:   0.000170

count  total (s)   self (s)
    7              0.000050   if s:disable_handlers_for_tabdo
                                return
                              endif
                            
    7              0.000016   if g:nerdtree_tabs_synchronize_view
    7   0.000564   0.000060     call s:SaveNERDTreeViewIfPossible()
    7              0.000009   endif

FUNCTION  gitgutter#utility#use_known_shell()
Called 44 times
Total time:   0.002275
 Self time:   0.002275

count  total (s)   self (s)
   44              0.000255   if has('unix')
   44              0.000179     if &shell !=# 'sh'
   44              0.000224       let s:shell = &shell
   44              0.000201       let s:shellcmdflag = &shellcmdflag
   44              0.000177       let s:shellredir = &shellredir
   44              0.000398       let &shell = 'sh'
   44              0.000332       set shellcmdflag=-c
   44              0.000209       set shellredir=>%s\ 2>&1
   44              0.000066     endif
   44              0.000050   endif

FUNCTION  <SNR>272_Count()
Called 4 times
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
    4              0.000054     return len(split(a:string, a:rx, 1)) - 1

FUNCTION  xolox#easytags#filetypes#add_group()
Called 2 times
Total time:   0.000111
 Self time:   0.000111

count  total (s)   self (s)
                              " Define a group of Vim file types whose tags should be stored together.
    2              0.000021   let canonical_filetype = tolower(a:1)
    2              0.000029   let other_filetypes = map(a:000[1:], 'tolower(v:val)')
    2              0.000013   let s:filetype_groups[canonical_filetype] = other_filetypes
    4              0.000013   for ft in other_filetypes
    2              0.000011     let s:canonical_filetypes[ft] = canonical_filetype
    2              0.000003   endfor

FUNCTION  xolox#misc#path#join()
Called 2 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
                              " Join a list of pathname components (the first and only argument) into a
                              " single pathname string. This is the counterpart to the
                              " `xolox#misc#path#split()` function and it expects a list of pathname
                              " components as returned by `xolox#misc#path#split()`.
    2              0.000007   if type(a:parts) == type([])
    2              0.000003     if s:windows_compatible
                                  return join(a:parts, xolox#misc#path#directory_separator())
                                elseif get(a:parts, 0) == '/'
                                  " Absolute path on UNIX (non-Windows).
    2              0.000016       return '/' . join(a:parts[1:], '/')
                                else
                                  " Relative path on UNIX (non-Windows).
                                  return join(a:parts, '/')
                                endif
                              endif
                              return ''

FUNCTION  <SNR>272_GuessCustomCommentString()
Called 2 times
Total time:   0.000428
 Self time:   0.000186

count  total (s)   self (s)
                                " TLogVAR a:ft, a:comment_mode, a:000
    2              0.000005     let comment_mode   = a:comment_mode
    2   0.000057   0.000018     let custom_comment = tcomment#TypeExists(a:ft)
    2   0.000044   0.000013     let custom_comment_mode = tcomment#TypeExists(a:ft, comment_mode)
    2              0.000008     let supported_comment_mode = !empty(custom_comment_mode) ? comment_mode : ''
                                " TLogVAR custom_comment, custom_comment_mode
    2              0.000004     let default = a:0 >= 1 ? a:1 : ''
    2              0.000004     let default_cdef = a:0 >= 2 ? a:2 : {}
    2              0.000010     let default_supports_comment_mode = get(default_cdef, 'comment_mode', custom_comment_mode)
                                " TLogVAR default, default_supports_comment_mode
    2              0.000010     if comment_mode =~# '[ILB]' && !empty(custom_comment_mode)
                                    let def = tcomment#GetCommentDef(custom_comment_mode)
                                    " TLogVAR 1, def
                                elseif !empty(custom_comment)
    2   0.000033   0.000012         let def = tcomment#GetCommentDef(custom_comment)
    2   0.000171   0.000020         let comment_mode = s:GuessCommentMode(comment_mode, supported_comment_mode)
                                    " TLogVAR 3, def, comment_mode
    2              0.000004     elseif !empty(default)
                                    if empty(default_cdef)
                                        let def = {'commentstring': default}
                                    else
                                        let def = default_cdef
                                    endif
                                    let comment_mode = s:GuessCommentMode(comment_mode, default_supports_comment_mode)
                                    " TLogVAR 4, def, comment_mode
                                else
                                    let def = {}
                                    let comment_mode = s:GuessCommentMode(comment_mode, '')
                                    " TLogVAR 5, def, comment_mode
                                endif
    2              0.000006     let cdef = copy(def)
    2              0.000006     if !has_key(cdef, 'mode')
    2              0.000004         let cdef.mode = comment_mode
    2              0.000002     endif
    2              0.000005     let cdef.filetype = a:ft
                                " TLogVAR cdef
    2              0.000002     return cdef

FUNCTION  xolox#easytags#filetypes#add_mapping()
Called 3 times
Total time:   0.000076
 Self time:   0.000076

count  total (s)   self (s)
                              " Map an Exuberant Ctags language to a Vim file type and vice versa.
    3              0.000018   let vim_filetype = tolower(a:vim_filetype)
    3              0.000016   let ctags_language = tolower(a:ctags_language)
    3              0.000018   let g:xolox#easytags#filetypes#ctags_to_vim[ctags_language] = vim_filetype
    3              0.000017   let g:xolox#easytags#filetypes#vim_to_ctags[vim_filetype] = ctags_language

FUNCTION  NERDTreeGetGitStatusPrefix()
Called 581 times
Total time:   0.989894
 Self time:   0.040796

count  total (s)   self (s)
  581              0.002675     if localtime() - s:GitStatusCacheTime > s:GitStatusCacheTimeExpiry
   13              0.000049         let s:GitStatusCacheTime = localtime()
   13   0.817528   0.000354         call g:NERDTreeGitStatusRefresh()
   13              0.000022     endif
  581   0.059723   0.002774     let l:pathStr = a:path.str()
  581   0.064304   0.004434     let l:cwd = b:NERDTree.root.path.str() . a:path.Slash()
  581   0.005694   0.001492     if nerdtree#runningWindows()
                                    let l:pathStr = a:path.WinToUnixPath(l:pathStr)
                                    let l:cwd = a:path.WinToUnixPath(l:cwd)
                                endif
  581              0.010700     let l:pathStr = substitute(l:pathStr, fnameescape(l:cwd), '', '')
  581              0.001042     let l:statusKey = ''
  581              0.000766     if a:path.isDirectory
  313              0.002235         let l:statusKey = get(b:NERDTreeCachedGitDirtyDir, fnameescape(l:pathStr . '/'), '')
  313              0.000253     else
  268              0.001689         let l:statusKey = get(b:NERDTreeCachedGitFileStatus, fnameescape(l:pathStr), '')
  268              0.000190     endif
  581   0.013817   0.002914     return s:NERDTreeGetIndicator(l:statusKey)

FUNCTION  gitgutter#utility#not_git_dir()
Called 37 times
Total time:   0.002561
 Self time:   0.001241

count  total (s)   self (s)
   37   0.002530   0.001210   return gitgutter#utility#full_path_to_directory_of_file() !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  gitgutter#diff#is_added()
Called 16 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
   16              0.000039   return a:from_count == 0 && a:to_count > 0

FUNCTION  <SNR>119_can_diffoff()
Called 3 times
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
    3              0.000041   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getbufvar(a:buf, 'git_dir')) && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))

FUNCTION  12()
Called 581 times
Total time:   0.807002
 Self time:   0.054513

count  total (s)   self (s)
  581   0.010666   0.002914     let self.cachedDisplayString = self.getLastPathComponent(1)
                            
  581              0.000744     if self.isExecutable
                                    let self.cachedDisplayString = self.cachedDisplayString . '*'
                                endif
                            
  581              0.001920     let self._bookmarkNames = []
 4648   0.010533   0.006818     for i in g:NERDTreeBookmark.Bookmarks()
 4067   0.754112   0.013090         if i.path.equals(self)
                                        call add(self._bookmarkNames, i.name)
                                    endif
 4067              0.003088     endfor
  581              0.001284     if !empty(self._bookmarkNames)
                                    let self.cachedDisplayString .= ' {' . join(self._bookmarkNames) . '}'
                                endif
                            
  581              0.000679     if self.isSymLink
                                    let self.cachedDisplayString .=  ' -> ' . self.symLinkDest
                                endif
                            
  581              0.000572     if self.isReadOnly
                                    let self.cachedDisplayString .=  ' ['.g:NERDTreeGlyphReadOnly.']'
                                endif

FUNCTION  14()
Called 93 times
Total time:   0.015553
 Self time:   0.002868

count  total (s)   self (s)
   93   0.001421   0.000346     let thisPath = self.getLastPathComponent(1)
   93   0.001378   0.000342     let thatPath = a:path.getLastPathComponent(1)
                            
                                "if the paths are the same then clearly we return 0
   93              0.000151     if thisPath ==# thatPath
   23              0.000019         return 0
                                endif
                            
   70   0.004903   0.000217     let thisSS = self.getSortOrderIndex()
   70   0.006157   0.000269     let thatSS = a:path.getSortOrderIndex()
                            
                                "compare the sort sequences, if they are different then the return
                                "value is easy
   70              0.000083     if thisSS < thatSS
   12              0.000011         return -1
                                elseif thisSS > thatSS
                                    return 1
                                else
   58              0.000090         if !g:NERDTreeSortHiddenFirst
                                        let thisPath = substitute(thisPath, '^[._]', '', '')
                                        let thatPath = substitute(thatPath, '^[._]', '', '')
                                    endif
                                    "if the sort sequences are the same then compare the paths
                                    "alphabetically
   58              0.000201         let pathCompare = g:NERDTreeCaseSensitiveSort ? thisPath <# thatPath : thisPath <? thatPath
   58              0.000066         if pathCompare
   28              0.000028             return -1
                                    else
   30              0.000025             return 1
                                    endif
                                endif

FUNCTION  xolox#misc#path#merge()
Called 1 time
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
                              " Join a directory pathname and filename into a single pathname.
    1              0.000007   if type(a:parent) == type('') && type(a:child) == type('')
                                " TODO Use xolox#misc#path#is_relative()?
    1              0.000001     if s:windows_compatible
                                  let parent = substitute(a:parent, '[\\/]\+$', '', '')
                                  let child = substitute(a:child, '^[\\/]\+', '', '')
                                  return parent . '\' . child
                                else
    1              0.000008       let parent = substitute(a:parent, '/\+$', '', '')
    1              0.000005       let child = substitute(a:child, '^/\+', '', '')
    1              0.000002       return parent . '/' . child
                                endif
                              endif
                              return ''

FUNCTION  <SNR>247_OnCursorHold()
Called 29 times
Total time:   0.013126
 Self time:   0.000472

count  total (s)   self (s)
   29   0.001318   0.000148   if !s:AllowedToCompleteInCurrentBuffer()
    4              0.000003     return
                              endif
                            
   25   0.000671   0.000108   call s:SetUpCompleteopt()
   25   0.011047   0.000126   call s:OnFileReadyToParse()

FUNCTION  gitgutter#utility#shellescape()
Called 24 times
Total time:   0.000736
 Self time:   0.000555

count  total (s)   self (s)
   24              0.000308   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
   16              0.000029     return a:arg
                              elseif &shell =~# 'cmd' || gitgutter#utility#using_xolox_shell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
                              else
    8              0.000035     return shellescape(a:arg)
                              endif

FUNCTION  <SNR>242_line()
Called 14 times
Total time:   0.017633
 Self time:   0.007543

count  total (s)   self (s)
   14              0.000042   let _ = a:tabline ? '' : '%{lightline#link()}'
   14              0.000047   if s:lightline.palette == {}
                                call lightline#colorscheme()
                              endif
   14              0.000089   let [l, r] = a:tabline ? [s:lightline.tab_llen, s:lightline.tab_rlen] : [s:lightline.llen, s:lightline.rlen]
   14              0.000082   let [p, s] = a:tabline ? [s:lightline.tabline_separator, s:lightline.tabline_subseparator] : [s:lightline.separator, s:lightline.subseparator]
   14              0.000076   let [c, f, t] = [s:lightline.component, s:lightline.component_function, s:lightline.component_type]
   14              0.000048   let mode = a:tabline ? 'tabline' : a:inactive ? 'inactive' : 'active'
   14              0.000085   let l_ = has_key(s:lightline, mode) ? s:lightline[mode].left : s:lightline.active.left
   14   0.004235   0.000220   let [lt, lc, ll] = s:expand(copy(l_))
   14              0.000087   let r_ = has_key(s:lightline, mode) ? s:lightline[mode].right : s:lightline.active.right
   14   0.003649   0.000193   let [rt, rc, rl] = s:expand(copy(r_))
   35              0.000078   for i in range(len(lt))
   21              0.000111     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '#'
   70              0.000135     for j in range(len(lt[i]))
   49              0.000616       let x = lc[i][j] ? lt[i][j] : has_key(f, lt[i][j]) ? (exists('*' . f[lt[i][j]]) ? '%{' . f[lt[i][j]] . '()}' : '%{exists("*' . f[lt[i][j]] . '")?' . f[lt[i][j]] . '():""}') : get(c, lt[i][j], '')
   49              0.000345       let _ .= has_key(t, lt[i][j]) && t[lt[i][j]] ==# 'raw' || x ==# '' ? x : '%( ' . x . ' %)'
   49              0.000175       if j < len(lt[i]) - 1 && s.left !=# ''
   28   0.002214   0.000347         let _ .= s:subseparator(lt[i][(j):], s.left, lc[i][(j):])
   28              0.000025       endif
   49              0.000040     endfor
   21              0.000139     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '_' . ll[i + 1] . '#'
   21              0.000182     let _ .= i < l + len(lt) - len(l_) && ll[i] < l || ll[i] != ll[i + 1] ? p.left : len(lt[i]) ? s.left : ''
   21              0.000019   endfor
   14              0.000046   let _ .= '%#LightlineMiddle_' . mode . '#%='
   49              0.000103   for i in reverse(range(len(rt)))
   35              0.000223     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '_' . rl[i + 1] . '#'
   35              0.000260     let _ .= i < r + len(rt) - len(r_) && rl[i] < r || rl[i] != rl[i + 1] ? p.right : len(rt[i]) ? s.right : ''
   35              0.000154     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '#'
   84              0.000183     for j in range(len(rt[i]))
   49              0.000479       let x = rc[i][j] ? rt[i][j] : has_key(f, rt[i][j]) ? (exists('*' . f[rt[i][j]]) ? '%{' . f[rt[i][j]] . '()}' : '%{exists("*' . f[rt[i][j]] . '")?' . f[rt[i][j]] . '():""}') : get(c, rt[i][j], '')
   49              0.000323       let _ .= has_key(t, rt[i][j]) && t[rt[i][j]] ==# 'raw' || x ==# '' ? x : '%( ' . x . ' %)'
   49              0.000155       if j < len(rt[i]) - 1 && s.right !=# ''
   14   0.000902   0.000150         let _ .= s:subseparator(rt[i][(j):], s.right, rc[i][(j):])
   14              0.000011       endif
   49              0.000031     endfor
   35              0.000026   endfor
   14              0.000019   return _

FUNCTION  <SNR>119_repo()
Called 2408 times
Total time:   0.076934
 Self time:   0.076934

count  total (s)   self (s)
 2408              0.021808   let dir = a:0 ? a:1 : (exists('b:git_dir') && b:git_dir !=# '' ? b:git_dir : fugitive#extract_git_dir(expand('%:p')))
 2408              0.004256   if dir !=# ''
 2408              0.007595     if has_key(s:repos, dir)
 2408              0.007674       let repo = get(s:repos, dir)
 2408              0.002213     else
                                  let repo = {'git_dir': dir}
                                  let s:repos[dir] = repo
                                endif
 2408              0.018327     return extend(extend(repo, s:repo_prototype, 'keep'), s:abstract_prototype, 'keep')
                              endif
                              call s:throw('not a git repository: '.expand('%:p'))

FUNCTION  xolox#session#auto_save()
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
                              " Automatically save the current editing session when Vim is closed.
                              " Normally called by the [VimLeavePre] [] automatic command event.
                              "
                              " [VimLeavePre]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#VimLeavePre
    1              0.000003   if v:dying
                                " We won't save the session if Vim is not terminating normally.
                                return
                              endif
    1              0.000004   if g:session_autosave == 'no'
                                " We won't save the session if auto-save is explicitly disabled.
    1              0.000001     return
                              endif
                              " Get the name of the session for automatic saving.
                              let name = xolox#misc#option#get('session_autosave_to')
                              if empty(name)
                                " Get the name of the active session (if any).
                                let name = xolox#session#find_current_session()
                                " If no session is active and the user doesn't have any sessions yet,
                                " help them get started by suggesting to create the default session.
                                if empty(name) && (empty(xolox#session#get_names(0)) || g:session_default_overwrite)
                                  let name = g:session_default_name
                                endif
                              endif
                              " Prompt the user to save the active/first/default session?
                              if !empty(name)
                                let is_tab_scoped = xolox#session#is_tab_scoped()
                                let msg = "Do you want to save your %s before quitting Vim?"
                                if s:prompt(printf(msg, xolox#session#get_label(name, is_tab_scoped)), ["&Save", "&Don't Save"], 'g:session_autosave') == 1
                                  if g:session_default_overwrite && (name == g:session_default_name)
                                    let bang = '!'
                                  else
                                    let bang = ''
                                  endif
                                  if is_tab_scoped
                                    call xolox#session#save_tab_cmd(name, bang, 'SaveTabSession')
                                  else
                                    call xolox#session#save_cmd(name, bang, 'SaveSession')
                                  endif
                                endif
                              endif

FUNCTION  21()
Called 450 times
Total time:   0.002671
 Self time:   0.002671

count  total (s)   self (s)
  450              0.000771     if self.cachedDisplayString ==# ""
                                    call self.cacheDisplayString()
                                endif
                            
  450              0.000478     return self.cachedDisplayString

FUNCTION  23()
Called 48 times
Total time:   0.001269
 Self time:   0.000900

count  total (s)   self (s)
   48   0.000502   0.000133     if nerdtree#runningWindows()
                                    if a:fullpath =~ '^\(\\\\\|\/\/\)'
                                        "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
                                        let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
                                        let self.drive = substitute(self.drive, '/', '\', "g")
                                    else
                                        let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
                                    endif
                                else
   48              0.000120         let self.drive = ''
   48              0.000039     endif
                            

FUNCTION  25()
Called 1 time
Total time:   0.000014
 Self time:   0.000006

count  total (s)   self (s)
    1   0.000010   0.000002     if nerdtree#runningWindows()
                                    return " `\|\"#%&,?()\*^<>$"
                                endif
                            
    1              0.000001     return " \\`\|\"#%&,?()\*^<>[]$"

FUNCTION  28()
Called 3579 times
Total time:   0.038245
 Self time:   0.038245

count  total (s)   self (s)
 3579              0.006715     if empty(self.pathSegments)
                                    return ''
                                endif
 3579              0.008071     let toReturn = self.pathSegments[-1]
 3579              0.004609     if a:dirSlash && self.isDirectory
  461              0.001024         let toReturn = toReturn . '/'
  461              0.000316     endif
 3579              0.003440     return toReturn

FUNCTION  29()
Called 140 times
Total time:   0.010574
 Self time:   0.006150

count  total (s)   self (s)
  140              0.000177     let i = 0
  530              0.000982     while i < len(g:NERDTreeSortOrder)
  452   0.007105   0.002681         if  self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
   62              0.000070             return i
                                    endif
  390              0.000564         let i = i + 1
  390              0.000318     endwhile
   78              0.000101     return s:NERDTreeSortStarIndex

FUNCTION  xolox#misc#str#trim()
Called 49 times
Total time:   0.000835
 Self time:   0.000835

count  total (s)   self (s)
                              " Trim all whitespace from the start and end of a string (the first
                              " argument).
   49              0.000743   return substitute(a:s, '^\_s*\(.\{-}\)\_s*$', '\1', '')

FUNCTION  116()
Called 175 times
Total time:   0.005034
 Self time:   0.001251

count  total (s)   self (s)
  175   0.004798   0.001015     return self.path.flagSet.renderToString() . self.path.displayString()

FUNCTION  118()
Called 11 times
Total time:   0.001963
 Self time:   0.000082

count  total (s)   self (s)
   11   0.001933   0.000052     if a:path.equals(self.path)
    1              0.000001         return self
                                endif
   10              0.000009     return {}

FUNCTION  <SNR>272_GetCommentDefinition()
Called 1 time
Total time:   0.002487
 Self time:   0.000102

count  total (s)   self (s)
    1              0.000002     let ft = a:0 >= 1 ? a:1 : ''
    1              0.000005     Tlibtrace 'tcomment', a:beg, a:end, a:comment_mode, ft
    1              0.000002     if ft != ''
                                    let cdef = s:GuessCustomCommentString(ft, a:comment_mode)
                                else
    1              0.000003         let cdef = {'mode': a:comment_mode}
    1              0.000000     endif
                                " TLogVAR cdef
    1              0.000004     let cms = get(cdef, 'commentstring', '')
    1              0.000002     if empty(cms)
    1   0.000260   0.000014         let filetype = s:GetFiletype(ft)
    1              0.000003         Tlibtrace 'tcomment', filetype
    1              0.000003         if exists('b:commentstring')
                                        let cms = b:commentstring
                                        " TLogVAR 1, cms
                                        return s:GuessCustomCommentString(filetype, a:comment_mode, cms)
                                    elseif exists('b:commentStart') && b:commentStart != ''
                                        let cms = s:EncodeCommentPart(b:commentStart) .' %s'
                                        " TLogVAR 2, cms
                                        if exists('b:commentEnd') && b:commentEnd != ''
                                            let cms = cms .' '. s:EncodeCommentPart(b:commentEnd)
                                        endif
                                        return s:GuessCustomCommentString(filetype, a:comment_mode, cms)
                                    else
    1   0.000170   0.000011             let [use_guess_ft, alt_filetype] = s:AltFiletype(ft, cdef)
    1              0.000002             Tlibtrace 'tcomment', use_guess_ft, alt_filetype
    1              0.000002             if use_guess_ft
    1   0.001998   0.000018                 return s:GuessFileType(a:beg, a:end, a:comment_mode, filetype, alt_filetype)
                                        else
                                            let guess_cdef = s:GuessVimOptionsCommentString(a:comment_mode)
                                            " TLogVAR guess_cdef
                                            return s:GuessCustomCommentString(filetype, a:comment_mode, guess_cdef.commentstring, guess_cdef)
                                        endif
                                    endif
                                    let cdef.commentstring = cms
                                endif
                                return cdef

FUNCTION  gitgutter#sign#next_sign_id()
Called 3 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    3              0.000006   let next_id = s:next_sign_id
    3              0.000006   let s:next_sign_id += 1
    3              0.000003   return next_id

FUNCTION  xolox#easytags#update()
Called 1 time
Total time:   0.066475
 Self time:   0.001754

count  total (s)   self (s)
    1   0.000023   0.000006   let async = xolox#misc#option#get('easytags_async', 0)
    1   0.000020   0.000008   call g:xolox#easytags#update_timer.start()
    1              0.000001   try
    1              0.000003     let have_args = !empty(a:filenames)
    1   0.000012   0.000005     let starttime = xolox#misc#timer#start()
    1   0.002615   0.000014     let cfile = s:check_cfile(a:silent, a:filter_tags, have_args)
    1   0.000401   0.000014     let command_line = s:prep_cmdline(cfile, a:filenames)
    1              0.000003     if empty(command_line)
                                  return 0
                                endif
                                " Pack all of the information required to update the tags in
                                " a Vim dictionary which is easy to serialize to a string.
    1              0.000002     let params = {}
    1              0.000003     let params['command'] = command_line
    1              0.000003     let params['ctags_version'] = g:easytags_ctags_version
    1   0.000075   0.000007     let params['default_filetype'] = xolox#easytags#filetypes#canonicalize(&filetype)
    1              0.000004     let params['filter_tags'] = a:filter_tags || async
    1              0.000002     let params['have_args'] = have_args
    1   0.000559   0.000012     let dynamic_tagsfile = xolox#easytags#get_dynamic_tagsfile()
    1              0.000003     if !empty(dynamic_tagsfile)
    1              0.000003       let params['tagsfile'] = dynamic_tagsfile
    1              0.000002     elseif !empty(g:easytags_by_filetype)
                                  let params['directory'] = xolox#misc#path#absolute(g:easytags_by_filetype)
                                  let params['filetypes'] = g:xolox#easytags#filetypes#ctags_to_vim
                                else
                                  let params['tagsfile'] = xolox#easytags#get_global_tagsfile()
                                endif
    1              0.000001     if async
    1   0.062309   0.001560       call xolox#misc#async#call({'function': 'xolox#easytags#update#with_vim', 'arguments': [params], 'callback': 'xolox#easytags#async_callback'})
    1              0.000001     else
                                  call s:report_results(xolox#easytags#update#with_vim(params), 0)
                                  " When :UpdateTags was executed manually we'll refresh the dynamic
                                  " syntax highlighting so that new tags are immediately visible.
                                  if !a:silent && xolox#misc#option#get('easytags_auto_highlight', 1)
                                    HighlightTags
                                  endif
                                endif
    1              0.000002     return 1
                              catch
                                call xolox#misc#msg#warn("easytags.vim %s: %s (at %s)", g:xolox#easytags#version, v:exception, v:throwpoint)
                              finally
    1   0.000369   0.000036     call g:xolox#easytags#update_timer.stop()
    1              0.000005   endtry

FUNCTION  30()
Called 292 times
Total time:   0.004137
 Self time:   0.004137

count  total (s)   self (s)
  292              0.000554     if !exists("self._sortKey")
                                    let path = self.getLastPathComponent(1)
                                    if !g:NERDTreeSortHiddenFirst
                                        let path = substitute(path, '^[._]', '', '')
                                    endif
                                    if !g:NERDTreeCaseSensitiveSort
                                        let path = tolower(path)
                                    endif
                                    let self._sortKey = printf(s:sortKeyFormat, self.getSortOrderIndex()) . path
                                endif
                            
  292              0.000264     return self._sortKey

FUNCTION  31()
Called 1156 times
Total time:   0.017615
 Self time:   0.006128

count  total (s)   self (s)
 1156   0.017245   0.005758     return self.getLastPathComponent(0) =~# '^\.'

FUNCTION  34()
Called 1156 times
Total time:   0.042322
 Self time:   0.030413

count  total (s)   self (s)
 1156              0.001916     let pat = a:pattern
 1156              0.004656     if strpart(pat,len(pat)-7) == '[[dir]]'
                                    if !self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-7)
                                elseif strpart(pat,len(pat)-8) == '[[file]]'
                                    if self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-8)
                                endif
                            
 1156   0.017700   0.005791     return self.getLastPathComponent(0) =~# pat

FUNCTION  38()
Called 4092 times
Total time:   0.746783
 Self time:   0.024883

count  total (s)   self (s)
 4092   0.745593   0.023693     return self.str() ==# a:path.str()

FUNCTION  39()
Called 24 times
Total time:   0.007141
 Self time:   0.001059

count  total (s)   self (s)
   24              0.000609     let newPath = copy(self)
                            
   24   0.006100   0.000212     call newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:path))
                            
   24              0.000047     let newPath.cachedDisplayString = ""
   24   0.000302   0.000108     let newPath.flagSet = g:NERDTreeFlagSet.New()
                            
   24              0.000024     return newPath

FUNCTION  ale#linter#Get()
Called 10 times
Total time:   0.001878
 Self time:   0.001672

count  total (s)   self (s)
   10              0.000038     let l:combined_linters = []
                            
                                " Handle dot-seperated filetypes.
   20              0.000161     for l:original_filetype in split(a:original_filetypes, '\.')
                                    " Try and get an aliased file type either from the user's Dictionary, or
                                    " our default Dictionary, otherwise use the filetype as-is.
   10              0.000142         let l:filetype = get(   g:ale_linter_aliases,   l:original_filetype,   get(       s:default_ale_linter_aliases,       l:original_filetype,       l:original_filetype   ))
                            
                                    " Try and get a list of linters to run, using the original file type,
                                    " not the aliased filetype. We have some linters to limit by default,
                                    " and users may define their own list of linters to run.
   10              0.000101         let l:linter_names = get(   g:ale_linters,   l:original_filetype,   get(       s:default_ale_linters,       l:original_filetype,       'all'   ))
                            
   10   0.000342   0.000136         let l:all_linters = s:LoadLinters(l:filetype)
   10              0.000030         let l:filetype_linters = []
                            
   10              0.000069         if type(l:linter_names) == type('') && l:linter_names ==# 'all'
   10              0.000033             let l:filetype_linters = l:all_linters
   10              0.000039         elseif type(l:linter_names) == type([])
                                        " Select only the linters we or the user has specified.
                                        for l:linter in l:all_linters
                                            if index(l:linter_names, l:linter.name) >= 0
                                                call add(l:filetype_linters, l:linter)
                                            endif
                                        endfor
                                    endif
                            
   10              0.000053         call extend(l:combined_linters, l:filetype_linters)
   10              0.000013     endfor
                            
   10              0.000023     return l:combined_linters

FUNCTION  <SNR>119_repo_head()
Called 1204 times
Total time:   0.216734
 Self time:   0.050991

count  total (s)   self (s)
 1204   0.156221   0.011093     let head = s:repo().head_ref()
                            
 1204              0.013380     if head =~# '^ref: '
 1204   0.030951   0.010336       let branch = s:sub(head,'^ref: %(refs/%(heads/|remotes/|tags/)=)=','')
 1204              0.001986     elseif head =~# '^\x\{40\}$'
                                  " truncate hash to a:1 characters if we're in detached head mode
                                  let len = a:0 ? a:1 : 0
                                  let branch = len ? head[0:len-1] : ''
                                else
                                  return ''
                                endif
                            
 1204              0.001672     return branch

FUNCTION  ctrlp#mrufiles#cachefile()
Called 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000011 	if !exists('s:cadir') || !exists('s:cafile')
                            		let s:cadir = ctrlp#utils#cachedir().ctrlp#utils#lash().'mru'
                            		let s:cafile = s:cadir.ctrlp#utils#lash().'cache.txt'
                            	en
    1              0.000003 	retu s:cafile

FUNCTION  121()
Called 1737 times
Total time:   0.002487
 Self time:   0.002487

count  total (s)   self (s)
 1737              0.002002     return self._nerdtree

FUNCTION  123()
Called 1 time
Total time:   0.000294
 Self time:   0.000032

count  total (s)   self (s)
    1              0.000002     try
    1   0.000051   0.000013         let path = b:NERDTree.ui.getPath(line("."))
    1              0.000002         if path ==# {}
                                        return {}
                                    endif
    1   0.000233   0.000009         return b:NERDTree.root.findNode(path)
                                catch /^NERDTree/
                                    return {}
                                endtry

FUNCTION  <SNR>161_SaveNERDTreeViewIfPossible()
Called 7 times
Total time:   0.000504
 Self time:   0.000504

count  total (s)   self (s)
    7              0.000363   if exists("t:NERDTreeBufName") && bufwinnr(t:NERDTreeBufName) == winnr()
                                " save scroll and cursor etc.
    2              0.000021     let s:nerdtree_view = winsaveview()
                            
                                " save NERDTree window width
    2              0.000009     let s:nerdtree_width = winwidth(winnr())
                            
                                " save buffer name (to be able to correct desync by commands spawning
                                " a new NERDTree instance)
    2              0.000011     let s:nerdtree_buffer = bufname("%")
    2              0.000002   endif

FUNCTION  MyReadonly()
Called 4796 times
Total time:   0.039575
 Self time:   0.039575

count  total (s)   self (s)
 4796              0.016208   if &filetype == "help"
 1148              0.001443     return ""
                              elseif &readonly
                                return "⭤ "
                              else
 3648              0.003728     return ""
                              endif

FUNCTION  nerdtree#checkForBrowse()
Called 7 times
Total time:   0.000229
 Self time:   0.000229

count  total (s)   self (s)
    7              0.000191     if !isdirectory(a:dir)
    7              0.000011         return
                                endif
                            
                                if s:reuseWin(a:dir)
                                    return
                                endif
                            
                                call g:NERDTreeCreator.CreateWindowTree(a:dir)

FUNCTION  <SNR>163_addtomrufs()
Called 4 times
Total time:   0.000618
 Self time:   0.000618

count  total (s)   self (s)
    4              0.000133 	let fn = fnamemodify(a:fname, get(g:, 'ctrlp_tilde_homedir', 0) ? ':p:~' : ':p')
    4              0.000033 	let fn = exists('+ssl') ? tr(fn, '/', '\') : fn
    4              0.000030 	let abs_fn = fnamemodify(fn,':p')
    4              0.000366 	if ( !empty({s:in}) && fn !~# {s:in} ) || ( !empty({s:ex}) && fn =~# {s:ex} ) || !empty(getbufvar('^' . abs_fn . '$', '&bt')) || !filereadable(abs_fn)
    2              0.000003 		retu
                            	en
    2              0.000016 	let idx = index(s:mrufs, fn, 0, !{s:cseno})
    2              0.000002 	if idx
                            		cal filter(s:mrufs, 'v:val !='.( {s:cseno} ? '#' : '?' ).' fn')
                            		cal insert(s:mrufs, fn)
                            		if {s:soup} && idx < 0
                            			cal s:savetofile(s:mergelists())
                            		en
                            	en

FUNCTION  xolox#easytags#ctags_command()
Called 2 times
Total time:   0.000163
 Self time:   0.000068

count  total (s)   self (s)
    2   0.000062   0.000014   let program = xolox#misc#option#get('easytags_cmd')
    2              0.000006   if !empty(program)
    2   0.000058   0.000011     let options = xolox#misc#option#get('easytags_opts')
    2              0.000005     if !empty(options)
                                  let command_line = [program]
                                  call extend(command_line, map(copy(options), 'xolox#misc#escape#shell(expand(v:val))'))
                                  let program = join(command_line)
                                endif
    2              0.000003     return program
                              endif
                              return ''

FUNCTION  40()
Called 19585 times
Total time:   0.208435
 Self time:   0.060830

count  total (s)   self (s)
19585   0.203159   0.055554     return nerdtree#runningWindows() ? '\' : '/'

FUNCTION  41()
Called 96 times
Total time:   0.001740
 Self time:   0.001740

count  total (s)   self (s)
   96              0.000818     let tmp = resolve(a:path)
   96              0.000866     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp

FUNCTION  42()
Called 48 times
Total time:   0.009565
 Self time:   0.004932

count  total (s)   self (s)
   48   0.001463   0.000194     call self.extractDriveLetter(a:fullpath)
                            
   48   0.000784   0.000192     let fullpath = s:Path.WinToUnixPath(a:fullpath)
                            
   48              0.000451     if getftype(fullpath) ==# "fifo"
                                    throw "NERDTree.InvalidFiletypeError: Cant handle FIFO files: " . a:fullpath
                                endif
                            
   48              0.000438     let self.pathSegments = split(fullpath, '/')
                            
   48              0.000089     let self.isReadOnly = 0
   48              0.000238     if isdirectory(a:fullpath)
   25              0.000047         let self.isDirectory = 1
   25              0.000046     elseif filereadable(a:fullpath)
   23              0.000055         let self.isDirectory = 0
   23              0.000237         let self.isReadOnly = filewritable(a:fullpath) ==# 0
   23              0.000022     else
                                    throw "NERDTree.InvalidArgumentsError: Invalid path = " . a:fullpath
                                endif
                            
   48              0.000088     let self.isExecutable = 0
   48              0.000056     if !self.isDirectory
   23              0.000165         let self.isExecutable = getfperm(a:fullpath) =~# 'x'
   23              0.000023     endif
                            
                                "grab the last part of the path (minus the trailing slash)
   48   0.000791   0.000229     let lastPathComponent = self.getLastPathComponent(0)
                            
                                "get the path to the new node with the parent dir fully resolved
   48   0.001812   0.000355     let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent
                            
                                "if  the last part of the path is a symlink then flag it as such
   48   0.001035   0.000282     let self.isSymLink = (s:Path.Resolve(hardPath) != hardPath)
   48              0.000057     if self.isSymLink
                                    let self.symLinkDest = s:Path.Resolve(fullpath)
                            
                                    "if the link is a dir then slap a / on the end of its dest
                                    if isdirectory(self.symLinkDest)
                            
                                        "we always wanna treat MS windows shortcuts as files for
                                        "simplicity
                                        if hardPath !~# '\.lnk$'
                            
                                            let self.symLinkDest = self.symLinkDest . '/'
                                        endif
                                    endif
                                endif

FUNCTION  43()
Called 24 times
Total time:   0.110525
 Self time:   0.000475

count  total (s)   self (s)
   24   0.007175   0.000157     call self.readInfoFromDisk(self.str())
   24   0.068598   0.000204     call g:NERDTreePathNotifier.NotifyListeners('refresh', self, a:nerdtree, {})
   24   0.034732   0.000094     call self.cacheDisplayString()

FUNCTION  44()
Called 557 times
Total time:   1.749628
 Self time:   0.006361

count  total (s)   self (s)
  557   0.974958   0.004055     call g:NERDTreePathNotifier.NotifyListeners('refreshFlags', self, a:nerdtree, {})
  557   0.774309   0.001945     call self.cacheDisplayString()

FUNCTION  46()
Called 9527 times
Total time:   0.850239
 Self time:   0.408480

count  total (s)   self (s)
 9527              0.018513     let options = a:0 ? a:1 : {}
 9527              0.013480     let toReturn = ""
                            
 9527              0.018983     if has_key(options, 'format')
   26              0.000055         let format = options['format']
   26              0.000084         if has_key(self, '_strFor' . format)
   26   0.000614   0.000225             exec 'let toReturn = self._strFor' . format . '()'
   26              0.000019         else
                                        throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
                                    endif
   26              0.000019     else
 9501   0.443119   0.032786         let toReturn = self._str()
 9501              0.007488     endif
                            
 9527   0.062142   0.031105     if nerdtree#has_opt(options, 'escape')
                                    let toReturn = shellescape(toReturn)
                                endif
                            
 9527              0.019091     if has_key(options, 'truncateTo')
   25              0.000054         let limit = options['truncateTo']
   25              0.000087         if len(toReturn) > limit-1
                                        let toReturn = toReturn[(len(toReturn)-limit+1):]
                                        if len(split(toReturn, '/')) > 1
                                            let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
                                        else
                                            let toReturn = '<' . toReturn
                                        endif
                                    endif
   25              0.000019     endif
                            
 9527              0.010494     return toReturn

FUNCTION  47()
Called 25 times
Total time:   0.000307
 Self time:   0.000307

count  total (s)   self (s)
   25              0.000113     let toReturn = '/' . join(self.pathSegments, '/')
   25              0.000062     if self.isDirectory && toReturn != '/'
   25              0.000056         let toReturn  = toReturn . '/'
   25              0.000017     endif
   25              0.000032     return toReturn

FUNCTION  <SNR>272_Printf1()
Called 4 times
Total time:   0.000143
 Self time:   0.000088

count  total (s)   self (s)
    4   0.000077   0.000022     let n = s:Count(a:fmt, '%\@<!\%(%%\)*%s')
    4              0.000017     let exprs = repeat([a:expr], n)
                                " TLogVAR a:fmt, a:expr, exprs
    4              0.000036     let rv = call(function('printf'), [a:fmt] + exprs)
                                " TLogVAR rv
    4              0.000004     return rv

FUNCTION  132()
Called 11 times
Total time:   0.024082
 Self time:   0.000074

count  total (s)   self (s)
   11   0.024078   0.000070     call self.path.refresh(self.getNerdtree())

FUNCTION  133()
Called 257 times
Total time:   0.441912
 Self time:   0.001691

count  total (s)   self (s)
  257   0.441755   0.001534     call self.path.refreshFlags(self.getNerdtree())

FUNCTION  135()
Called 25 times
Total time:   0.180017
 Self time:   0.000238

count  total (s)   self (s)
   25   0.180007   0.000228     return self._renderToString(0, 0)

FUNCTION  lightline#link()
Called 931 times
Total time:   0.024625
 Self time:   0.024625

count  total (s)   self (s)
  931              0.015270   let mode = get(s:lightline._mode_, a:0 ? a:1 : mode(), 'normal')
  931              0.003489   if s:mode == mode
  929              0.001831     return ''
                              endif
    2              0.000004   let s:mode = mode
    2              0.000007   if !has_key(s:highlight, mode)
                                call lightline#highlight(mode)
                              endif
    2              0.000038   let types = map(s:uniq(sort(filter(values(s:lightline.component_type), 'v:val !=# "raw"'))), '[v:val, 1]')
    6              0.000024   for [p, l] in [['Left', len(s:lightline.active.left)], ['Right', len(s:lightline.active.right)]]
   22              0.000063     for [i, t] in map(range(0, l), '[v:val, 0]') + types
   18              0.000018       if i != l
   14              0.000234         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
   14              0.000012       endif
  100              0.000273       for [j, s] in map(range(0, l), '[v:val, 0]') + types
   82              0.000193         if i + 1 == j || t || s && i != l
   38              0.000571           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
   38              0.000032         endif
   82              0.000048       endfor
   18              0.000014     endfor
    4              0.000003   endfor
    2              0.000023   exec printf('hi link LightlineMiddle_active LightlineMiddle_%s', mode)
    2              0.000003   return ''

FUNCTION  gitgutter#diff#is_modified()
Called 16 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
   16              0.000048   return a:from_count > 0 && a:to_count > 0 && a:from_count == a:to_count

FUNCTION  51()
Called 9501 times
Total time:   0.410333
 Self time:   0.137889

count  total (s)   self (s)
 9501   0.132704   0.029821     let lead = s:Path.Slash()
                            
                                "if we are running windows then slap a drive letter on the front
 9501   0.094597   0.024308     if nerdtree#runningWindows()
                                    let lead = self.drive . '\'
                                endif
                            
 9501   0.147432   0.048160     return lead . join(self.pathSegments, s:Path.Slash())

FUNCTION  52()
Called 48 times
Total time:   0.000470
 Self time:   0.000470

count  total (s)   self (s)
   48              0.000449     return self.drive . '/' . join(self.pathSegments[0:-2], '/')

FUNCTION  54()
Called 48 times
Total time:   0.000592
 Self time:   0.000228

count  total (s)   self (s)
   48   0.000496   0.000132     if !nerdtree#runningWindows()
   48              0.000064         return a:pathstr
                                endif
                            
                                let toReturn = a:pathstr
                            
                                "remove the x:\ of the front
                                let toReturn = substitute(toReturn, '^.*:\(\\\|/\)\?', '/', "")
                            
                                "remove the \\ network share from the front
                                let toReturn = substitute(toReturn, '^\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\(\\\|\/\)\?', '/', "")
                            
                                "convert all \ chars to /
                                let toReturn = substitute(toReturn, '\', '/', "g")
                            
                                return toReturn

FUNCTION  <SNR>192_YRCheckClipboard()
Called 3 times
Total time:   0.003509
 Self time:   0.003509

count  total (s)   self (s)
    3              0.000012     if g:yankring_clipboard_monitor == 1
                                    " If the clipboard has changed record it inside the yankring
                                    " echomsg "YRCheckClipboard[".len(@*)."][".@*.']['.s:yr_prev_clipboard_star.']'
    3              0.000041         if has('unnamedplus') && &clipboard =~ '\<unnamedplus\>'
                                        if len(@+) > 0 && @+ != s:yr_prev_clipboard_plus
                                            let elem    = s:YRMRUElemFormat(   getreg('+') , getregtype('+') )
                                            let found   = s:YRMRUHas('s:yr_history_list', elem)
                            
                                            " Only add the item to the "top" of the ring if it is
                                            " not in the ring already.
                                            if found == -1
                                                call YRRecord3("+")
                                            endif
                                            let s:yr_prev_clipboard_plus = @+
                                        endif
                                    else
    3              0.003246             if len(@*) > 0 && @* != s:yr_prev_clipboard_star
                                            let elem    = s:YRMRUElemFormat(   getreg('*') , getregtype('*') )
                                            let found   = s:YRMRUHas('s:yr_history_list', elem)
                            
                                            " Only add the item to the "top" of the ring if it is
                                            " not in the ring already.
                                            if found == -1
                                                call YRRecord3("*")
                                            endif
                                            let s:yr_prev_clipboard_star = @*
                                        endif
    3              0.000003         endif
    3              0.000003     endif

FUNCTION  <SNR>232_LoadLinters()
Called 10 times
Total time:   0.000206
 Self time:   0.000206

count  total (s)   self (s)
   10              0.000037     if a:filetype ==# ''
                                    " Empty filetype? Nothing to be done about that.
                                    return []
                                endif
                            
   10              0.000053     if has_key(s:linters, a:filetype)
                                    " We already loaded the linter files for this filetype, so stop here.
   10              0.000051         return s:linters[a:filetype]
                                endif
                            
                                " Load all linters for a given filetype.
                                execute 'silent! runtime! ale_linters/' . a:filetype . '/*.vim'
                            
                                if !has_key(s:linters, a:filetype)
                                    " If we couldn't load any linters, let everyone know.
                                    let s:linters[a:filetype] = []
                                endif
                            
                                return s:linters[a:filetype]

FUNCTION  <SNR>267_job_output()
Called 7 times
Total time:   0.000121
 Self time:   0.000079

count  total (s)   self (s)
    7              0.000031   if has_key(s:jobs, a:id)
    7   0.000087   0.000045     return gitgutter#utility#stringify(s:jobs[a:id].output)
                              else
                                return ""
                              endif

FUNCTION  gitgutter#process_buffer()
Called 44 times
Total time:   0.050413
 Self time:   0.007227

count  total (s)   self (s)
   44   0.002702   0.000427   call gitgutter#utility#use_known_shell()
                            
   44   0.001643   0.000396   call gitgutter#utility#set_buffer(a:bufnr)
   44   0.004814   0.000274   if gitgutter#utility#is_active()
   30              0.000109     if g:gitgutter_sign_column_always
                                  call gitgutter#sign#add_dummy_sign()
                                endif
   30              0.000072     try
   30   0.000509   0.000231       if !a:realtime || gitgutter#utility#has_fresh_changes()
    8   0.031201   0.000787         let diff = gitgutter#diff#run_diff(a:realtime || gitgutter#utility#has_unsaved_changes(), 0)
    8              0.000037         if diff != 'async'
                                      call gitgutter#handle_diff(diff)
                                    endif
    8              0.000007       endif
   30              0.000108     catch /diff failed/
                                  call gitgutter#debug#log('diff failed')
                                  call gitgutter#hunk#reset()
                                endtry
   30   0.004103   0.002063     execute "silent doautocmd" s:nomodeline "User GitGutter"
   30              0.000093   else
   14   0.000519   0.000089     call gitgutter#hunk#reset()
   14              0.000027   endif
                            
   44   0.002416   0.000454   call gitgutter#utility#restore_shell()

FUNCTION  143()
Called 275 times
Total time:   0.021414
 Self time:   0.007727

count  total (s)   self (s)
  275   0.008259   0.000921     let cascade = self.getCascade()
  275              0.000354     let rv = ""
  550              0.000720     for node in cascade
  275   0.002727   0.001039         let rv = rv . node.path.displayString()
  275              0.000224     endfor
                            
  275              0.000877     let sym = cascade[-1].isOpen ? g:NERDTreeDirArrowCollapsible : g:NERDTreeDirArrowExpandable
                            
  275   0.005840   0.001179     let flags = cascade[-1].path.flagSet.renderToString()
                            
  275              0.000742     return sym . ' ' . flags . rv

FUNCTION  144()
Called 14 times
Total time:   0.017750
 Self time:   0.006699

count  total (s)   self (s)
   14   0.004034   0.000154     if a:path.equals(self.path)
    1              0.000001         return self
                                endif
   13   0.003945   0.000141     if stridx(a:path.str(), self.path.str(), 0) ==# -1
   11              0.000018         return {}
                                endif
                            
    2              0.000005     if self.path.isDirectory
   24              0.000092         for i in self.children
   23   0.002071   0.000108             let retVal = i.findNode(a:path)
   23              0.000040             if retVal != {}
    1              0.000001                 return retVal
                                        endif
   22              0.000022         endfor
    1              0.000001     endif
    1              0.000001     return {}

FUNCTION  145()
Called 275 times
Total time:   0.007338
 Self time:   0.001388

count  total (s)   self (s)
  275   0.006861   0.000911     if !self.isCascadable()
  275              0.000330         return [self]
                                endif
                            
                                let vc = self.getVisibleChildren()
                                let visChild = vc[0]
                            
                                return [self] + visChild.getCascade()

FUNCTION  146()
Called 23 times
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
   23              0.000050     return len(self.children)

FUNCTION  147()
Called 23 times
Total time:   0.026180
 Self time:   0.000465

count  total (s)   self (s)
   23   0.004229   0.000181     if stridx(a:path.str(), self.path.str(), 0) ==# -1
                                    return {}
                                endif
                            
   23   0.021769   0.000102     let index = self.getChildIndex(a:path)
   23              0.000026     if index ==# -1
                                    return {}
                                else
   23              0.000046         return self.children[index]
                                endif
                            

FUNCTION  149()
Called 23 times
Total time:   0.021667
 Self time:   0.002105

count  total (s)   self (s)
   23   0.004114   0.000161     if stridx(a:path.str(), self.path.str(), 0) ==# -1
                                    return -1
                                endif
                            
                                "do a binary search for the child
   23              0.000031     let a = 0
   23   0.000131   0.000075     let z = self.getChildCount()
   93              0.000107     while a < z
   93              0.000208         let mid = (a+z)/2
   93   0.016160   0.000607         let diff = a:path.compareTo(self.children[mid].path)
                            
   93              0.000106         if diff ==# -1
   40              0.000049             let z = mid
   40              0.000040         elseif diff ==# 1
   30              0.000053             let a = mid+1
   30              0.000027         else
   23              0.000023             return mid
                                    endif
   70              0.000053     endwhile
                                return -1

FUNCTION  gitgutter#diff#process_hunks()
Called 7 times
Total time:   0.003132
 Self time:   0.000357

count  total (s)   self (s)
    7   0.000297   0.000055   call gitgutter#hunk#reset()
    7              0.000020   let modified_lines = []
   23              0.000051   for hunk in a:hunks
   16   0.002685   0.000152     call extend(modified_lines, gitgutter#diff#process_hunk(hunk))
   16              0.000018   endfor
    7              0.000010   return modified_lines

FUNCTION  <SNR>124_GetMarkLine()
Called 1377 times
Total time:   0.026188
 Self time:   0.026188

count  total (s)   self (s)
 1377              0.002289     if v:version < 700
                                    let lnum = line(a:mark)
                                else
 1377              0.004806         let pos = getpos(a:mark)
 1377              0.003134         let lnum = pos[1]
 1377              0.003761         if pos[0] && bufnr("%") != pos[0]
   27              0.000037             let lnum = 0
   27              0.000025         endif
 1377              0.001131     endif
 1377              0.002134     return lnum

FUNCTION  gitgutter#utility#filename()
Called 2 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    2              0.000008   return fnamemodify(s:file, ':t')

FUNCTION  MyFugitive()
Called 1774 times
Total time:   0.318108
 Self time:   0.030511

count  total (s)   self (s)
 1774              0.010255   if exists("*fugitive#head")
 1774   0.298247   0.010650     let _ = fugitive#head()
 1774              0.007232     return strlen(_) ? '⭠ '._ : ''
                              endif
                              return ''

FUNCTION  <SNR>242_convert()
Called 98 times
Total time:   0.001860
 Self time:   0.001860

count  total (s)   self (s)
   98              0.000342   if has_key(s:lightline.component_expand, a:name)
                                let type = get(s:lightline.component_type, a:name, a:index)
                                return filter(s:map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1, v:key == 1 ? "' . type . '" : "' . a:index . '"]'), 'v:val[0] != []')
                              else
   98              0.000359     return [[[a:name], 0, a:index]]
                              endif

FUNCTION  xolox#misc#timer#start()
Called 4 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
                              " Start a timer. This returns a list which can later be passed to
                              " `xolox#misc#timer#stop()`.
    4              0.000031   return [s:unique_marker, s:has_reltime ? reltime() : localtime()]

FUNCTION  <SNR>247_OnBufferEnter()
Called 7 times
Total time:   0.410474
 Self time:   0.012031

count  total (s)   self (s)
    7   0.001110   0.000048   if !s:VisitedBufferRequiresReparse()
    3              0.000003     return
                              endif
                            
    4   0.407327   0.011859   exec s:python_command "ycm_state.OnBufferVisit()"
    4   0.001999   0.000086   call s:OnFileReadyToParse()

FUNCTION  153()
Called 325 times
Total time:   0.134095
 Self time:   0.015536

count  total (s)   self (s)
  325              0.000471     let toReturn = []
 1481              0.001795     for i in self.children
 1156   0.124420   0.005861         if i.path.ignore(self.getNerdtree()) ==# 0
  900              0.002169             call add(toReturn, i)
  900              0.000661         endif
 1156              0.000832     endfor
  325              0.000310     return toReturn

FUNCTION  155()
Called 300 times
Total time:   0.072827
 Self time:   0.003128

count  total (s)   self (s)
  300              0.000507     if g:NERDTreeCascadeSingleChildDir == 0
                                    return 0
                                endif
                            
  300   0.070719   0.001020     let c = self.getVisibleChildren()
  300              0.000794     return len(c) == 1 && c[0].path.isDirectory

FUNCTION  <SNR>242_flatten_twice()
Called 28 times
Total time:   0.001056
 Self time:   0.001056

count  total (s)   self (s)
   28              0.000050   let ys = []
   84              0.000138   for xs in a:xss
  154              0.000177     for x in xs
   98              0.000177       let ys += x
   98              0.000093     endfor
   56              0.000048   endfor
   28              0.000033   return ys

FUNCTION  tcomment#TypeExists()
Called 4 times
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
    4              0.000010     let comment_mode = a:0 >= 1 ? a:1 : ''
    4              0.000007     let name = a:name
    4              0.000014     if comment_mode =~? 'b'
                                    let name .= '_block'
                                elseif comment_mode =~? 'i'
                                    let name .= '_inline'
                                endif
    4              0.000012     return has_key(s:definitions, name) ? name : ''

FUNCTION  xolox#misc#cursorhold#register()
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
                              " Register a [CursorHold][] event handler with a custom interval. This
                              " function takes a single argument which is a dictionary with the following
                              " fields:
                              "
                              "  - **function** (required): The name of the event handler function (a
                              "    string).
                              "
                              "  - **arguments** (optional): A list of arguments to pass to the event
                              "    handler function (defaults to an empty list).
                              "
                              "  - **interval** (optional): The number of seconds between calls to the
                              "    event handler (defaults to 4).
    1              0.000011   call add(g:xolox#misc#cursorhold#handlers, copy(a:options))

FUNCTION  <SNR>237_RefreshBuffer()
Called 2 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    2              0.000010   if exists("b:rails_refresh") && b:rails_refresh
                                let b:rails_refresh = 0
                                let &filetype = &filetype
                                unlet! b:rails_refresh
                              endif

FUNCTION  76()
Called 2 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    2              0.000005     if !exists("s:keyMaps")
                                    let s:keyMaps = []
                                endif
    2              0.000003     return s:keyMaps

FUNCTION  77()
Called 2 times
Total time:   0.000436
 Self time:   0.000423

count  total (s)   self (s)
   82   0.000092   0.000079     for i in s:KeyMap.All()
   81              0.000152          if i.key ==# a:key && i.scope ==# a:scope
    1              0.000001             return i
                                    endif
   80              0.000051     endfor
    1              0.000001     return {}

FUNCTION  NERDTreeRender()
Called 24 times
Total time:   0.183399
 Self time:   0.000131

count  total (s)   self (s)
   24   0.183382   0.000114     call nerdtree#renderView()

FUNCTION  165()
Called 13 times
Total time:   0.178138
 Self time:   0.133620

count  total (s)   self (s)
   13   0.086649   0.000093     call self.path.refresh(self.getNerdtree())
                            
                                "if this node was ever opened, refresh its children
   13              0.000034     if self.isOpen || !empty(self.children)
                                    "go thru all the files/dirs under this node
    1              0.000001         let newChildNodes = []
    1              0.000002         let invalidFilesFound = 0
    1              0.000002         let dir = self.path
    1   0.000145   0.000006         let globDir = dir.str({'format': 'Glob'})
    1              0.001012         let filesStr = globpath(globDir, '*') . "\n" . globpath(globDir, '.*')
    1              0.000016         let files = split(filesStr, "\n")
   26              0.000038         for i in files
                                        "filter out the .. and . directories
                                        "Note: we must match .. AND ../ cos sometimes the globpath returns
                                        "../ for path with strange chars (eg $)
                                        "if i !~# '\/\.\.\/\?$' && i !~# '\/\.\/\?$'
                            
                                        " Regular expression is too expensive. Use simply string comparison
                                        " instead
   25              0.000291             if i[len(i)-3:2] != ".." && i[len(i)-2:2] != ".." && i[len(i)-2:1] != "." && i[len(i)-1] != "."
   23              0.000025                 try
                                                "create a new path and see if it exists in this nodes children
   23   0.007003   0.000519                     let path = g:NERDTreePath.New(i)
   23   0.026298   0.000118                     let newNode = self.getChild(path)
   23              0.000047                     if newNode != {}
   23   0.024182   0.000100                         call newNode.refresh()
   23              0.000079                         call add(newChildNodes, newNode)
                            
                                                "the node doesnt exist so create it
   23              0.000020                     else
                                                    let newNode = g:NERDTreeFileNode.New(path, self.getNerdtree())
                                                    let newNode.parent = self
                                                    call add(newChildNodes, newNode)
                                                endif
                            
                            
   23              0.000034                 catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
                                                let invalidFilesFound = 1
                                            endtry
   23              0.000019             endif
   25              0.000025         endfor
                            
                                    "swap this nodes children out for the children we just read/refreshed
    1              0.000054         let self.children = newChildNodes
    1   0.004971   0.000006         call self.sortChildren()
                            
    1              0.000002         if invalidFilesFound
                                        call nerdtree#echoWarning("some files could not be loaded into the NERD tree")
                                    endif
    1              0.000000     endif

FUNCTION  166()
Called 299 times
Total time:   2.261382
 Self time:   1.235385

count  total (s)   self (s)
  299   1.310897   0.002174     call self.path.refreshFlags(self.getNerdtree())
  831              0.001932     for i in self.children
  532   0.442141   0.001967         call i.refreshFlags()
  532              0.000449     endfor

FUNCTION  167()
Called 1 time
Total time:   0.001628
 Self time:   0.000006

count  total (s)   self (s)
    1   0.001627   0.000005     call self.path.refreshFlags(self.getNerdtree())

FUNCTION  xolox#misc#path#absolute()
Called 1 time
Total time:   0.000147
 Self time:   0.000069

count  total (s)   self (s)
                              " Canonicalize and resolve a pathname, *regardless of whether it exists*.
                              " This is intended to support string comparison to determine whether two
                              " pathnames point to the same directory or file.
    1              0.000004   if type(a:path) == type('')
    1              0.000002     let path = a:path
                                " Make the pathname absolute.
    1              0.000004     if path =~ '^\~'
                                  " Expand ~ to $HOME.
                                  let path = $HOME . '/' . path[1:]
                                elseif xolox#misc#path#is_relative(path)
                                  " Make relative pathnames absolute.
                                  let path = getcwd() . '/' . path
                                endif
                                " Resolve symbolic links to find the canonical pathname. In my tests this
                                " also removes all symbolic pathname segments (`.' and `..'), even when
                                " the pathname does not exist. Also there used to be a bug in resolve()
                                " where it wouldn't resolve pathnames ending in a directory separator.
                                " Since it's not much trouble to work around, that's what we do.
    1              0.000017     let path = resolve(substitute(path, s:windows_compatible ? '[\/]\+$' : '/\+$', '', ''))
                                " Normalize directory separators (especially relevant on Windows).
    1   0.000051   0.000008     let parts = xolox#misc#path#split(path)
    1              0.000002     if s:windows_compatible && parts[0] =~ '^[\/][\/]'
                                  " Also normalize the two leading "directory separators" (I'm not
                                  " sure what else to call them :-) in Windows UNC pathnames.
                                  let parts[0] = repeat(xolox#misc#path#directory_separator(), 2) . parts[0][2:]
                                elseif s:windows_compatible && parts[0] =~ '^[\/]$'
                                  " If a pathname is relative to the current drive we should add
                                  " the drive letter in order to make the pathname absolute.
                                  let parts[0] = matchstr(getcwd(), '^\a:')
                                endif
    1   0.000027   0.000007     return xolox#misc#path#join(parts)
                              endif
                              return ''

FUNCTION  <SNR>189_TmuxWinCmd()
Called 16 times
Total time:   0.336598
 Self time:   0.000501

count  total (s)   self (s)
   16   0.000393   0.000204   if s:InTmuxSession()
                                call s:TmuxAwareNavigate(a:direction)
                              else
   16   0.336042   0.000134     call s:VimNavigate(a:direction)
   16              0.000019   endif

FUNCTION  xolox#session#locking_enabled()
Called 1 time
Total time:   0.000043
 Self time:   0.000014

count  total (s)   self (s)
                              " Check whether session locking is enabled. Returns true (1) when locking is
                              " enabled, false (0) otherwise.
                              "
                              " By default session locking is enabled but users can opt-out by setting
                              " `g:session_lock_enabled` to false (0).
    1   0.000039   0.000010   return xolox#misc#option#get('session_lock_enabled', 1)

FUNCTION  81()
Called 1 time
Total time:   0.166577
 Self time:   0.000036

count  total (s)   self (s)
    1              0.000006     let Callback = function(self.callback)
    1              0.000002     if a:0
    1   0.166554   0.000013         call Callback(a:1)
    1              0.000002     else
                                    call Callback()
                                endif

FUNCTION  82()
Called 1 time
Total time:   0.167433
 Self time:   0.000117

count  total (s)   self (s)
                            
                                "required because clicking the command window below another window still
                                "invokes the <LeftRelease> mapping - but changes the window cursor
                                "is in first
                                "
                                "TODO: remove this check when the vim bug is fixed
    1   0.000029   0.000020     if !g:NERDTree.ExistsForBuf()
                                    return {}
                                endif
                            
    1   0.000303   0.000009     let node = g:NERDTreeFileNode.GetSelected()
    1              0.000003     if !empty(node)
                            
                                    "try file node
    1              0.000001         if !node.path.isDirectory
                                        let km = s:KeyMap.FindFor(a:key, "FileNode")
                                        if !empty(km)
                                            return km.invoke(node)
                                        endif
                                    endif
                            
                                    "try dir node
    1              0.000001         if node.path.isDirectory
    1   0.000292   0.000008             let km = s:KeyMap.FindFor(a:key, "DirNode")
    1              0.000002             if !empty(km)
                                            return km.invoke(node)
                                        endif
    1              0.000001         endif
                            
                                    "try generic node
    1   0.000156   0.000004         let km = s:KeyMap.FindFor(a:key, "Node")
    1              0.000002         if !empty(km)
    1   0.166601   0.000024             return km.invoke(node)
                                    endif
                            
                                endif
                            
                                "try bookmark
                                let bm = g:NERDTreeBookmark.GetSelected()
                                if !empty(bm)
                                    let km = s:KeyMap.FindFor(a:key, "Bookmark")
                                    if !empty(km)
                                        return km.invoke(bm)
                                    endif
                                endif
                            
                                "try all
                                let km = s:KeyMap.FindFor(a:key, "all")
                                if !empty(km)
                                    return km.invoke()
                                endif

FUNCTION  87()
Called 581 times
Total time:   0.003715
 Self time:   0.003715

count  total (s)   self (s)
  581              0.001639     if !exists("g:NERDTreeBookmarks")
                                    let g:NERDTreeBookmarks = []
                                endif
  581              0.000666     return g:NERDTreeBookmarks

FUNCTION  gitgutter#utility#set_buffer()
Called 58 times
Total time:   0.001563
 Self time:   0.001563

count  total (s)   self (s)
   58              0.000212   let s:bufnr = a:bufnr
   58              0.001289   let s:file = resolve(bufname(a:bufnr))

FUNCTION  gitgutter#debug#log()
Called 38 times
Total time:   0.002053
 Self time:   0.002053

count  total (s)   self (s)
   38              0.000139   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
                              endif

FUNCTION  170()
Called 1 time
Total time:   0.004965
 Self time:   0.000127

count  total (s)   self (s)
    1              0.000005     let CompareFunc = function("nerdtree#compareNodesBySortKey")
    1   0.004959   0.000121     call sort(self.children, CompareFunc)

FUNCTION  <SNR>161_WinEnterHandler()
Called 7 times
Total time:   0.000436
 Self time:   0.000110

count  total (s)   self (s)
    7              0.000019   if s:disable_handlers_for_tabdo
                                return
                              endif
                            
    7              0.000012   if g:nerdtree_tabs_autoclose
    7   0.000367   0.000041     call s:CloseIfOnlyNerdTreeLeft()
    7              0.000006   endif

FUNCTION  <SNR>138_DelaySearchIndex()
Called 1 time
Total time:   0.000107
 Self time:   0.000032

count  total (s)   self (s)
    1              0.000011     let s:DelaySearchIndex = 1
    1   0.000094   0.000019     call s:ScheduleEcho('','')

FUNCTION  nerdtree#echo()
Called 2 times
Total time:   0.000255
 Self time:   0.000255

count  total (s)   self (s)
    2              0.000189     redraw
    2              0.000063     echomsg "NERDTree: " . a:msg

FUNCTION  gitgutter#utility#extension()
Called 6 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    6              0.000027   return fnamemodify(s:file, ':e')

FUNCTION  <SNR>158_CursorHoldUpdate()
Called 29 times
Total time:   1.937560
 Self time:   0.002115

count  total (s)   self (s)
   29              0.000068     if g:NERDTreeUpdateOnCursorHold != 1
                                    return
                                endif
                            
   29   0.001692   0.000208     if !g:NERDTree.IsOpen()
                                    return
                                endif
                            
                                " Do not update when a special buffer is selected
   29              0.000094     if !empty(&l:buftype)
    6              0.000004         return
                                endif
                            
   23              0.000067     let l:winnr = winnr()
   23              0.000064     let l:altwinnr = winnr('#')
                            
   23   0.003518   0.000092     call g:NERDTree.CursorToTreeWin()
   23   1.757337   0.000406     call b:NERDTree.root.refreshFlags()
   23   0.173741   0.000137     call NERDTreeRender()
                            
   23              0.000252     exec l:altwinnr . 'wincmd w'
   23              0.000416     exec l:winnr . 'wincmd w'

FUNCTION  <SNR>161_CloseIfOnlyNerdTreeLeft()
Called 7 times
Total time:   0.000326
 Self time:   0.000326

count  total (s)   self (s)
    7              0.000304   if exists("t:NERDTreeBufName") && bufwinnr(t:NERDTreeBufName) != -1 && winnr("$") == 1
                                q
                              endif

FUNCTION  xolox#misc#timer#stop()
Called 3 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
                              " Show a formatted debugging message to the user, if the user has enabled
                              " increased verbosity by setting Vim's ['verbose'] [verbose] option to one
                              " (1) or higher.
                              "
                              " This function has the same argument handling as Vim's [printf()] [printf]
                              " function with one difference: At the point where you want the elapsed time
                              " to be embedded, you write `%s` and you pass the list returned by
                              " `xolox#misc#timer#start()` as an argument.
                              "
                              " [verbose]: http://vimdoc.sourceforge.net/htmldoc/options.html#'verbose'
                              " [printf]: http://vimdoc.sourceforge.net/htmldoc/eval.html#printf()
    3              0.000012   if (g:timer_enabled || &verbose >= g:timer_verbosity)
                                call call('xolox#misc#msg#info', map(copy(a:000), 'xolox#misc#timer#convert(v:val)'))
                              endif

FUNCTION  gitgutter#hunk#hunks()
Called 7 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    7              0.000019   return s:hunks

FUNCTION  <SNR>163_savetofile()
Called 1 time
Total time:   0.000134
 Self time:   0.000015

count  total (s)   self (s)
    1   0.000134   0.000015 	cal ctrlp#utils#writecache(a:mrufs, s:cadir, s:cafile)

FUNCTION  <SNR>272_CommentDef()
Called 1 time
Total time:   0.000190
 Self time:   0.000129

count  total (s)   self (s)
                                " TLogVAR a:beg, a:end, a:checkRx, a:comment_mode, a:cbeg, a:cend
    1              0.000002     let beg = a:beg
    1              0.000002     let end = a:end
    1              0.000004     if a:comment_mode =~# 'U'
                                    let uncomment = 1
                                elseif a:comment_mode =~# '[CK]'
                                    let uncomment = 0
                                else
    1              0.000003         if get(s:cdef, 'mixedindent', 1)
    1   0.000031   0.000010             let mdrx = '\V'. s:StartColRx(a:comment_mode, a:cbeg) .'\s\*'
    1              0.000005             let cbeg1 = a:comment_mode =~? 'i' ? a:cbeg : a:cbeg + 1
    1   0.000026   0.000008             let mdrx .= s:StartColRx(a:comment_mode, cbeg1, 0) .'\s\*'
    1              0.000001         else
                                        let mdrx = '\V'. s:StartColRx(a:comment_mode, a:cbeg) .'\s\*'
                                    endif
    1   0.000031   0.000009         let mdrx .= a:checkRx .'\s\*'. s:EndColRx(a:comment_mode, a:end, 0)
                                    " let mdrx = '\V'. s:StartPosRx(a:comment_mode, beg, a:cbeg) .'\s\*'. a:checkRx .'\s\*'. s:EndPosRx(a:comment_mode, end, 0)
                                    " TLogVAR mdrx
    1              0.000003         let line = getline(beg)
    1              0.000002         if a:cbeg != 0 && a:cend != 0
                                        let line = strpart(line, 0, a:cend - 1)
                                    endif
    1              0.000009         let uncomment = (line =~ mdrx)
                                    " TLogVAR 1, uncomment, line
    1              0.000002         let n  = beg + 1
    1              0.000004         if a:comment_mode =~# 'G'
    1              0.000001             if uncomment
                                            while n <= end
                                                if getline(n) =~ '\S'
                                                    if !(getline(n) =~ mdrx)
                                                        let uncomment = 0
                                                        " TLogVAR 2, uncomment
                                                        break
                                                    endif
                                                endif
                                                let n = n + 1
                                            endwh
                                        endif
    1              0.000002         elseif a:comment_mode =~# 'B'
                                        let t = @t
                                        try
                                            silent exec 'norm! '. beg.'G1|v'.end.'G$"ty'
                                            if &selection == 'inclusive' && @t =~ '\n$' && len(@t) > 1
                                                let @t = @t[0 : -2]
                                            endif
                                            " TLogVAR @t, mdrx
                                            let uncomment = (@t =~ mdrx)
                                            " TLogVAR 3, uncomment
                                            if !uncomment && a:comment_mode =~ 'o'
                                                let mdrx1 = substitute(mdrx, '\\$$', '\\n\\$', '')
                                                " TLogVAR mdrx1
                                                if @t =~ mdrx1
                                                    let uncomment = 1
                                                    " TLogVAR 4, uncomment
                                                endif
                                            endif
                                        finally
                                            let @t = t
                                        endtry
                                    endif
    1              0.000001     endif
                                " TLogVAR 5, beg, end, uncomment
    1              0.000002     return [beg, end, uncomment]

FUNCTION  <SNR>158_FileUpdate()
Called 1 time
Total time:   0.024813
 Self time:   0.000324

count  total (s)   self (s)
    1              0.000004     if g:NERDTreeUpdateOnWrite != 1
                                    return
                                endif
                            
    1   0.000079   0.000014     if !g:NERDTree.IsOpen()
                                    return
                                endif
                            
    1              0.000004     let l:winnr = winnr()
    1              0.000003     let l:altwinnr = winnr('#')
                            
    1   0.000452   0.000004     call g:NERDTree.CursorToTreeWin()
    1   0.011021   0.000206     let l:node = b:NERDTree.root.findNode(g:NERDTreePath.New(a:fname))
    1              0.000001     if l:node == {}
                                    return
                                endif
    1   0.001745   0.000007     call l:node.refreshFlags()
    1              0.000002     let l:node = l:node.parent
    2              0.000005     while !empty(l:node)
    1   0.001635   0.000007         call l:node.refreshDirFlags()
    1              0.000003         let l:node = l:node.parent
    1              0.000001     endwhile
                            
    1   0.009800   0.000005     call NERDTreeRender()
                            
    1              0.000007     exec l:altwinnr . 'wincmd w'
    1              0.000037     exec l:winnr . 'wincmd w'

FUNCTION  <SNR>272_ReplaceInLine()
Called 3 times
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    3              0.000009     if has_key(s:cdef, 'replacements')
                                    let replacements = s:cdef.replacements
                                    return s:DoReplacements(a:text, keys(replacements), values(replacements))
                                else
    3              0.000003         return a:text
                                endif

FUNCTION  xolox#misc#os#is_mac()
Called 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
                              " Returns 1 (true) when on Mac OS X, 0 (false) otherwise. You would expect
                              " this to simply check the Vim feature list, but for some obscure reason the
                              " `/usr/bin/vim` included in Mac OS X (verified on version 10.7.5) returns 0
                              " (false) in response to `has('mac')`, so we check the output of `uname`
                              " to avoid false negatives.
    1              0.000003   if !exists('s:is_mac')
                                " By default we assume we are *not* on Mac OS X.
    1              0.000002     let s:is_mac = 0
    1              0.000004     if has('mac') || has('macunix') || has('gui_mac')
                                  " If Vim's feature list indicates we are on Mac OS X, we have our answer :-).
    1              0.000002       let s:is_mac = 1
    1              0.000002     elseif !xolox#misc#os#is_win()
                                  " Otherwise we check the output of `uname' to avoid false negatives.
                                  let result = xolox#misc#os#exec({'command': 'uname', 'check': 0})
                                  if result['exit_code'] == 0 && get(result['stdout'], 0, '') == 'Darwin'
                                    let s:is_mac = 1
                                  endif
                                endif
    1              0.000001   endif
    1              0.000002   return s:is_mac

FUNCTION  212()
Called 581 times
Total time:   0.003105
 Self time:   0.003105

count  total (s)   self (s)
  581              0.002907     let self._flags[a:scope] = []

FUNCTION  xolox#misc#option#split_tags()
Called 1 time
Total time:   0.000060
 Self time:   0.000040

count  total (s)   self (s)
                              " Customized version of `xolox#misc#option#split()` with specialized
                              " handling for Vim's ['tags' option] [tags].
                              "
                              " [tags]: http://vimdoc.sourceforge.net/htmldoc/options.html#'tags'
    1              0.000015   let values = split(a:value, '[^\\]\zs,')
    1   0.000043   0.000023   return map(values, 's:unescape_tags(v:val)')

FUNCTION  <SNR>138_ScheduleEcho()
Called 2 times
Total time:   0.000109
 Self time:   0.000109

count  total (s)   self (s)
                            
                                "if &ut > 50 | let g:IndSearchUT=&ut | let &ut=50 | endif
                                "if &ut > 100 | let g:IndSearchUT=&ut | let &ut=100 | endif
    2              0.000019     if &ut > 200 | let g:IndSearchUT=&ut | let &ut=200 | endif
                                " 061116 &ut is sometimes not restored and drops permanently to 50. But how ?
                            
    2              0.000008     let s:ScheduledEcho      = a:msg
    2              0.000016     let use_colors = !exists('g:indexed_search_colors') || g:indexed_search_colors
    2              0.000009     let s:ScheduledHighlight = ( use_colors ? a:highlight : "None" )
                            
    2              0.000011     aug IndSearchEcho
                            
    2              0.000027     au CursorHold *  exe 'set ut='.g:IndSearchUT |  if s:DelaySearchIndex | call s:ShowCurrentSearchIndex(0,'') |     let s:ScheduledEcho = s:Msg | let s:ScheduledHighlight = s:Highlight |    let s:DelaySearchIndex = 0 | endif | if s:ScheduledEcho != ""  | exe "echohl ".s:ScheduledHighlight | echo s:ScheduledEcho | echohl None | let s:ScheduledEcho='' |  endif |  aug IndSearchEcho | exe 'au!' | aug END | aug! IndSearchEcho
                                " how about moving contents of this au into function
                            
    2              0.000002     aug END

FUNCTION  gitgutter#hunk#increment_lines_modified()
Called 16 times
Total time:   0.000576
 Self time:   0.000306

count  total (s)   self (s)
   16   0.000100   0.000067   let bufnr = gitgutter#utility#bufnr()
   16   0.000311   0.000074   let summary = gitgutter#hunk#summary(bufnr)
   16              0.000067   let summary[1] += a:count
   16              0.000083   call setbufvar(bufnr, 'gitgutter_summary', summary)

FUNCTION  ale#Queue()
Called 9 times
Total time:   0.001102
 Self time:   0.000267

count  total (s)   self (s)
                                " Do nothing for blacklisted files.
    9              0.000045     if index(g:ale_filetype_blacklist, &filetype) >= 0
    3              0.000003         return
                                endif
                            
    6              0.000014     if s:lint_timer != -1
    4              0.000015         call timer_stop(s:lint_timer)
    4              0.000011         let s:lint_timer = -1
    4              0.000002     endif
                            
    6   0.000883   0.000048     let l:linters = ale#linter#Get(&filetype)
    6              0.000015     if len(l:linters) == 0
                                    " There are no linters to lint with, so stop here.
    2              0.000002         return
                                endif
                            
    4              0.000005     if a:delay > 0
    4              0.000023         let s:lint_timer = timer_start(a:delay, function('ale#Lint'))
    4              0.000004     else
                                    call ale#Lint()
                                endif

FUNCTION  gitgutter#utility#directory_of_file()
Called 8 times
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    8              0.000043   return fnamemodify(s:file, ':h')

FUNCTION  xolox#misc#async#periodic_callback()
Called 2 times
Total time:   0.000138
 Self time:   0.000118

count  total (s)   self (s)
                              " When client/server support is not being used the vim-misc plug-in
                              " improvises: It uses Vim's [CursorHold][] event to periodically check if an
                              " asynchronous process has written its results to one of the expected
                              " temporary files. If a response is found the temporary file is read and
                              " deleted and then `xolox#misc#async#callback_to_parent()` is called to
                              " process the response.
                              "
                              " [CursorHold]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#CursorHold
    2              0.000010   if !empty(g:xolox#misc#async#requests)
    1              0.000001     let num_processed = 0
    1   0.000017   0.000006     call xolox#misc#msg#debug("vim-misc %s: Checking for asynchronous responses (%i responses not yet received) ..", g:xolox#misc#version, len(g:xolox#misc#async#requests))
    2              0.000006     for unique_number in sort(keys(g:xolox#misc#async#requests))
    1              0.000003       let request = g:xolox#misc#async#requests[unique_number]
    1              0.000003       let temporary_file = get(request, 'temporary_file', '')
    1              0.000003       if !empty(temporary_file) && getfsize(temporary_file) > 0
                                    try
                                      call xolox#misc#msg#debug("vim-misc %s: Found asynchronous response by %s in %s ..", g:xolox#misc#version, request['function'], temporary_file)
                                      call xolox#misc#async#callback_to_parent(xolox#misc#persist#load(temporary_file))
                                      let num_processed += 1
                                    finally
                                      call delete(temporary_file)
                                    endtry
                                  endif
    1              0.000001     endfor
    1   0.000016   0.000007     call xolox#misc#msg#debug("vim-misc %s: Processed %i asynchronous responses (%i responses not yet received).", g:xolox#misc#version, num_processed, len(g:xolox#misc#async#requests))
    1              0.000001   endif

FUNCTION  xolox#misc#cursorhold#autocmd()
Called 29 times
Total time:   0.003356
 Self time:   0.002481

count  total (s)   self (s)
                              " The 'top level event handler' that's called by Vim whenever the
                              " [CursorHold][] or [CursorHoldI][] event fires. It iterates through the
                              " event handlers registered using `xolox#misc#cursorhold#register()` and
                              " calls each event handler at the appropriate interval, keeping track of
                              " the time when each event handler was last run.
   60              0.000157   for handler in g:xolox#misc#cursorhold#handlers
   31              0.000094     let function = handler['function']
   31              0.000120     let last_run = get(handler, 'last_run', 0)
   31              0.000082     let interval = get(handler, 'interval', 4)
   31   0.000717   0.000298     call xolox#misc#msg#debug("vim-misc %s: Checking handler %s with interval %i and last run %i ..", g:xolox#misc#version, function, interval, last_run)
                                " Rate limit in case &updatetime is set (very) low.
   31              0.000173     let time_until_next_run = (last_run + interval) - localtime()
   31              0.000042     if time_until_next_run > 0
   28   0.000461   0.000198       call xolox#misc#msg#debug("vim-misc %s: Rate limiting handler %s (time until next run: %i seconds).", g:xolox#misc#version, function, time_until_next_run)
   28              0.000025     else
    3   0.000040   0.000015       call xolox#misc#msg#debug("vim-misc %s: Running handler %s ..", g:xolox#misc#version, function)
    3   0.000201   0.000033       call call(function, get(handler, 'arguments', []))
    3              0.000012       let handler['last_run'] = localtime()
    3              0.000003     endif
   31              0.000028   endfor

FUNCTION  <SNR>277_discover_supported_filetypes()
Called 9 times
Total time:   0.060235
 Self time:   0.004259

count  total (s)   self (s)
                              " Initialize predefined groups & mappings and discover supported file types.
    9              0.000021   if !s:discovered_filetypes
                                " Discover the file types supported by Exuberant Ctags?
    1   0.000126   0.000019     let command_line = xolox#easytags#ctags_command()
    1              0.000004     if !empty(command_line)
    1   0.000027   0.000016       let starttime = xolox#misc#timer#start()
    1              0.000006       let command_line .= ' --list-languages'
   50   0.054277   0.000120       for line in xolox#misc#os#exec({'command': command_line})['stdout']
   49              0.000305         if line =~ '\[disabled\]$'
                                      " Ignore languages that have been explicitly disabled using `--languages=-Vim'.
    2              0.000003           continue
                                    elseif line =~ '^\w\S*$'
   47   0.004111   0.002443           call add(s:supported_filetypes, xolox#easytags#filetypes#to_vim(xolox#misc#str#trim(line)))
   47              0.000069         elseif line =~ '\S'
                                      call xolox#misc#msg#warn("easytags.vim %s: Failed to parse line of output from ctags --list-languages: %s", g:xolox#easytags#version, string(line))
                                    endif
   47              0.000044       endfor
    1              0.000002       let msg = "easytags.vim %s: Retrieved %i supported languages in %s."
    1   0.000029   0.000015       call xolox#misc#timer#stop(msg, g:xolox#easytags#version, len(s:supported_filetypes), starttime)
    1              0.000001     endif
                                " Add file types supported by language specific programs.
    1   0.000030   0.000011     call extend(s:supported_filetypes, keys(xolox#misc#option#get('easytags_languages', {})))
                                " Don't run s:discover_supported_filetypes() more than once.
    1              0.000004     let s:discovered_filetypes = 1
    1              0.000001   endif

FUNCTION  <SNR>247_AllowedToCompleteInCurrentBuffer()
Called 752 times
Total time:   0.038877
 Self time:   0.006605

count  total (s)   self (s)
  752   0.038323   0.006051   return s:AllowedToCompleteInBuffer( '%' )

FUNCTION  nerdtree#runningWindows()
Called 29790 times
Total time:   0.223129
 Self time:   0.223129

count  total (s)   self (s)
29790              0.214300     return has("win16") || has("win32") || has("win64")

FUNCTION  <SNR>237_BufDatabase()
Called 2 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    2              0.000012   if exists("s:lock_database") || !exists('g:loaded_dbext') || !exists('b:rails_root')
    2              0.000002     return
                              endif
                              let self = rails#app()
                              if a:level > 1
                                call self.cache.clear('db_config')
                              elseif exists('g:rails_no_dbext')
                                return
                              endif
                              if (a:0 && !empty(a:1))
                                let env = a:1
                              else
                                let env = s:environment()
                              endif
                              if !self.cache.has('db_config') && a:level <= 0
                                return
                              endif
                              let dict = self.dbext_settings(env)
                              if empty(dict)
                                return
                              endif
                              for key in ['type', 'profile', 'bin', 'user', 'passwd', 'dbname', 'srvname', 'host', 'port', 'dsnname', 'extra', 'integratedlogin']
                                let b:dbext_{key} = get(dict,key,'')
                              endfor
                              if b:dbext_type == 'SQLITE'
                                " dbext seems to have overlooked the release of sqlite3 a decade ago
                                let g:dbext_default_SQLITE_bin = "sqlite3"
                              endif
                              if b:dbext_type == 'PGSQL'
                                let $PGPASSWORD = b:dbext_passwd
                              elseif exists('$PGPASSWORD')
                                let $PGPASSWORD = ''
                              endif

FUNCTION  <SNR>267_accumulate_job_output()
Called 16 times
Total time:   0.012554
 Self time:   0.012554

count  total (s)   self (s)
   16              0.012545   call add(s:jobs[a:id].output, a:line)

FUNCTION  <SNR>192_YRFocusGained()
Called 3 times
Total time:   0.004249
 Self time:   0.000636

count  total (s)   self (s)
                                " FocusGained is not available in general by console vim.
                                " There are some terminal windows which support it though.
                                " This thread on vim_use covers some of it:
                                "     http://groups.google.com/group/vim_use/browse_thread/thread/8dd3fb054ee922c6/59bee226473a9eea?lnk=gst&q=console+FocusGained#59bee226473a9eea
                                "     http://groups.google.com/group/vim_dev/browse_thread/thread/ba58fb493a3cf4ba/dc1a22ba1e92579d?lnk=gst&q=terminal+FocusGained#dc1a22ba1e92579d
                                " Does not work:
                                "     urxvt terminal
                                " Works:
                                "     GTK2 GUI, on Fedora 11, both as gvim and as vim in a GNOME Terminal
                                "
                                " Simple test, create the following autocmd and gain and loose focus in
                                " the terminal:
                                "     autocmd FocusLost * echomsg "focus lost"
                                "     autocmd FocusGained * echomsg "focus gained"
    3   0.003564   0.000055     call s:YRCheckClipboard()
                            
                                " If the yankring window is open, refresh it
    3   0.000604   0.000500     call s:YRWindowUpdate()

FUNCTION  xolox#easytags#async_callback()
Called 1 time
Total time:   0.000128
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000003   if has_key(a:response, 'result')
    1   0.000118   0.000010     call s:report_results(a:response['result'], 1)
    1              0.000001   else
                                call xolox#misc#msg#warn("easytags.vim %s: Asynchronous tags file update failed! (%s at %s)", g:xolox#easytags#version, a:response['exception'], a:response['throwpoint'])
                              endif

FUNCTION  246()
Called 25 times
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
   25              0.000038     return self._showHelp

FUNCTION  <SNR>167_readfile()
Called 2 times
Total time:   0.000123
 Self time:   0.000123

count  total (s)   self (s)
    2              0.000006   try
    2              0.000087     return readfile(a:fname)
                              catch
                                call xolox#misc#msg#warn("vim-misc %s: Failed to read temporary file (%s) with %s of external command: %s! (external command: %s)", g:xolox#misc#version, a:fname, a:label, v:exception, a:cmd)
                                return []
                              endtry

FUNCTION  NERDTreeGitStatusRefreshListener()
Called 581 times
Total time:   1.008660
 Self time:   0.013877

count  total (s)   self (s)
  581              0.001887     if !exists('b:NOT_A_GIT_REPOSITORY')
                                    call g:NERDTreeGitStatusRefresh()
                                endif
  581              0.001113     let l:path = a:event.subject
  581   0.993073   0.003179     let l:flag = g:NERDTreeGetGitStatusPrefix(l:path)
  581   0.005677   0.002572     call l:path.flagSet.clearFlags('git')
  581              0.000919     if l:flag !=# ''
   97   0.002208   0.000424         call l:path.flagSet.addFlag('git', l:flag)
   97              0.000070     endif

FUNCTION  <SNR>242_subseparator()
Called 42 times
Total time:   0.002619
 Self time:   0.002619

count  total (s)   self (s)
   42              0.000283   let [a, c, f, v, u ] = [ a:components, s:lightline.component, s:lightline.component_function, s:lightline.component_visible_condition, s:lightline.component_function_visible_condition ]
   42              0.001765   let xs = map(range(len(a:components)), 'a:expanded[v:val] ? "1" : has_key(f, a[v:val]) ? (has_key(u, a[v:val]) ? "(".u[a[v:val]].")" : (exists("*".f[a[v:val]]) ? "" : "exists(\"*".f[a[v:val]]."\")&&").f[a[v:val]]."()!=#\"\"") : has_key(v, a[v:val]) ? "(".v[a[v:val]].")" : has_key(c, a[v:val]) ? "1" : "0"')
   42              0.000527   return '%{' . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : xs[0] . '&&(') . join(xs[1:], '||') . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : ')') . '?"' . a:subseparator . '":""}'

FUNCTION  <SNR>272_BlockGetCommentRx()
Called 1 time
Total time:   0.000035
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000003     if has_key(a:cdef, 'commentstring_rx')
                                    return a:cdef.commentstring_rx
                                else
    1   0.000024   0.000009         let cms0 = s:BlockGetCommentString(a:cdef)
    1              0.000003         let cms0 = escape(cms0, '\')
    1              0.000001         return cms0
                                endif

FUNCTION  <SNR>272_GetStartEnd()
Called 1 time
Total time:   0.000128
 Self time:   0.000128

count  total (s)   self (s)
                                " TLogVAR a:beg, a:end, a:comment_mode
    1              0.000003     if type(a:beg) == 3
                                    let [lbeg, cbeg] = a:beg
                                    let [lend, cend] = a:end
                                else
    1              0.000001         let lbeg = a:beg
    1              0.000001         let lend = a:end
    1              0.000002         let comment_mode = a:comment_mode
                                    " TLogVAR comment_mode
    1              0.000003         if comment_mode =~# 'R'
                                        let cbeg = virtcol('.')
                                        let cend = virtcol('$')
                                        let comment_mode = substitute(comment_mode, '\CR', 'G', 'g')
                                        " TLogVAR 'R', cbeg, cend, comment_mode
                                    elseif comment_mode =~# 'I'
                                        let cbeg = virtcol("'<")
                                        if cbeg == 0
                                            let cbeg = virtcol('.')
                                        endif
                                        let cend = virtcol("'>")
                                        if cend < virtcol('$') && (comment_mode =~# 'o' || &selection == 'inclusive')
                                            let cend += 1
                                            " TLogVAR cend, virtcol('$')
                                        endif
                                        " TLogVAR 'I', cbeg, cend, comment_mode
                                    else
    1              0.000002             let cbeg = -1
    1              0.000002             let cend = 0
    4              0.000008             for lnum in range(a:beg, a:end)
    3              0.000013                 if getline(lnum) =~ '\S'
    3              0.000009                     let indentwidth = indent(lnum)
                                                " TLogVAR cbeg, lnum, indentwidth, getline(lnum)
    3              0.000006                     if cbeg == -1 || indentwidth < cbeg
    1              0.000001                         let cbeg = indentwidth
    1              0.000001                     endif
    3              0.000002                 endif
    3              0.000003             endfor
    1              0.000002             if cbeg == -1
                                            let cbeg = 0
                                        endif
    1              0.000000         endif
    1              0.000000     endif
                                " TLogVAR lbeg, cbeg, lend, cend
    1              0.000002     if lend < lbeg || (lend == lbeg && cend > 0 && cend < cbeg)
                                    return [lend, cend, lbeg, cbeg]
                                else
    1              0.000002         return [lbeg, cbeg, lend, cend]
                                endif

FUNCTION  gitgutter#sign#upsert_new_gitgutter_signs()
Called 7 times
Total time:   0.002167
 Self time:   0.001880

count  total (s)   self (s)
    7   0.000050   0.000036   let bufnr = gitgutter#utility#bufnr()
    7              0.000039   let other_signs         = getbufvar(bufnr, 'gitgutter_other_signs')
    7              0.000032   let old_gitgutter_signs = getbufvar(bufnr, 'gitgutter_gitgutter_signs')
                            
   27              0.000046   for line in a:modified_lines
   20              0.000082     let line_number = line[0]  " <number>
   20              0.000058     if index(other_signs, line_number) == -1  " don't clobber others' signs
   20   0.000384   0.000128       let name = gitgutter#utility#highlight_name_for_change(line[1])
   20              0.000073       if !has_key(old_gitgutter_signs, line_number)  " insert
    3   0.000033   0.000016         let id = gitgutter#sign#next_sign_id()
    3              0.000828         execute "sign place" id "line=" . line_number "name=" . name "buffer=" . bufnr
    3              0.000005       else  " update if sign has changed
   17              0.000051         let old_sign = old_gitgutter_signs[line_number]
   17              0.000044         if old_sign.name !=# name
                                      execute "sign place" old_sign.id "name=" . name "buffer=" . bufnr
                                    end
   17              0.000014       endif
   20              0.000016     endif
   20              0.000017   endfor
                              " At this point b:gitgutter_gitgutter_signs is out of date.

FUNCTION  lightline#mode()
Called 887 times
Total time:   0.007831
 Self time:   0.007831

count  total (s)   self (s)
  887              0.006905   return get(s:lightline.mode_map, mode(), '')

FUNCTION  nerdtree#compareNodesBySortKey()
Called 92 times
Total time:   0.004838
 Self time:   0.000701

count  total (s)   self (s)
   92   0.002945   0.000351     if a:n1.path.getSortKey() <# a:n2.path.getSortKey()
   38              0.000032         return -1
                                elseif a:n1.path.getSortKey() ># a:n2.path.getSortKey()
   54              0.000040         return 1
                                else
                                    return 0
                                endif

FUNCTION  gitgutter#async#available()
Called 8 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    8              0.000015   return s:available

FUNCTION  <SNR>217_Highlight_Matching_Pair()
Called 725 times
Total time:   0.104183
 Self time:   0.104183

count  total (s)   self (s)
                              " Remove any previous match.
  725              0.003266   if exists('w:paren_hl_on') && w:paren_hl_on
   23              0.000111     silent! call matchdelete(3)
   23              0.000051     let w:paren_hl_on = 0
   23              0.000019   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  725              0.007496   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  725              0.003141   let c_lnum = line('.')
  725              0.002711   let c_col = col('.')
  725              0.001189   let before = 0
                            
  725              0.002646   let text = getline(c_lnum)
  725              0.018763   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
  725              0.002243   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
  725              0.004807     let [c_before, c] = matches[1:2]
  725              0.000737   endif
  725              0.014180   let plist = split(&matchpairs, '.\zs[:,]')
  725              0.003377   let i = index(plist, c)
  725              0.001248   if i < 0
                                " not found, in Insert mode try character before the cursor
  701              0.003684     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
                                endif
  701              0.000857     if i < 0
                                  " not found, nothing to do
  701              0.001005       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
   24              0.000030   if i % 2 == 0
   11              0.000019     let s_flags = 'nW'
   11              0.000037     let c2 = plist[i + 1]
   11              0.000009   else
   13              0.000025     let s_flags = 'nbW'
   13              0.000023     let c2 = c
   13              0.000058     let c = plist[i - 1]
   13              0.000011   endif
   24              0.000043   if c == '['
   14              0.000022     let c = '\['
   14              0.000020     let c2 = '\]'
   14              0.000013   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
   24              0.000030   if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
   24              0.000122   let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
   24              0.003198   execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
   24              0.000099   let stoplinebottom = line('w$')
   24              0.000086   let stoplinetop = line('w0')
   24              0.000035   if i % 2 == 0
   11              0.000030     let stopline = stoplinebottom
   11              0.000009   else
   13              0.000036     let stopline = stoplinetop
   13              0.000019   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
   24              0.000092   if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
   24              0.000146     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
   24              0.000019   endif
   24              0.000074   try
   24              0.003141     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
   24              0.000053   catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
   24              0.000045   if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
   24              0.000081   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
   24              0.000096     if exists('*matchaddpos')
   24              0.001212       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
   24              0.000033     else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
   24              0.000060     let w:paren_hl_on = 1
   24              0.000021   endif

FUNCTION  <SNR>189_InTmuxSession()
Called 16 times
Total time:   0.000189
 Self time:   0.000189

count  total (s)   self (s)
   16              0.000161   return $TMUX != ''

FUNCTION  gitgutter#diff#parse_hunk()
Called 16 times
Total time:   0.000741
 Self time:   0.000741

count  total (s)   self (s)
   16              0.000369   let matches = matchlist(a:line, s:hunk_re)
   16              0.000048   if len(matches) > 0
   16              0.000064     let from_line  = str2nr(matches[1])
   16              0.000074     let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
   16              0.000052     let to_line    = str2nr(matches[3])
   16              0.000060     let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
   16              0.000046     return [from_line, from_count, to_line, to_count]
                              else
                                return []
                              end

FUNCTION  gitgutter#utility#has_fresh_changes()
Called 23 times
Total time:   0.000278
 Self time:   0.000278

count  total (s)   self (s)
   23              0.000258   return getbufvar(s:bufnr, 'changedtick') != getbufvar(s:bufnr, 'gitgutter_last_tick')

FUNCTION  <SNR>192_YRWindowUpdate()
Called 3 times
Total time:   0.000104
 Self time:   0.000104

count  total (s)   self (s)
    3              0.000049     let orig_win_bufnr = bufwinnr('%')
                            
                                " Switch to the yankring buffer
                                " only if it is already visible
    3              0.000018     if bufwinnr(s:yr_buffer_id) != -1
                                    call s:YRShow(0)
                                    " Switch back to the original buffer
                                    exec orig_win_bufnr . "wincmd w"
                                endif

FUNCTION  xolox#misc#os#is_win()
Called 10 times
Total time:   0.000112
 Self time:   0.000112

count  total (s)   self (s)
                              " Returns 1 (true) when on Microsoft Windows, 0 (false) otherwise.
   10              0.000101   return has('win16') || has('win32') || has('win64')

FUNCTION  <SNR>272_BlockGetCommentString()
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000002     if has_key(a:cdef, 'middle')
                                    return a:cdef.commentstring
                                else
    1              0.000009         return matchstr(a:cdef.commentstring, '^.\{-}\ze\(\n\|$\)')
                                endif

FUNCTION  xolox#easytags#utils#resolve()
Called 1 time
Total time:   0.000044
 Self time:   0.000020

count  total (s)   self (s)
    1   0.000038   0.000014   if !empty(a:pathname) && xolox#misc#option#get('easytags_resolve_links', 0)
                                return resolve(a:pathname)
                              endif
    1              0.000001   return a:pathname

FUNCTION  <SNR>168_prep_cmdline()
Called 1 time
Total time:   0.000387
 Self time:   0.000141

count  total (s)   self (s)
    1   0.000073   0.000005   let vim_file_type = xolox#easytags#filetypes#canonicalize(&filetype)
    1   0.000022   0.000005   let custom_languages = xolox#misc#option#get('easytags_languages', {})
    1              0.000003   let language = get(custom_languages, vim_file_type, {})
    1              0.000001   if empty(language)
    1   0.000064   0.000008     let cmdline = [xolox#easytags#ctags_command()]
    1              0.000004     call add(cmdline, '--fields=+l')
    1              0.000002     call add(cmdline, '--c-kinds=+p')
    1              0.000002     call add(cmdline, '--c++-kinds=+p')
    1              0.000002     call add(cmdline, '--sort=no')
    1              0.000002     call add(cmdline, '-f-')
    1   0.000021   0.000004     if xolox#misc#option#get('easytags_include_members', 0)
                                  call add(cmdline, '--extra=+q')
                                endif
    1              0.000001   else
                                let program = get(language, 'cmd', xolox#easytags#ctags_command())
                                if empty(program)
                                  call xolox#misc#msg#warn("easytags.vim %s: No 'cmd' defined for language '%s', and also no global default!", g:xolox#easytags#version, vim_file_type)
                                  return ''
                                endif
                                let cmdline = [program] + get(language, 'args', [])
                                call add(cmdline, xolox#misc#escape#shell(get(language, 'stdout_opt', '-f-')))
                              endif
    1              0.000002   let have_args = 0
    1              0.000002   if a:cfile != ''
    1   0.000021   0.000005     if xolox#misc#option#get('easytags_autorecurse', 0)
                                  call add(cmdline, empty(language) ? '-R' : xolox#misc#escape#shell(get(language, 'recurse_flag', '-R')))
                                  call add(cmdline, xolox#misc#escape#shell(a:cfile))
                                else
    1              0.000001       if empty(language)
                                    " TODO Should --language-force distinguish between C and C++?
                                    " TODO --language-force doesn't make sense for JavaScript tags in HTML files?
    1   0.000019   0.000010         let filetype = xolox#easytags#filetypes#to_ctags(vim_file_type)
    1   0.000042   0.000007         call add(cmdline, xolox#misc#escape#shell('--language-force=' . filetype))
    1              0.000001       endif
    1   0.000033   0.000005       call add(cmdline, xolox#misc#escape#shell(a:cfile))
    1              0.000001     endif
    1              0.000002     let have_args = 1
    1              0.000000   else
                                for arg in a:arguments
                                  if arg =~ '^-'
                                    call add(cmdline, arg)
                                    let have_args = 1
                                  else
                                    let matches = split(expand(arg), "\n")
                                    if !empty(matches)
                                      call map(matches, 'xolox#misc#escape#shell(xolox#easytags#utils#canonicalize(v:val))')
                                      call extend(cmdline, matches)
                                      let have_args = 1
                                    endif
                                  endif
                                endfor
                              endif
                              " No need to run Exuberant Ctags without any filename arguments!
    1              0.000005   return have_args ? join(cmdline) : ''

FUNCTION  gitgutter#utility#restore_shell()
Called 44 times
Total time:   0.001962
 Self time:   0.001962

count  total (s)   self (s)
   44              0.000234   if has('unix')
   44              0.000228     if exists('s:shell')
   44              0.000640       let &shell = s:shell
   44              0.000303       let &shellcmdflag = s:shellcmdflag
   44              0.000253       let &shellredir = s:shellredir
   44              0.000067     endif
   44              0.000047   endif

FUNCTION  gitgutter#sign#obsolete_gitgutter_signs_to_remove()
Called 7 times
Total time:   0.002179
 Self time:   0.002162

count  total (s)   self (s)
    7   0.000060   0.000043   let bufnr = gitgutter#utility#bufnr()
    7              0.000013   let signs_to_remove = []  " list of [<id (number)>, ...]
    7              0.000017   let remove_all_signs = 1
    7              0.001598   let old_gitgutter_signs = getbufvar(bufnr, 'gitgutter_gitgutter_signs')
   24              0.000082   for line_number in keys(old_gitgutter_signs)
   17              0.000086     if index(a:new_gitgutter_signs_line_numbers, str2nr(line_number)) == -1
                                  call add(signs_to_remove, old_gitgutter_signs[line_number].id)
                                else
   17              0.000034       let remove_all_signs = 0
   17              0.000015     endif
   17              0.000018   endfor
    7              0.000051   let s:remove_all_old_signs = remove_all_signs
    7              0.000014   return signs_to_remove

FUNCTION  <SNR>168_python_available()
Called 4 times
Total time:   0.002692
 Self time:   0.002692

count  total (s)   self (s)
    4              0.000014   if !exists('s:is_python_available')
    1              0.000002     try
    1              0.002548       execute 'pyfile' fnameescape(g:easytags_python_script)
    1              0.000010       redir => output
    1              0.000042         silent python easytags_ping()
    1              0.000004       redir END
    1              0.000016       let s:is_python_available = (output =~ 'it works!')
    1              0.000003     catch
                                  let s:is_python_available = 0
                                endtry
    1              0.000000   endif
    4              0.000006   return s:is_python_available

FUNCTION  ale#util#BinarySearch()
Called 340 times
Total time:   0.012083
 Self time:   0.012083

count  total (s)   self (s)
  340              0.001551     let l:min = 0
  340              0.002971     let l:max = len(a:loclist) - 1
  340              0.001537     let l:last_column_match = -1
                            
  340              0.001191     while 1
  340              0.001199         if l:max < l:min
  340              0.001534             return l:last_column_match
                                    endif
                            
                                    let l:mid = (l:min + l:max) / 2
                                    let l:obj = a:loclist[l:mid]
                            
                                    " Binary search to get on the same line
                                    if a:loclist[l:mid]['lnum'] < a:line
                                        let l:min = l:mid + 1
                                    elseif a:loclist[l:mid]['lnum'] > a:line
                                        let l:max = l:mid - 1
                                    else
                                        let l:last_column_match = l:mid
                            
                                        " Binary search to get the same column, or near it
                                        if a:loclist[l:mid]['col'] < a:column
                                            let l:min = l:mid + 1
                                        elseif a:loclist[l:mid]['col'] > a:column
                                            let l:max = l:mid - 1
                                        else
                                            return l:mid
                                        endif
                                    endif
                                endwhile

FUNCTION  xolox#misc#path#split()
Called 2 times
Total time:   0.000108
 Self time:   0.000108

count  total (s)   self (s)
                              " Split a pathname (the first and only argument) into a list of pathname
                              " components.
                              "
                              " On Windows, pathnames starting with two slashes or backslashes are UNC
                              " paths where the leading slashes are significant... In this case we split
                              " like this:
                              "
                              " - Input: `'//server/share/directory'`
                              " - Result: `['//server', 'share', 'directory']`
                              "
                              " Everything except Windows is treated like UNIX until someone has a better
                              " suggestion :-). In this case we split like this:
                              "
                              " - Input: `'/foo/bar/baz'`
                              " - Result: `['/', 'foo', 'bar', 'baz']`
                              "
                              " To join a list of pathname components back into a single pathname string,
                              " use the `xolox#misc#path#join()` function.
    2              0.000007   if type(a:path) == type('')
    2              0.000003     if s:windows_compatible
                                  if a:path =~ '^[\/][\/]'
                                    " UNC pathname.
                                    return split(a:path, '\%>2c[\/]\+')
                                  else
                                    " If it's not a UNC pathname we can simply split on slashes and
                                    " backslashes, although we should preserve a leading slash (which
                                    " denotes a pathname that is 'absolute to the current drive').
                                    let absolute = (a:path =~ '^[\/]')
                                    let segments = split(a:path, '[\/]\+')
                                    return absolute ? insert(segments, a:path[0]) : segments
                                  endif
                                else
                                  " Everything else is treated as UNIX.
    2              0.000016       let absolute = (a:path =~ '^/')
    2              0.000029       let segments = split(a:path, '/\+')
    2              0.000009       return absolute ? insert(segments, '/') : segments
                                endif
                              endif
                              return []

FUNCTION  <SNR>170_unescape_tags()
Called 2 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    2              0.000020   return substitute(a:s, '\\\([\\, ]\)', '\1', 'g')

FUNCTION  nerdtree#has_opt()
Called 9527 times
Total time:   0.031037
 Self time:   0.031037

count  total (s)   self (s)
 9527              0.028209     return has_key(a:options, a:name) && a:options[a:name] == 1

FUNCTION  <SNR>189_VimNavigate()
Called 16 times
Total time:   0.335908
 Self time:   0.001669

count  total (s)   self (s)
   16              0.000034   try
   16   0.335709   0.001470     execute 'wincmd ' . a:direction
   16              0.000032   catch
                                echohl ErrorMsg | echo 'E11: Invalid in command-line window; <CR> executes, CTRL-C quits: wincmd k' | echohl None
                              endtry

FUNCTION  UltiSnips#SnippetsInCurrentScope()
Called 4 times
Total time:   0.395468
 Self time:   0.395468

count  total (s)   self (s)
    4              0.000498     let g:current_ulti_dict = {}
    4              0.000026     let all = get(a:, 1, 0)
    4              0.000005     if all
    4              0.000188       let g:current_ulti_dict_info = {}
    4              0.000005     endif
    4              0.394718     exec g:_uspy "UltiSnips_Manager.snippets_in_current_scope(" . all . ")"
    4              0.000012     return g:current_ulti_dict

FUNCTION  <SNR>124_NameOfMark()
Called 1377 times
Total time:   0.016215
 Self time:   0.016215

count  total (s)   self (s)
 1377              0.002780 	let name = a:mark
 1377              0.005821 	if a:mark =~# '\W'
                            		let name = stridx(s:all_marks, a:mark) + 10
                            	endif
 1377              0.001682 	return name

FUNCTION  33()
Called 1156 times
Total time:   0.117049
 Self time:   0.045010

count  total (s)   self (s)
                                "filter out the user specified paths to ignore
 1156   0.004858   0.003119     if a:nerdtree.ui.isIgnoreFilterEnabled()
 2312              0.003261         for i in g:NERDTreeIgnore
 1156   0.046170   0.003848             if self._ignorePatternMatches(i)
                                            return 1
                                        endif
 1156              0.000897         endfor
                            
 1156   0.011127   0.003697         for callback in g:NERDTree.PathFilters()
                                        if {callback}({'path': self, 'nerdtree': a:nerdtree})
                                            return 1
                                        endif
                                    endfor
 1156              0.000843     endif
                            
                                "dont show hidden files unless instructed to
 1156   0.024524   0.005231     if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
  256              0.000241         return 1
                                endif
                            
  900   0.004209   0.002954     if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
                                    return 1
                                endif
                            
  900              0.000654     return 0

FUNCTION  NERDTreeGitStatusRefresh()
Called 13 times
Total time:   0.817174
 Self time:   0.019481

count  total (s)   self (s)
   13              0.000105     let b:NERDTreeCachedGitFileStatus = {}
   13              0.000057     let b:NERDTreeCachedGitDirtyDir   = {}
   13              0.000026     let b:NOT_A_GIT_REPOSITORY        = 1
                            
   13   0.001726   0.000092     let l:root = b:NERDTree.root.path.str()
   13              0.000029     let l:gitcmd = 'git -c color.status=false status -s'
   13              0.000042     if exists('g:NERDTreeGitStatusIgnoreSubmodules')
                                    let l:gitcmd = l:gitcmd . ' --ignore-submodules'
                                    if g:NERDTreeGitStatusIgnoreSubmodules ==# 'all' || g:NERDTreeGitStatusIgnoreSubmodules ==# 'dirty' || g:NERDTreeGitStatusIgnoreSubmodules ==# 'untracked'
                                        let l:gitcmd = l:gitcmd . '=' . g:NERDTreeGitStatusIgnoreSubmodules
                                    endif
                                endif
   13   0.785896   0.005500     let l:statusesStr = system(l:gitcmd . ' ' . l:root)
   13              0.000789     let l:statusesSplit = split(l:statusesStr, '\n')
   13              0.000480     if l:statusesSplit != [] && l:statusesSplit[0] =~# 'fatal:.*'
                                    let l:statusesSplit = []
                                    return
                                endif
   13              0.000088     let b:NOT_A_GIT_REPOSITORY = 0
                            
  130              0.000363     for l:statusLine in l:statusesSplit
                                    " cache git status of files
  117              0.001440         let l:pathStr = substitute(l:statusLine, '...', '', '')
  117              0.001150         let l:pathSplit = split(l:pathStr, ' -> ')
  117              0.000448         if len(l:pathSplit) == 2
                                        call s:NERDTreeCacheDirtyDir(l:pathSplit[0])
                                        let l:pathStr = l:pathSplit[1]
                                    else
  117              0.000473             let l:pathStr = l:pathSplit[0]
  117              0.000154         endif
  117   0.003613   0.001063         let l:pathStr = s:NERDTreeTrimDoubleQuotes(l:pathStr)
  117              0.000782         if l:pathStr =~# '\.\./.*'
                                        continue
                                    endif
  117   0.002950   0.001350         let l:statusKey = s:NERDTreeGetFileGitStatusKey(l:statusLine[0], l:statusLine[1])
  117              0.001474         let b:NERDTreeCachedGitFileStatus[fnameescape(l:pathStr)] = l:statusKey
                            
  117   0.012391   0.000878         call s:NERDTreeCacheDirtyDir(l:pathStr)
  117              0.000159     endfor

FUNCTION  ctrlp#utils#mkdir()
Called 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    1              0.000014 	if exists('*mkdir') && !isdirectory(a:dir)
                            		sil! cal mkdir(a:dir, 'p')
                            	en
    1              0.000002 	retu a:dir

FUNCTION  gitgutter#diff#process_modified()
Called 16 times
Total time:   0.000500
 Self time:   0.000500

count  total (s)   self (s)
   16              0.000035   let offset = 0
   36              0.000081   while offset < a:to_count
   20              0.000060     let line_number = a:to_line + offset
   20              0.000113     call add(a:modifications, [line_number, 'modified'])
   20              0.000040     let offset += 1
   20              0.000021   endwhile

FUNCTION  nerdtree#exec()
Called 28 times
Total time:   0.001468
 Self time:   0.001468

count  total (s)   self (s)
   28              0.000174     let old_ei = &ei
   28              0.000401     set ei=all
   28              0.000692     exec a:cmd
   28              0.000166     let &ei = old_ei

FUNCTION  ale#cleanup#Buffer()
Called 4 times
Total time:   0.000127
 Self time:   0.000127

count  total (s)   self (s)
    4              0.000022     if has_key(g:ale_buffer_info, a:buffer)
                                    " When buffers are removed, clear all of the jobs.
    1              0.000008         for l:job in get(g:ale_buffer_info[a:buffer], 'job_list', [])
                                        call ale#engine#ClearJob(l:job)
                                    endfor
                            
    1              0.000031         call remove(g:ale_buffer_info, a:buffer)
    1              0.000001     endif

FUNCTION  10()
Called 24 times
Total time:   0.000973
 Self time:   0.000696

count  total (s)   self (s)
   24              0.000049     let prependCWD = 0
   24   0.000353   0.000076     if nerdtree#runningWindows()
                                    let prependCWD = a:str !~# '^.:\(\\\|\/\)' && a:str !~# '^\(\\\\\|\/\/\)'
                                else
   24              0.000226         let prependCWD = a:str !~# '^/'
   24              0.000017     endif
                            
   24              0.000040     let toReturn = a:str
   24              0.000025     if prependCWD
                                    let toReturn = getcwd() . s:Path.Slash() . a:str
                                endif
                            
   24              0.000027     return toReturn

FUNCTION  <SNR>168_report_results()
Called 1 time
Total time:   0.000108
 Self time:   0.000060

count  total (s)   self (s)
    1   0.000027   0.000005   if !xolox#misc#option#get('easytags_suppress_report', 0)
    1              0.000002     let actions = []
    1              0.000002     if a:response['num_updated'] > 0
    1              0.000007       call add(actions, printf('updated %i tags', a:response['num_updated']))
    1              0.000001     endif
    1              0.000002     if a:response['num_filtered'] > 0
                                  call add(actions, printf('filtered %i invalid tags', a:response['num_filtered']))
                                endif
    1              0.000002     if !empty(actions)
    1              0.000003       let function = a:async ? 'xolox#misc#msg#debug' : 'xolox#misc#msg#info'
    1   0.000026   0.000013       let actions_string = xolox#misc#str#ucfirst(join(actions, ' and '))
    1              0.000002       let command_type = a:async ? 'asynchronously' : 'synchronously'
    1   0.000025   0.000012       call call(function, ["easytags.vim %s: %s in %s (%s).", g:xolox#easytags#version, actions_string, a:response['elapsed_time'], command_type])
    1              0.000001     endif
    1              0.000001   endif

FUNCTION  <SNR>272_AltFiletype()
Called 1 time
Total time:   0.000159
 Self time:   0.000055

count  total (s)   self (s)
    1   0.000115   0.000011     let filetype = empty(a:filetype) ? s:GetFiletype(&filetype, [-1]) : a:filetype
    1              0.000003     Tlibtrace 'tcomment', a:filetype, filetype
    1              0.000014     if g:tcommentGuessFileType || (exists('g:tcommentGuessFileType_'. filetype)  && g:tcommentGuessFileType_{filetype} =~ '[^0]')
    1              0.000003         if g:tcommentGuessFileType_{filetype} == 1
    1              0.000007             if filetype =~ '^.\{-}\..\+$'
                                            let alt_filetype = s:GetFiletype(filetype)
                                        else
    1              0.000002                 let alt_filetype = ''
    1              0.000001             endif
    1              0.000001         else
                                        let alt_filetype = g:tcommentGuessFileType_{filetype}
                                    endif
    1              0.000003         Tlibtrace 'tcomment', 1, alt_filetype
    1              0.000003         return [1, alt_filetype]
                                elseif filetype =~ '^.\{-}\..\+$'
                                    " Unfortunately the handling of "sub-filetypes" isn't 
                                    " consistent. Some use MAJOR.MINOR, others use MINOR.MAJOR.
                                    let alt_filetype = s:GetFiletype(filetype)
                                    " if alt_filetype == filetype
                                    "     let alt_filetype = s:GetFiletype(filetype, 1)
                                    "     if alt_filetype == a:filetype
                                    "         let alt_filetype = s:GetFiletype(filetype, 0)
                                    "     endif
                                    " endif
                                    Tlibtrace 'tcomment', 2, alt_filetype
                                    return [1, alt_filetype]
                                else
                                    Tlibtrace 'tcomment', 3, ''
                                    return [0, '']
                                endif

FUNCTION  indent_guides#init_matches()
Called 14 times
Total time:   0.000224
 Self time:   0.000224

count  total (s)   self (s)
   14              0.000107   let w:indent_guides_matches = exists('w:indent_guides_matches') ? w:indent_guides_matches : []

FUNCTION  xolox#easytags#filetypes#canonicalize()
Called 9 times
Total time:   0.060554
 Self time:   0.000319

count  total (s)   self (s)
                              " Select a canonical, supported Vim file type given a value of &filetype.
    9   0.060310   0.000075   call s:discover_supported_filetypes()
                              " Split the possibly combined Vim file type into individual file types.
    9              0.000086   for filetype in split(tolower(a:vim_filetype_value), '\.')
                                " Canonicalize the Vim file type.
    9              0.000049     let filetype = get(s:canonical_filetypes, filetype, filetype)
    9              0.000046     if index(s:supported_filetypes, filetype) >= 0
    9              0.000015       return filetype
                                endif
                              endfor
                              return ''

FUNCTION  <SNR>163_chop()
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000013 	if len(a:mrufs) > {s:max} | cal remove(a:mrufs, {s:max}, -1) | en
    1              0.000002 	retu a:mrufs

FUNCTION  <SNR>163_record()
Called 4 times
Total time:   0.000779
 Self time:   0.000161

count  total (s)   self (s)
    4              0.000016 	if s:locked | retu | en
    4              0.000015 	let bufnr = a:bufnr + 0
    4              0.000015 	let bufname = bufname(bufnr)
    4              0.000013 	if bufnr > 0 && !empty(bufname)
    4              0.000041 		cal filter(s:mrbs, 'v:val != bufnr')
    4              0.000013 		cal insert(s:mrbs, bufnr)
    4   0.000651   0.000033 		cal s:addtomrufs(bufname)
    4              0.000004 	en

FUNCTION  gitgutter#utility#full_path_to_directory_of_file()
Called 37 times
Total time:   0.001320
 Self time:   0.001320

count  total (s)   self (s)
   37              0.001291   return fnamemodify(s:file, ':p:h')

FUNCTION  <SNR>192_YRWinLeave()
Called 7 times
Total time:   0.000062
 Self time:   0.000062

count  total (s)   self (s)
                                " Track which window we are last in.  We will use this information
                                " to determine where we need to paste any contents, or which
                                " buffer to return to.
                            
    7              0.000022     if s:yr_buffer_id < 0
                                    " The yankring window has never been activated
    7              0.000010         return
                                endif
                            
                                if winbufnr(winnr()) == s:yr_buffer_id
                                    " Ignore leaving the yankring window
                                    return
                                endif
                            
                                if bufwinnr(s:yr_buffer_id) != -1
                                    " YankRing window is visible, so save off the previous buffer ids
                                    let s:yr_buffer_last_winnr = winnr()
                                    let s:yr_buffer_last       = winbufnr(s:yr_buffer_last_winnr)
                                " else
                                "     let s:yr_buffer_last_winnr = -1
                                "     let s:yr_buffer_last       = -1
                                endif

FUNCTION  gitgutter#diff#process_hunk()
Called 16 times
Total time:   0.002533
 Self time:   0.001321

count  total (s)   self (s)
   16              0.000036   let modifications = []
   16              0.000042   let from_line  = a:hunk[0]
   16              0.000056   let from_count = a:hunk[1]
   16              0.000034   let to_line    = a:hunk[2]
   16              0.000033   let to_count   = a:hunk[3]
                            
   16   0.000139   0.000095   if gitgutter#diff#is_added(from_count, to_count)
                                call gitgutter#diff#process_added(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_added(to_count)
                            
                              elseif gitgutter#diff#is_removed(from_count, to_count)
                                call gitgutter#diff#process_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_removed(from_count)
                            
                              elseif gitgutter#diff#is_modified(from_count, to_count)
   16   0.000609   0.000109     call gitgutter#diff#process_modified(modifications, from_count, to_count, to_line)
   16   0.000680   0.000104     call gitgutter#hunk#increment_lines_modified(to_count)
                            
   16              0.000045   elseif gitgutter#diff#is_modified_and_added(from_count, to_count)
                                call gitgutter#diff#process_modified_and_added(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_added(to_count - from_count)
                                call gitgutter#hunk#increment_lines_modified(from_count)
                            
                              elseif gitgutter#diff#is_modified_and_removed(from_count, to_count)
                                call gitgutter#diff#process_modified_and_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(to_count)
                                call gitgutter#hunk#increment_lines_removed(from_count - to_count)
                            
                              endif
   16              0.000022   return modifications

FUNCTION  nerdtree#renderView()
Called 24 times
Total time:   0.183268
 Self time:   0.000164

count  total (s)   self (s)
   24   0.183253   0.000149     call b:NERDTree.render()

FUNCTION  <SNR>272_GuessFileType()
Called 1 time
Total time:   0.001980
 Self time:   0.001073

count  total (s)   self (s)
                                " TLogVAR a:beg, a:end, a:comment_mode, a:filetype, a:000
    1   0.000233   0.000013     let cdef0 = s:GuessCustomCommentString(a:filetype, a:comment_mode)
    1              0.000002     if a:0 >= 1 && a:1 != ''
                                    let cdef = s:GuessCustomCommentString(a:1, a:comment_mode)
                                    " TLogVAR 0, cdef
                                    let cdef = extend(cdef, cdef0, 'keep')
                                    " TLogVAR 1, cdef
                                    if empty(get(cdef, 'commentstring', ''))
                                        let guess_cdef = s:GuessVimOptionsCommentString(a:comment_mode)
                                        call extend(cdef, guess_cdef)
                                    endif
                                    " TLogVAR 2, cdef
                                else
    1              0.000002         let cdef = cdef0
                                    " TLogVAR 3, cdef
    1              0.000003         if !has_key(cdef, 'commentstring')
                                        let cdef = s:GuessVimOptionsCommentString(a:comment_mode)
                                    endif
                                    " TLogVAR 4, cdef
    1              0.000000     endif
    1              0.000001     let beg = a:beg
    1              0.000002     let end = nextnonblank(a:end)
    1              0.000001     if end == 0
                                    let end = a:end
                                    let beg = prevnonblank(a:beg)
                                    if beg == 0
                                        let beg = a:beg
                                    endif
                                endif
    1              0.000001     let n  = beg
                                " TLogVAR n, beg, end
    1              0.000002     while n <= end
    1              0.000002         let text = getline(n)
    1              0.000007         let indentstring = matchstr(text, '^\s*')
    1              0.000003         let m = strwidth(indentstring)
                                    " let m  = indent(n) + 1
    1              0.000003         let le = strwidth(text)
                                    " TLogVAR n, m, le
    2              0.000002         while m <= le
    2   0.000495   0.000016             let syntax_name = s:GetSyntaxName(n, m)
                                        " TLogVAR syntax_name, n, m
    2              0.000004             unlet! ftype_map
    2              0.000009             let ftype_map = get(g:tcommentSyntaxMap, syntax_name, '')
                                        " TLogVAR ftype_map
    2              0.000008             if !empty(ftype_map) && type(ftype_map) == 4
                                            if n < a:beg
                                                let key = 'prevnonblank'
                                            elseif n > a:end
                                                let key = 'nextnonblank'
                                            else
                                                let key = ''
                                            endif
                                            if empty(key) || !has_key(ftype_map, key)
                                                let ftypeftype = get(ftype_map, 'filetype', {})
                                                " TLogVAR ftype_map, ftypeftype
                                                unlet! ftype_map
                                                let ftype_map = get(ftypeftype, a:filetype, '')
                                            else
                                                let mapft = ''
                                                for mapdef in ftype_map[key]
                                                    if strpart(text, m - 1) =~ '^'. mapdef.match
                                                        let mapft = mapdef.filetype
                                                        break
                                                    endif
                                                endfor
                                                unlet! ftype_map
                                                if empty(mapft)
                                                    let ftype_map = ''
                                                else
                                                    let ftype_map = mapft
                                                endif
                                            endif
                                        endif
    2              0.000003             if !empty(ftype_map)
                                            " TLogVAR ftype_map
                                            return s:GuessCustomCommentString(ftype_map, a:comment_mode, cdef.commentstring)
                                        elseif syntax_name =~ s:types_rx
    1              0.000171                 let ft = substitute(syntax_name, s:types_rx, '\1', '')
                                            " TLogVAR ft
    1              0.000006                 if exists('g:tcommentIgnoreTypes_'. a:filetype) && g:tcommentIgnoreTypes_{a:filetype} =~ '\<'.ft.'\>'
                                                let m += 1
                                            else
    1   0.000218   0.000010                     return s:GuessCustomCommentString(ft, a:comment_mode, cdef.commentstring)
                                            endif
                                        elseif syntax_name == '' || syntax_name == 'None' || syntax_name =~ '^\u\+$' || syntax_name =~ '^\u\U*$'
    1              0.000002                 let m += 1
    1              0.000001             else
                                            break
                                        endif
    1              0.000001         endwh
                                    let n += 1
                                endwh
                                " TLogVAR cdef
                                return cdef

FUNCTION  AutoPairsTryInit()
Called 7 times
Total time:   0.000068
 Self time:   0.000068

count  total (s)   self (s)
    7              0.000034   if exists('b:autopairs_loaded')
    7              0.000008     return
                              end
                            
                              " for auto-pairs starts with 'a', so the priority is higher than supertab and vim-endwise
                              "
                              " vim-endwise doesn't support <Plug>AutoPairsReturn
                              " when use <Plug>AutoPairsReturn will cause <Plug> isn't expanded
                              "
                              " supertab doesn't support <SID>AutoPairsReturn
                              " when use <SID>AutoPairsReturn  will cause Duplicated <CR>
                              "
                              " and when load after vim-endwise will cause unexpected endwise inserted. 
                              " so always load AutoPairs at last
                              
                              " Buffer level keys mapping
                              " comptible with other plugin
                              if g:AutoPairsMapCR
                                if v:version >= 703 && has('patch32')
                                  " VIM 7.3 supports advancer maparg which could get <expr> info
                                  " then auto-pairs could remap <CR> in any case.
                                  let info = maparg('<CR>', 'i', 0, 1)
                                  if empty(info)
                                    let old_cr = '<CR>'
                                    let is_expr = 0
                                  else
                                    let old_cr = info['rhs']
                                    let old_cr = s:ExpandMap(old_cr)
                                    let old_cr = substitute(old_cr, '<SID>', '<SNR>' . info['sid'] . '_', 'g')
                                    let is_expr = info['expr']
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper73'
                                  endif
                                else
                                  " VIM version less than 7.3
                                  " the mapping's <expr> info is lost, so guess it is expr or not, it's
                                  " not accurate.
                                  let old_cr = maparg('<CR>', 'i')
                                  if old_cr == ''
                                    let old_cr = '<CR>'
                                    let is_expr = 0
                                  else
                                    let old_cr = s:ExpandMap(old_cr)
                                    " old_cr contain (, I guess the old cr is in expr mode
                                    let is_expr = old_cr  =~ '\V(' && toupper(old_cr) !~ '\V<C-R>'
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper'
                                  end
                                end
                            
                                if old_cr !~ 'AutoPairsReturn'
                                  if is_expr
                                    " remap <expr> to `name` to avoid mix expr and non-expr mode
                                    execute 'inoremap <buffer> <expr> <script> '. wrapper_name . ' ' . old_cr
                                    let old_cr = wrapper_name
                                  end
                                  " Always silent mapping
                                  execute 'inoremap <script> <buffer> <silent> <CR> '.old_cr.'<SID>AutoPairsReturn'
                                end
                              endif
                              call AutoPairsInit()

FUNCTION  ZoomWin#CleanupSessionFile()
Called 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
                            "  call Dfunc("ZoomWin#CleanupSessionFile()")
    1              0.000010   if exists("s:sessionfile") && filereadable(s:sessionfile)
                            "   call Decho("sessionfile exists and is readable; deleting it")
                               sil! call delete(s:sessionfile)
                               unlet s:sessionfile
                              endif
                            "  call Dret("ZoomWin#CleanupSessionFile")

FUNCTION  ctrlp#utils#readfile()
Called 1 time
Total time:   0.013749
 Self time:   0.013749

count  total (s)   self (s)
    1              0.013687 	if filereadable(a:file)
    1              0.000039 		let data = readfile(a:file)
    1              0.000007 		if empty(data) || type(data) != 3
    1              0.000003 			unl data
    1              0.000003 			let data = []
    1              0.000001 		en
    1              0.000002 		retu data
                            	en
                            	retu []

FUNCTION  ale#Lint()
Called 4 times
Total time:   0.002183
 Self time:   0.001053

count  total (s)   self (s)
                                " Do nothing for blacklisted files.
    4              0.000135     if index(g:ale_filetype_blacklist, &filetype) >= 0
                                    return
                                endif
                            
    4              0.000055     let l:buffer = bufnr('%')
    4   0.001102   0.000059     let l:linters = ale#linter#Get(&filetype)
                            
                                " Initialise the buffer information if needed.
    4   0.000144   0.000057     call ale#engine#InitBufferInfo(l:buffer)
                            
                                " Clear the new loclist again, so we will work with all new items.
    4              0.000028     let g:ale_buffer_info[l:buffer].new_loclist = []
                            
    8              0.000021     for l:linter in l:linters
                                    " Check if a given linter has a program which can be executed.
    4              0.000018         if has_key(l:linter, 'executable_callback')
                                        let l:executable = ale#util#GetFunction(l:linter.executable_callback)(l:buffer)
                                    else
    4              0.000017             let l:executable = l:linter.executable
    4              0.000004         endif
                            
    4              0.000380         if !executable(l:executable)
                                        " The linter's program cannot be executed, so skip it.
    4              0.000018             continue
                                    endif
                            
                                    call ale#engine#Invoke(l:buffer, l:linter)
                                endfor

FUNCTION  gitgutter#hunk#summary()
Called 16 times
Total time:   0.000237
 Self time:   0.000237

count  total (s)   self (s)
   16              0.000231   return get(getbufvar(a:bufnr,''), 'gitgutter_summary', [0,0,0])

FUNCTION  indent_guides#disable()
Called 14 times
Total time:   0.001069
 Self time:   0.000164

count  total (s)   self (s)
   14              0.000050   let g:indent_guides_autocmds_enabled = 0
   14   0.000986   0.000081   call indent_guides#clear_matches()

FUNCTION  <SNR>158_NERDTreeTrimDoubleQuotes()
Called 234 times
Total time:   0.004867
 Self time:   0.004867

count  total (s)   self (s)
  234              0.002185     let l:toReturn = substitute(a:pathStr, '^"', '', '')
  234              0.001851     let l:toReturn = substitute(l:toReturn, '"$', '', '')
  234              0.000518     return l:toReturn

FUNCTION  272()
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000003     if s:has_reltime
    1              0.000004       let self.current = reltime()
    1              0.000001     else
                                  let self.current = localtime()
                                endif

FUNCTION  <SNR>168_highlight_with_python()
Called 4 times
Total time:   0.023779
 Self time:   0.020165

count  total (s)   self (s)
    4   0.002853   0.000059   if xolox#misc#option#get('easytags_python_enabled', 1) && s:python_available()
                                " Gather arguments for Python function.
    4              0.000008     let context = {}
    4              0.001056     let context['tagsfiles'] = tagfiles()
    4              0.000016     let context['syntaxgroup'] = a:syntax_group
                                " TODO This doesn't support file type groups!
    4   0.000407   0.000054     let context['filetype'] = xolox#easytags#filetypes#to_ctags(xolox#easytags#filetypes#canonicalize(&filetype))
    4              0.000018     let context['tagkinds'] = get(a:tagkind, 'tagkinds', '')
    4              0.000016     let context['prefix'] = get(a:tagkind, 'pattern_prefix', '')
    4              0.000014     let context['suffix'] = get(a:tagkind, 'pattern_suffix', '')
    4              0.000015     let context['filters'] = get(a:tagkind, 'python_filter', {})
    4   0.000500   0.000033     let context['ignoresyntax'] = xolox#easytags#syntax_groups_to_ignore()
                                " Call the Python function and intercept the output.
    4              0.000005     try
    4              0.000013       redir => commands
    4              0.000130       python import vim
    4              0.007057       silent python print easytags_gensyncmd(**vim.eval('context'))
    4              0.000036       redir END
    4              0.011574       execute commands
    4              0.000010       return 1
                                catch
                                  redir END
                                  " If the Python script raised an error, don't run it again.
                                  let g:easytags_python_enabled = 0
                                endtry
                              endif
                              return 0

FUNCTION  <SNR>247_VisitedBufferRequiresReparse()
Called 7 times
Total time:   0.001062
 Self time:   0.000105

count  total (s)   self (s)
    7   0.000988   0.000031   if !s:AllowedToCompleteInCurrentBuffer()
    2              0.000002     return 0
                              endif
                            
    5              0.000019   if bufnr( '' ) ==# s:previous_allowed_buffer_number
    1              0.000001     return 0
                              endif
    4              0.000018   let s:previous_allowed_buffer_number = bufnr( '' )
    4              0.000005   return 1

FUNCTION  xolox#misc#path#is_relative()
Called 2 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
                              " Returns true (1) when the pathname given as the first argument is
                              " relative, false (0) otherwise.
    2              0.000011   if a:path =~ '^\w\+://'
                                return 0
                              elseif s:windows_compatible
                                return a:path !~ '^\(\w:\|[\\/]\)'
                              else
    2              0.000007     return a:path !~ '^/'
                              endif

FUNCTION  xolox#misc#option#eval_tags()
Called 1 time
Total time:   0.000253
 Self time:   0.000142

count  total (s)   self (s)
                              " Evaluate Vim's ['tags' option] [tags] without looking at the file
                              " system, i.e. this will report tags files that don't exist yet. Expects
                              " the value of the ['tags' option] [tags] as the first argument. If the
                              " optional second argument is 1 (true) only the first match is returned,
                              " otherwise (so by default) a list with all matches is returned.
    1              0.000002   let pathnames = []
    1              0.000003   let first_only = exists('a:1') ? a:1 : 0
    1   0.000071   0.000011   for pattern in xolox#misc#option#split_tags(a:value)
                                " Make buffer relative pathnames absolute.
    1              0.000003     if pattern =~ '^\./'
                                  let suffix = matchstr(pattern, '^./\zs.*$')
                                  let directory = (&cpoptions =~# 'd') ? getcwd() : expand('%:p:h')
                                  let pattern = xolox#misc#path#merge(directory, suffix)
                                endif
                                " Make working directory relative pathnames absolute.
    1   0.000024   0.000007     if xolox#misc#path#is_relative(pattern)
    1   0.000061   0.000027       let pattern = xolox#misc#path#merge(getcwd(), pattern)
    1              0.000001     endif
                                " Ignore the trailing `;' for recursive upwards searching because we
                                " always want the most specific pathname available.
    1              0.000006     let pattern = substitute(pattern, ';$', '', '')
                                " Expand the pattern.
    1              0.000054     call extend(pathnames, split(expand(pattern), "\n"))
    1              0.000004     if first_only && !empty(pathnames)
    1              0.000004       return pathnames[0]
                                endif
                              endfor
                              return first_only ? '' : pathnames

FUNCTION  gitgutter#utility#bufnr()
Called 95 times
Total time:   0.000418
 Self time:   0.000418

count  total (s)   self (s)
   95              0.000207   return s:bufnr

FUNCTION  xolox#misc#str#ucfirst()
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
                              " Uppercase the first character in a string (the first argument).
    1              0.000012   return substitute(a:s, '^.', '\U\0', '')

FUNCTION  <SNR>163_mergelists()
Called 1 time
Total time:   0.013859
 Self time:   0.000065

count  total (s)   self (s)
    1   0.013806   0.000028 	let diskmrufs = ctrlp#utils#readfile(ctrlp#mrufiles#cachefile())
    1              0.000008 	cal filter(diskmrufs, 'index(s:mrufs, v:val) < 0')
    1              0.000004 	let mrufs = s:mrufs + diskmrufs
    1   0.000038   0.000022 	retu s:chop(mrufs)

FUNCTION  <SNR>272_GetSyntaxName()
Called 2 times
Total time:   0.000479
 Self time:   0.000479

count  total (s)   self (s)
    2              0.000373     let syntax_name = synIDattr(synID(a:lnum, a:col, 1), 'name')
    2              0.000006     if !empty(g:tcomment#syntax_substitute)
    6              0.000020         for [rx, subdef] in items(g:tcomment#syntax_substitute)
    4              0.000014             if !has_key(subdef, 'if') || eval(subdef.if)
    4              0.000034                 let syntax_name = substitute(syntax_name, rx, subdef.sub, 'g')
    4              0.000004             endif
    4              0.000003         endfor
    2              0.000001     endif
                                " TLogVAR syntax_name
    2              0.000004     return syntax_name

FUNCTION  211()
Called 97 times
Total time:   0.001784
 Self time:   0.001103

count  total (s)   self (s)
   97   0.001060   0.000379     let flags = self._flagsForScope(a:scope)
   97              0.000274     if index(flags, a:flag) == -1
   97              0.000304         call add(flags, a:flag)
   97              0.000078     end

FUNCTION  213()
Called 97 times
Total time:   0.000681
 Self time:   0.000681

count  total (s)   self (s)
   97              0.000261     if !has_key(self._flags, a:scope)
                                    let self._flags[a:scope] = []
                                endif
   97              0.000174     return self._flags[a:scope]

FUNCTION  214()
Called 24 times
Total time:   0.000194
 Self time:   0.000194

count  total (s)   self (s)
   24              0.000106     let newObj = copy(self)
   24              0.000049     let newObj._flags = {}
   24              0.000024     return newObj

FUNCTION  216()
Called 450 times
Total time:   0.007461
 Self time:   0.007461

count  total (s)   self (s)
  450              0.000597     let flagstring = ""
  900              0.001691     for i in values(self._flags)
  450              0.001376         let flagstring .= join(i)
  450              0.000349     endfor
                            
  450              0.000850     if len(flagstring) == 0
  350              0.000301         return ""
                                endif
                            
  100              0.000197     return '[' . flagstring . ']'

FUNCTION  gitgutter#utility#stringify()
Called 7 times
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
    7              0.000039   return join(a:list, "\n")."\n"

FUNCTION  xolox#easytags#syntax_groups_to_ignore()
Called 4 times
Total time:   0.000467
 Self time:   0.000467

count  total (s)   self (s)
                              " Get a string matching the syntax groups where dynamic highlighting should
                              " *not* apply. This is complicated by the fact that Vim has a tendency to do
                              " this:
                              "
                              "     Vim(syntax):E409: Unknown group name: doxygen.*
                              "
                              " This happens when a group wildcard doesn't match *anything*. Why does Vim
                              " always have to make everything so complicated? :-(
    4              0.000012   let groups = ['.*String.*', '.*Comment.*']
   28              0.000052   for group_name in ['cIncluded', 'cCppOut2', 'cCppInElse2', 'cCppOutIf2', 'pythonDocTest', 'pythonDocTest2']
   24              0.000204     if hlexists(group_name)
    4              0.000014       call add(groups, group_name)
    4              0.000003     endif
   24              0.000018   endfor
                              " Doxygen is an "add-on syntax script", it's usually used in combination:
                              "   :set syntax=c.doxygen
                              " It gets special treatment because it defines a dozen or so groups :-)
    4              0.000032   if hlexists('doxygenComment')
                                call add(groups, 'doxygen.*')
                              endif
    4              0.000019   return join(groups, ',')

FUNCTION  gitgutter#diff#run_diff()
Called 8 times
Total time:   0.030359
 Self time:   0.012867

count  total (s)   self (s)
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
    8              0.000020   let cmd = '('
                            
    8   0.000062   0.000040   let bufnr = gitgutter#utility#bufnr()
    8              0.000038   let tracked = getbufvar(bufnr, 'gitgutter_tracked')  " i.e. tracked by git
    8              0.000011   if !tracked
                                " Don't bother trying to realtime-diff an untracked file.
                                " NOTE: perhaps we should pull this guard up to the caller?
                                if a:realtime
                                  throw 'diff failed'
                                else
                                  let cmd .= g:gitgutter_git_executable.' ls-files --error-unmatch '.gitgutter#utility#shellescape(gitgutter#utility#filename()).' && ('
                                endif
                              endif
                            
    8              0.000010   if a:realtime
    6   0.000386   0.000089     let blob_name = g:gitgutter_diff_base.':'.gitgutter#utility#shellescape(gitgutter#utility#file_relative_to_repo_root())
    6              0.000017     let blob_file = s:temp_index
    6              0.000016     let buff_file = s:temp_buffer
    6   0.000070   0.000038     let extension = gitgutter#utility#extension()
    6              0.000018     if !empty(extension)
                                  let blob_file .= '.'.extension
                                  let buff_file .= '.'.extension
                                endif
    6              0.000052     let cmd .= g:gitgutter_git_executable.' show '.blob_name.' > '.blob_file.' && '
                            
                                " Writing the whole buffer resets the '[ and '] marks and also the
                                " 'modified' flag (if &cpoptions includes '+').  These are unwanted
                                " side-effects so we save and restore the values ourselves.
    6              0.000045     let modified      = getbufvar(bufnr, "&mod")
    6              0.000034     let op_mark_start = getpos("'[")
    6              0.000025     let op_mark_end   = getpos("']")
                            
    6              0.010146     execute 'keepalt noautocmd silent write!' buff_file
                            
    6              0.000140     call setbufvar(bufnr, "&mod", modified)
    6              0.000031     call setpos("'[", op_mark_start)
    6              0.000020     call setpos("']", op_mark_end)
    6              0.000012   endif
                            
    8              0.000049   let cmd .= g:gitgutter_git_executable
    8              0.000019   if s:c_flag
    8              0.000028     let cmd .= ' -c "diff.autorefreshindex=0"'
    8              0.000008   endif
    8              0.000042   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' '
                            
    8              0.000012   if a:realtime
    6              0.000036     let cmd .= ' -- '.blob_file.' '.buff_file
    6              0.000005   else
    2   0.000057   0.000024     let cmd .= g:gitgutter_diff_base.' -- '.gitgutter#utility#shellescape(gitgutter#utility#filename())
    2              0.000002   endif
                            
    8              0.000026   if !a:preserve_full_diff && s:grep_available
    8   0.000616   0.000099     let cmd .= ' | '.s:grep_command.' '.gitgutter#utility#shellescape('^@@ ')
    8              0.000009   endif
                            
    8              0.000023   if (!a:preserve_full_diff && s:grep_available) || a:realtime
                                " grep exits with 1 when no matches are found; diff exits with 1 when
                                " differences are found.  However we want to treat non-matches and
                                " differences as non-erroneous behaviour; so we OR the command with one
                                " which always exits with success (0).
    8              0.000023     let cmd .= ' || exit 0'
    8              0.000005   endif
                            
    8              0.000017   let cmd .= ')'
                            
    8              0.000010   if !tracked
                                let cmd .= ')'
                              endif
                            
    8   0.000296   0.000062   let cmd = gitgutter#utility#command_in_directory_of_file(cmd)
                            
    8   0.000073   0.000055   if g:gitgutter_async && gitgutter#async#available() && !a:preserve_full_diff
    8   0.017140   0.000801     call gitgutter#async#execute(cmd)
    8              0.000092     return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if gitgutter#utility#shell_error()
                                  " A shell error indicates the file is not tracked by git (unless something bizarre is going on).
                                  throw 'diff failed'
                                endif
                            
                                return diff
                              endif

FUNCTION  <SNR>272_ProcessLine()
Called 3 times
Total time:   0.000491
 Self time:   0.000354

count  total (s)   self (s)
                                " TLogVAR a:comment_do, a:match, a:checkRx, a:replace
    3              0.000003     try
    3              0.000008         if !(g:tcomment#blank_lines > 0 || a:match =~ '\S')
                                        return [a:match, 0]
                                    endif
    3              0.000006         if a:comment_do ==# 'k'
                                        if a:match =~ a:checkRx
                                            return ['', 0]
                                        endif
                                    endif
    3              0.000004         if a:comment_do ==# 'u'
                                        let m = matchlist(a:match, a:checkRx)
                                        if !empty(m)
                                            for irx in range(2, s:Count(a:checkRx, '\\\@<!\\('))
                                                if !empty(m[irx])
                                                    break
                                                endif
                                            endfor
                                            " TLogVAR irx
                                        else
                                            let irx = 2
                                        endif
                                        let rv = substitute(a:match, a:checkRx, '\1\'. irx, '')
                                        let rv = s:UnreplaceInLine(rv)
                                    else
    3              0.000009             let ml = len(a:match)
    3   0.000051   0.000018             let rv = s:ReplaceInLine(a:match)
    3   0.000121   0.000017             let rv = s:Printf1(a:replace, rv)
    3              0.000011             let strip_whitespace = get(s:cdef, 'strip_whitespace', 1)
    3              0.000008             if strip_whitespace == 2 || (strip_whitespace == 1 && ml == 0)
                                            let rv = substitute(rv, '\s\+$', '', '')
                                        endif
    3              0.000003         endif
                                    " TLogVAR rv
                                    " echom "DBG s:cdef.mode=" string(s:cdef.mode) "s:cursor_pos=" string(s:cursor_pos)
    3              0.000012         if s:cdef.mode =~ '>'
                                        let s:cursor_pos = getpos('.')
                                        let s:cursor_pos[2] += len(rv)
                                    elseif s:cdef.mode =~ '#'
                                        if empty(s:cursor_pos) || s:current_pos[1] == s:processline_lnum
                                            let prefix = matchstr(a:replace, '^.*%\@<!\ze%s')
                                            let prefix = substitute(prefix, '%\(.\)', '\1', 'g')
                                            let prefix_len = s:Strdisplaywidth(prefix)
                                            " TLogVAR a:replace, prefix_len
                                            if prefix_len != -1
                                                let s:cursor_pos = copy(s:current_pos)
                                                if a:comment_do ==# 'u'
                                                    let s:cursor_pos[2] -= prefix_len
                                                    if s:cursor_pos[2] < 1
                                                        let s:cursor_pos[2] = 1
                                                    endif
                                                else
                                                    let s:cursor_pos[2] += prefix_len
                                                endif
                                                " echom "DBG s:current_pos=" string(s:current_pos) "s:cursor_pos=" string(s:cursor_pos)
                                            endif
                                        endif
                                    endif
                                    " TLogVAR rv
    3              0.000005         if g:tcomment#must_escape_expression_backslash
                                        let rv = escape(rv, "\\r")
                                    else
    3              0.000012             let rv = escape(rv, "\r")
    3              0.000002         endif
                                    " TLogVAR rv
                                    " let rv = substitute(rv, '\n', '\\\n', 'g')
                                    " TLogVAR rv
    3              0.000005         return [rv, 1]
                                finally
    3              0.000006         let s:processline_lnum += 1
    3              0.000003     endtry

FUNCTION  222()
Called 26 times
Total time:   0.004184
 Self time:   0.000617

count  total (s)   self (s)
   26   0.001554   0.000240     call g:NERDTree.MustBeOpen()
   26   0.002527   0.000274     call nerdtree#exec(g:NERDTree.GetWinNum() . "wincmd w")

FUNCTION  223()
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000007     return exists("b:NERDTree")

FUNCTION  228()
Called 84 times
Total time:   0.003220
 Self time:   0.003220

count  total (s)   self (s)
   84              0.000360     if exists("t:NERDTreeBufName")
   84              0.002797         return bufwinnr(t:NERDTreeBufName)
                                endif
                            
                                return -1

FUNCTION  229()
Called 58 times
Total time:   0.002724
 Self time:   0.000335

count  total (s)   self (s)
   58   0.002703   0.000314     return s:NERDTree.GetWinNum() != -1

FUNCTION  xolox#easytags#filetypes#to_ctags()
Called 5 times
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
                              " Translate a Vim file type to an Exuberant Ctags language.
    5              0.000020   let vim_filetype = tolower(a:vim_filetype)
    5              0.000020   return get(g:xolox#easytags#filetypes#vim_to_ctags, vim_filetype, vim_filetype)

FUNCTION  MyFilename()
Called 2420 times
Total time:   0.047695
 Self time:   0.030857

count  total (s)   self (s)
 2420   0.045952   0.029114   return ('' != MyReadonly() ? MyReadonly() . ' ' : '') . ('' != expand('%') ? expand('%') : '[NoName]')

FUNCTION  xolox#misc#msg#debug()
Called 75 times
Total time:   0.000861
 Self time:   0.000861

count  total (s)   self (s)
                              " Show a formatted debugging message to the user, *if the user has enabled
                              " increased verbosity by setting Vim's ['verbose'] [] option to one
                              " (1) or higher*.
                              "
                              " This function has the same argument handling as the
                              " `xolox#misc#msg#info()` function.
                              "
                              " In the case of `xolox#misc#msg#debug()`, automatic string coercion
                              " provides lazy evaluation in the sense that complex data structures are
                              " only converted to strings when the user has enabled increased verbosity.
                              "
                              " ['verbose']: http://vimdoc.sourceforge.net/htmldoc/options.html#'verbose'
   75              0.000171   if &vbs >= 1
                                call s:show_message('Question', a:000)
                              endif

FUNCTION  232()
Called 26 times
Total time:   0.001314
 Self time:   0.000273

count  total (s)   self (s)
   26   0.001134   0.000093     if !s:NERDTree.IsOpen()
                                    throw "NERDTree.TreeNotOpen"
                                endif

FUNCTION  234()
Called 1156 times
Total time:   0.007430
 Self time:   0.007430

count  total (s)   self (s)
 1156              0.003236     if !exists('s:NERDTree._PathFilters')
                                    let s:NERDTree._PathFilters = []
                                endif
 1156              0.001447     return s:NERDTree._PathFilters

FUNCTION  237()
Called 25 times
Total time:   0.190590
 Self time:   0.000167

count  total (s)   self (s)
   25   0.190580   0.000157     call self.ui.render()

FUNCTION  239()
Called 25 times
Total time:   0.003377
 Self time:   0.003279

count  total (s)   self (s)
   25              0.000063     let old_h = @h
   25   0.000161   0.000116     if self.getShowHelp()
                                    let @h=   "\" NERD tree (" . nerdtree#version() . ") quickhelp~\n"
                                    let @h=@h."\" ============================\n"
                                    let @h=@h."\" File node mappings~\n"
                                    let @h=@h."\" ". (g:NERDTreeMouseMode ==# 3 ? "single" : "double") ."-click,\n"
                                    let @h=@h."\" <CR>,\n"
                                    if self.nerdtree.isTabTree()
                                        let @h=@h."\" ". g:NERDTreeMapActivateNode .": open in prev window\n"
                                    else
                                        let @h=@h."\" ". g:NERDTreeMapActivateNode .": open in current window\n"
                                    endif
                                    if self.nerdtree.isTabTree()
                                        let @h=@h."\" ". g:NERDTreeMapPreview .": preview\n"
                                    endif
                                    let @h=@h."\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let @h=@h."\" middle-click,\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenSplit .": open split\n"
                                    let @h=@h."\" ". g:NERDTreeMapPreviewSplit .": preview split\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenVSplit .": open vsplit\n"
                                    let @h=@h."\" ". g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                            
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Directory node mappings~\n"
                                    let @h=@h."\" ". (g:NERDTreeMouseMode ==# 1 ? "double" : "single") ."-click,\n"
                                    let @h=@h."\" ". g:NERDTreeMapActivateNode .": open & close node\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenRecursively .": recursively open node\n"
                                    let @h=@h."\" ". g:NERDTreeMapCloseDir .": close parent of node\n"
                                    let @h=@h."\" ". g:NERDTreeMapCloseChildren .": close all child nodes of\n"
                                    let @h=@h."\"    current node recursively\n"
                                    let @h=@h."\" middle-click,\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenExpl.": explore selected dir\n"
                            
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Bookmark table mappings~\n"
                                    let @h=@h."\" double-click,\n"
                                    let @h=@h."\" ". g:NERDTreeMapActivateNode .": open bookmark\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let @h=@h."\" ". g:NERDTreeMapDeleteBookmark .": delete bookmark\n"
                            
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Tree navigation mappings~\n"
                                    let @h=@h."\" ". g:NERDTreeMapJumpRoot .": go to root\n"
                                    let @h=@h."\" ". g:NERDTreeMapJumpParent .": go to parent\n"
                                    let @h=@h."\" ". g:NERDTreeMapJumpFirstChild  .": go to first child\n"
                                    let @h=@h."\" ". g:NERDTreeMapJumpLastChild   .": go to last child\n"
                                    let @h=@h."\" ". g:NERDTreeMapJumpNextSibling .": go to next sibling\n"
                                    let @h=@h."\" ". g:NERDTreeMapJumpPrevSibling .": go to prev sibling\n"
                            
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Filesystem mappings~\n"
                                    let @h=@h."\" ". g:NERDTreeMapChangeRoot .": change tree root to the\n"
                                    let @h=@h."\"    selected dir\n"
                                    let @h=@h."\" ". g:NERDTreeMapUpdir .": move tree root up a dir\n"
                                    let @h=@h."\" ". g:NERDTreeMapUpdirKeepOpen .": move tree root up a dir\n"
                                    let @h=@h."\"    but leave old root open\n"
                                    let @h=@h."\" ". g:NERDTreeMapRefresh .": refresh cursor dir\n"
                                    let @h=@h."\" ". g:NERDTreeMapRefreshRoot .": refresh current root\n"
                                    let @h=@h."\" ". g:NERDTreeMapMenu .": Show menu\n"
                                    let @h=@h."\" ". g:NERDTreeMapChdir .":change the CWD to the\n"
                                    let @h=@h."\"    selected dir\n"
                                    let @h=@h."\" ". g:NERDTreeMapCWD .":change tree root to CWD\n"
                            
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Tree filtering mappings~\n"
                                    let @h=@h."\" ". g:NERDTreeMapToggleHidden .": hidden files (" . (self.getShowHidden() ? "on" : "off") . ")\n"
                                    let @h=@h."\" ". g:NERDTreeMapToggleFilters .": file filters (" . (self.isIgnoreFilterEnabled() ? "on" : "off") . ")\n"
                                    let @h=@h."\" ". g:NERDTreeMapToggleFiles .": files (" . (self.getShowFiles() ? "on" : "off") . ")\n"
                                    let @h=@h."\" ". g:NERDTreeMapToggleBookmarks .": bookmarks (" . (self.getShowBookmarks() ? "on" : "off") . ")\n"
                            
                                    "add quickhelp entries for each custom key map
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Custom mappings~\n"
                                    for i in g:NERDTreeKeyMap.All()
                                        if !empty(i.quickhelpText)
                                            let @h=@h."\" ". i.key .": ". i.quickhelpText ."\n"
                                        endif
                                    endfor
                            
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Other mappings~\n"
                                    let @h=@h."\" ". g:NERDTreeMapQuit .": Close the NERDTree window\n"
                                    let @h=@h."\" ". g:NERDTreeMapToggleZoom .": Zoom (maximize-minimize)\n"
                                    let @h=@h."\"    the NERDTree window\n"
                                    let @h=@h."\" ". g:NERDTreeMapHelp .": toggle help\n"
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Bookmark commands~\n"
                                    let @h=@h."\" :Bookmark [<name>]\n"
                                    let @h=@h."\" :BookmarkToRoot <name>\n"
                                    let @h=@h."\" :RevealBookmark <name>\n"
                                    let @h=@h."\" :OpenBookmark <name>\n"
                                    let @h=@h."\" :ClearBookmarks [<names>]\n"
                                    let @h=@h."\" :ClearAllBookmarks\n"
                                    silent! put h
                                elseif !self.isMinimal()
                                    let @h="\" Press ". g:NERDTreeMapHelp ." for help\n"
                                    silent! put h
                                endif
                            
   25              0.000078     let @h = old_h

FUNCTION  <SNR>138_CountCurrentSearchIndex()
Called 1 time
Total time:   0.000272
 Self time:   0.000272

count  total (s)   self (s)
                            " sets globals -> s:Msg , s:Highlight
    1              0.000009     let s:Msg = '' | let s:Highlight = ''
    1              0.000001     let builtin_errmsg = ""
                            
                                " echo "" | " make sure old msg is erased
    1              0.000002     if a:cmd == '!'
                                    " if cmd is '!', we do not execute any command but report
                                    " last errmsg
                                    if v:errmsg != ""
                                        echohl Error
                                        echomsg v:errmsg
                                        echohl None
                                    endif
                                elseif a:cmd != ''
                                    let v:errmsg = ""
                            
                                    silent! exe "norm! ".a:cmd
                            
                                    if v:errmsg != ""
                                        echohl Error
                                        echomsg v:errmsg
                                        echohl None
                                    endif
                                    
                                    if line('$') >= g:search_index_max
                                        " for large files, preserve original error messages and add nothing
                                        return ""
                                    endif
                                else
    1              0.000001     endif
                            
    1              0.000003     if !a:force && line('$') >= g:search_index_max
                                    let too_slow=1
                                    " when too_slow, we'll want to switch the work over to CursorHold
                                    return ""
                                endif
    1              0.000003     if @/ == '' | return "" | endif
    1              0.000001     if version >= 700 
    1              0.000004 		let save = winsaveview()
    1              0.000001     endif
    1              0.000002     let line = line('.')
    1              0.000003     let vcol = virtcol('.')
    1              0.000022     norm gg0
    1              0.000002     let num = 0    " total # of matches in the buffer
    1              0.000002     let exact = -1
    1              0.000001     let after = 0
    1              0.000001     let too_slow = 0 " if too_slow, we'll want to switch the work over to CursorHold
    1              0.000001     let s_opt = 'Wc'
    4              0.000064     while search(@/, s_opt) && ( num <= g:search_index_maxhit  || a:force)
    3              0.000007         let num = num + 1
    3              0.000009         if line('.') == line && virtcol('.') == vcol
    1              0.000002             let exact = num
    1              0.000003         elseif line('.') < line || (line('.') == line && virtcol('.') < vcol)
                                        let after = num
                                    endif
    3              0.000004         let s_opt = 'W'
    3              0.000003     endwh
    1              0.000001     if version >= 700
    1              0.000005 		call winrestview(save)
    1              0.000001 	else
                            		exe line
                            		exe "norm! ".vcol."|"
                                endif
    1              0.000001     if !a:force && num > g:search_index_maxhit
                                    if exact >= 0 
                                        let too_slow=1 "  if too_slow, we'll want to switch the work over to CursorHold
                                        let num=">".(num-1)
                                    else
                                        let s:Msg = ">".(num-1)." matches"
                                        if v:errmsg != ""
                                            let s:Msg = ""  " avoid overwriting builtin errmsg with our ">1000 matches"
                                        endif
                                        return ""
                                    endif
                                endif
                            
    1              0.000002     let s:Highlight = "Directory"
    1              0.000001     if num == "0"
                                    let s:Highlight = "Error"
                                    let prefix = "No matches "
                                elseif exact == 1 && num==1
                                    " s:Highlight remains default
                                    "let prefix = "At single match"
                                    let prefix = "Single match"
                                elseif exact == 1
    1              0.000002         let s:Highlight = "Search"
                                    "let prefix = "At 1st  match, # 1 of " . num
                                    "let prefix = "First match, # 1 of " . num
    1              0.000003         let prefix = "First of " . num . " matches "
    1              0.000001     elseif exact == num
                                    let s:Highlight = "LineNr"
                                    "let prefix = "Last match, # ".num." of " . num
                                    "let prefix = "At last match, # ".num." of " . num
                                    let prefix = "Last of " . num . " matches "
                                elseif exact >= 0
                                    "let prefix = "At # ".exact." match of " . num
                                    "let prefix = "Match # ".exact." of " . num
                                    "let prefix = "# ".exact." match of " . num
                                    if exists('g:indexed_search_shortmess') && g:indexed_search_shortmess
                                        let prefix = exact." of " . num . " matches "
                                    else
                                        let prefix = "Match ".exact." of " . num
                                    endif
                                elseif after == 0
                                    let s:Highlight = "MoreMsg"
                                    let prefix = "Before first match, of ".num." matches "
                                    if num == 1
                                        let prefix = "Before single match"
                                    endif
                                elseif after == num
                                    let s:Highlight = "WarningMsg"
                                    let prefix = "After last match of ".num." matches "
                                    if num == 1
                                        let prefix = "After single match"
                                    endif
                                else
                                    let prefix = "Between matches ".after."-".(after+1)." of ".num
                                endif
    1              0.000003     let s:Msg = prefix . "  /".@/ . "/"
    1              0.000001     return ""

FUNCTION  gitgutter#async#execute()
Called 8 times
Total time:   0.016339
 Self time:   0.015232

count  total (s)   self (s)
    8   0.000057   0.000041   let bufnr = gitgutter#utility#bufnr()
                            
    8              0.000042   if has('nvim')
                                if has('unix')
                                  let command = ["sh", "-c", a:cmd]
                                elseif has('win32')
                                  let command = ["cmd.exe", "/c", a:cmd]
                                else
                                  throw 'unknown os'
                                endif
                                " Make the job use a shell while avoiding (un)quoting problems.
                                let job_id = jobstart(command, { 'buffer':    bufnr, 'on_stdout': function('gitgutter#async#handle_diff_job_nvim'), 'on_stderr': function('gitgutter#async#handle_diff_job_nvim'), 'on_exit':   function('gitgutter#async#handle_diff_job_nvim') })
                                call gitgutter#debug#log('[nvim job: '.job_id.', buffer: '.bufnr.'] '.a:cmd)
                                if job_id < 1
                                  throw 'diff failed'
                                endif
                            
                                " Note that when `cmd` doesn't produce any output, i.e. the diff is empty,
                                " the `stdout` event is not fired on the job handler.  Therefore we keep
                                " track of the jobs ourselves so we can spot empty diffs.
                                call s:job_started(job_id)
                            
                              else
                                " Make the job use a shell.
                                "
                                " Pass a handler for stdout but not for stderr so that errors are
                                " ignored (and thus signs are not updated; this assumes that an error
                                " only occurs when a file is not tracked by git).
                            
    8              0.000019     if has('unix')
    8              0.000029       let command = ["sh", "-c", a:cmd]
    8              0.000016     elseif has('win32')
                                  let command = "cmd.exe /c ".a:cmd
                                else
                                  throw 'unknown os'
                                endif
                            
    8              0.013247     let job = job_start(command, { 'out_cb':   'gitgutter#async#handle_diff_job_vim', 'close_cb': 'gitgutter#async#handle_diff_job_vim_close' })
    8   0.001533   0.000971     call gitgutter#debug#log('[vim job: '.string(job_info(job)).', buffer: '.bufnr.'] '.a:cmd)
                            
    8   0.000735   0.000206     call s:job_started(s:channel_id(job_getchannel(job)), bufnr)
    8              0.000034   endif

FUNCTION  <SNR>158_NERDTreeGetFileGitStatusKey()
Called 117 times
Total time:   0.001600
 Self time:   0.001600

count  total (s)   self (s)
  117              0.000373     if a:us ==# '?' && a:them ==# '?'
   13              0.000023         return 'Untracked'
                                elseif a:us ==# ' ' && a:them ==# 'M'
   91              0.000170         return 'Modified'
                                elseif a:us =~# '[MAC]'
                                    return 'Staged'
                                elseif a:us ==# 'R'
                                    return 'Renamed'
                                elseif a:us ==# 'U' || a:them ==# 'U' || a:us ==# 'A' && a:them ==# 'A' || a:us ==# 'D' && a:them ==# 'D'
                                    return 'Unmerged'
                                elseif a:them ==# 'D'
   13              0.000024         return 'Deleted'
                                else
                                    return 'Unknown'
                                endif

FUNCTION  <SNR>272_StartColRx()
Called 3 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
    3              0.000013     let mixedindent = a:0 >= 1 ? a:1 : get(s:cdef, 'mixedindent', 1)
                                " TLogVAR a:comment_mode, a:col, mixedindent
    3              0.000013     if a:comment_mode =~# '[IR]'
                                    let col = mixedindent ? a:col - 1 : a:col
                                    let c0 = 1
                                else
    3              0.000004         let col = a:col
    3              0.000004         let c0 = 2
    3              0.000001     endif
                                " TLogVAR col, c0, mixedindent
    3              0.000003     if col < c0
    3              0.000003         return '\^'
                                elseif mixedindent
                                    return '\%>'. col .'v'
                                else
                                    return '\%'. col .'v'
                                endif

FUNCTION  gitgutter#utility#file_relative_to_repo_root()
Called 6 times
Total time:   0.000195
 Self time:   0.000195

count  total (s)   self (s)
    6              0.000039   let file_path_relative_to_repo_root = getbufvar(s:bufnr, 'gitgutter_repo_relative_path')
    6              0.000020   if empty(file_path_relative_to_repo_root)
                                let dir_path_relative_to_repo_root = gitgutter#utility#system(gitgutter#utility#command_in_directory_of_file(g:gitgutter_git_executable.' rev-parse --show-prefix'))
                                let dir_path_relative_to_repo_root = gitgutter#utility#strip_trailing_new_line(dir_path_relative_to_repo_root)
                                let file_path_relative_to_repo_root = dir_path_relative_to_repo_root . gitgutter#utility#filename()
                                call setbufvar(s:bufnr, 'gitgutter_repo_relative_path', file_path_relative_to_repo_root)
                              endif
    6              0.000014   return file_path_relative_to_repo_root

FUNCTION  lightline#update_once()
Called 720 times
Total time:   0.008091
 Self time:   0.008091

count  total (s)   self (s)
  720              0.004161   if !exists('w:lightline') || w:lightline
                                call lightline#update()
                              endif

FUNCTION  <SNR>272_GetCommentReplace()
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000003     if has_key(a:cdef, 'commentstring_rx')
                                    let rs = s:BlockGetCommentString(a:cdef)
                                else
    1              0.000001         let rs = a:cms0
    1              0.000000     endif
    1              0.000002     return rs
                                " return escape(rs, '"/')

FUNCTION  gitgutter#diff#is_removed()
Called 16 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
   16              0.000036   return a:from_count > 0 && a:to_count == 0

FUNCTION  241()
Called 1 time
Total time:   0.000038
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000005     let line = getline(a:ln)
                            
    1   0.000027   0.000007     let rootLine = self.getRootLineNum()
                            
                                "check to see if we have the root node
    1              0.000001     if a:ln == rootLine
    1              0.000002         return self.nerdtree.root.path
                                endif
                            
                                if line ==# s:UI.UpDirLine()
                                    return self.nerdtree.root.path.getParent()
                                endif
                            
                                let indent = self._indentLevelFor(line)
                            
                                "remove the tree parts and the leading space
                                let curFile = self._stripMarkup(line, 0)
                            
                                let wasdir = 0
                                if curFile =~# '/$'
                                    let wasdir = 1
                                    let curFile = substitute(curFile, '/\?$', '/', "")
                                endif
                            
                                let dir = ""
                                let lnum = a:ln
                                while lnum > 0
                                    let lnum = lnum - 1
                                    let curLine = getline(lnum)
                                    let curLineStripped = self._stripMarkup(curLine, 1)
                            
                                    "have we reached the top of the tree?
                                    if lnum == rootLine
                                        let dir = self.nerdtree.root.path.str({'format': 'UI'}) . dir
                                        break
                                    endif
                                    if curLineStripped =~# '/$'
                                        let lpindent = self._indentLevelFor(curLine)
                                        if lpindent < indent
                                            let indent = indent - 1
                            
                                            let dir = substitute (curLineStripped,'^\\', "", "") . dir
                                            continue
                                        endif
                                    endif
                                endwhile
                                let curFile = self.nerdtree.root.path.drive . dir . curFile
                                let toReturn = g:NERDTreePath.New(curFile)
                                return toReturn

FUNCTION  243()
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000001     let rootLine = 1
    1              0.000011     while getline(rootLine) !~# '^\(/\|<\)'
                                    let rootLine = rootLine + 1
                                endwhile
    1              0.000001     return rootLine

FUNCTION  245()
Called 900 times
Total time:   0.001255
 Self time:   0.001255

count  total (s)   self (s)
  900              0.001008     return self._showFiles

FUNCTION  fugitive#head()
Called 1774 times
Total time:   0.287597
 Self time:   0.028044

count  total (s)   self (s)
 1774              0.007485   if !exists('b:git_dir')
  570              0.000915     return ''
                              endif
                            
 1204   0.273933   0.014380   return s:repo().head(a:0 ? a:1 : 0)

FUNCTION  247()
Called 1156 times
Total time:   0.001678
 Self time:   0.001678

count  total (s)   self (s)
 1156              0.001363     return self._showHidden

FUNCTION  <SNR>247_SetUpYcmChangedTick()
Called 706 times
Total time:   0.006900
 Self time:   0.006900

count  total (s)   self (s)
  706              0.006290   let b:ycm_changedtick  = get( b:, 'ycm_changedtick', {   'file_ready_to_parse' : -1, } )

FUNCTION  gitgutter#utility#has_unsaved_changes()
Called 7 times
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
    7              0.000050   return getbufvar(s:bufnr, "&mod")

FUNCTION  <SNR>168_select_tags_file()
Called 1 time
Total time:   0.000211
 Self time:   0.000048

count  total (s)   self (s)
                              " If the selected tags file exists, make sure its writable. Also provide the
                              " user with feedback about the tags file selection process.
    1              0.000018   if filereadable(a:tagsfile) && filewritable(a:tagsfile) != 1
                                let message = "The %s tags file %s isn't writable!"
                                throw printf(message, a:kind, fnamemodify(a:tagsfile, ':~'))
                              endif
                              " Provide the user with feedback about the tags file selection process.
    1   0.000026   0.000010   call xolox#misc#msg#debug("easytags.vim %s: Selected %s tags file %s.", g:xolox#easytags#version, a:kind, a:tagsfile)
                              " Canonicalize the tags file's pathname.
    1   0.000157   0.000010   return xolox#misc#path#absolute(a:tagsfile)

FUNCTION  251()
Called 75 times
Total time:   0.000133
 Self time:   0.000133

count  total (s)   self (s)
   75              0.000103     return g:NERDTreeMinimalUI

FUNCTION  255()
Called 2 times
Total time:   0.000454
 Self time:   0.000098

count  total (s)   self (s)
    2              0.000011     let win = winnr()
    2   0.000318   0.000008     call g:NERDTree.CursorToTreeWin()
    2              0.000023     let self._screenState = {}
    2              0.000014     let self._screenState['oldPos'] = getpos(".")
    2              0.000012     let self._screenState['oldTopLine'] = line("w0")
    2              0.000009     let self._screenState['oldWindowSize']= winwidth("")
    2   0.000059   0.000013     call nerdtree#exec(win . "wincmd w")

FUNCTION  258()
Called 25 times
Total time:   0.190423
 Self time:   0.005072

count  total (s)   self (s)
   25              0.000213     setlocal modifiable
                            
                                "remember the top line of the buffer and the current line so we can
                                "restore the view exactly how it was
   25              0.000079     let curLine = line(".")
   25              0.000061     let curCol = col(".")
   25              0.000109     let topLine = line("w0")
                            
                                "delete all lines in the buffer (being careful not to clobber a register)
   25              0.000649     silent 1,$delete _
                            
   25   0.003499   0.000122     call self._dumpHelp()
                            
                                "delete the blank line before the help and add one after it
   25   0.000131   0.000085     if !self.isMinimal()
                                    call setline(line(".")+1, "")
                                    call cursor(line(".")+1, col("."))
                                endif
                            
   25   0.000156   0.000111     if self.getShowBookmarks()
                                    call self._renderBookmarks()
                                endif
                            
                                "add the 'up a dir' line
   25   0.000096   0.000062     if !self.isMinimal()
                                    call setline(line(".")+1, s:UI.UpDirLine())
                                    call cursor(line(".")+1, col("."))
                                endif
                            
                                "draw the header line
   25   0.002080   0.000248     let header = self.nerdtree.root.path.str({'format': 'UI', 'truncateTo': winwidth(0)})
   25              0.000166     call setline(line(".")+1, header)
   25              0.000122     call cursor(line(".")+1, col("."))
                            
                                "draw the tree
   25              0.000046     let old_o = @o
   25   0.180252   0.000235     let @o = self.nerdtree.root.renderToString()
   25              0.000316     silent put o
   25              0.000108     let @o = old_o
                            
                                "delete the blank line at the top of the buffer
   25              0.000217     silent 1,1delete _
                            
                                "restore the view
   25              0.000080     let old_scrolloff=&scrolloff
   25              0.000301     let &scrolloff=0
   25              0.000110     call cursor(topLine, 1)
   25              0.000540     normal! zt
   25              0.000075     call cursor(curLine, curCol)
   25              0.000103     let &scrolloff = old_scrolloff
                            
   25              0.000109     setlocal nomodifiable

FUNCTION  gitgutter#hunk#reset()
Called 21 times
Total time:   0.000672
 Self time:   0.000590

count  total (s)   self (s)
   21   0.000652   0.000570   call setbufvar(gitgutter#utility#bufnr(), 'gitgutter_summary', [0,0,0])

FUNCTION  gitgutter#utility#exists_file()
Called 37 times
Total time:   0.001335
 Self time:   0.001335

count  total (s)   self (s)
   37              0.001303   return filereadable(s:file)

FUNCTION  fugitive#reload_status()
Called 3 times
Total time:   0.001092
 Self time:   0.001092

count  total (s)   self (s)
    3              0.000093   if exists('s:reloading_status')
                                return
                              endif
    3              0.000004   try
    3              0.000014     let s:reloading_status = 1
    3              0.000012     let mytab = tabpagenr()
    9              0.000041     for tab in [mytab] + range(1,tabpagenr('$'))
   20              0.000056       for winnr in range(1,tabpagewinnr(tab,'$'))
   14              0.000130         if getbufvar(tabpagebuflist(tab)[winnr-1],'fugitive_type') ==# 'index'
                                      execute 'tabnext '.tab
                                      if winnr != winnr()
                                        execute winnr.'wincmd w'
                                        let restorewinnr = 1
                                      endif
                                      try
                                        if !&modified
                                          call s:BufReadIndex()
                                        endif
                                      finally
                                        if exists('restorewinnr')
                                          wincmd p
                                        endif
                                        execute 'tabnext '.mytab
                                      endtry
                                    endif
   14              0.000013       endfor
    6              0.000009     endfor
    3              0.000005   finally
    3              0.000011     unlet! s:reloading_status
    3              0.000003   endtry

FUNCTION  <SNR>119_sub()
Called 1204 times
Total time:   0.020615
 Self time:   0.020615

count  total (s)   self (s)
 1204              0.019971   return substitute(a:str,'\v\C'.a:pat,a:rep,'')

FUNCTION  gitgutter#utility#is_file_buffer()
Called 51 times
Total time:   0.000542
 Self time:   0.000542

count  total (s)   self (s)
   51              0.000497   return empty(getbufvar(s:bufnr, '&buftype'))

FUNCTION  <SNR>247_OnFileReadyToParse()
Called 706 times
Total time:   0.266140
 Self time:   0.259240

count  total (s)   self (s)
                              " We need to call this just in case there is no b:ycm_changetick; this can
                              " happen for special buffers.
  706   0.010468   0.003568   call s:SetUpYcmChangedTick()
                            
                              " Order is important here; we need to extract any information before
                              " reparsing the file again. If we sent the new parse request first, then
                              " the response would always be pending when we called
                              " HandleFileParseRequest.
  706              0.233006   exec s:python_command "ycm_state.HandleFileParseRequest()"
                            
  706              0.006824   let buffer_changed = b:changedtick != b:ycm_changedtick.file_ready_to_parse
  706              0.001393   if buffer_changed
    2              0.004572     exec s:python_command "ycm_state.OnFileReadyToParse()"
    2              0.000014   endif
  706              0.002286   let b:ycm_changedtick.file_ready_to_parse = b:changedtick

FUNCTION  <SNR>157_refreshCurrent()
Called 1 time
Total time:   0.166541
 Self time:   0.006690

count  total (s)   self (s)
    1              0.000002     let node = a:node
    1              0.000001     if !node.path.isDirectory
                                    let node = node.parent
                                endif
                            
    1   0.000236   0.000011     call nerdtree#echo("Refreshing node. This could take a while...")
    1   0.152147   0.000037     call node.refresh()
    1   0.007493   0.000007     call b:NERDTree.render()
    1              0.006603     redraw
    1   0.000051   0.000021     call nerdtree#echo("Refreshing node. This could take a while... DONE")

FUNCTION  gitgutter#utility#is_active()
Called 51 times
Total time:   0.005576
 Self time:   0.001138

count  total (s)   self (s)
   51   0.005521   0.001083   return g:gitgutter_enabled && !pumvisible() && gitgutter#utility#is_file_buffer() && gitgutter#utility#exists_file() && gitgutter#utility#not_git_dir()

FUNCTION  267()
Called 581 times
Total time:   0.007718
 Self time:   0.007718

count  total (s)   self (s)
  581              0.001882     let newObj = copy(self)
  581              0.001281     let newObj.nerdtree = a:nerdtree
  581              0.001100     let newObj.subject = a:subject
  581              0.001095     let newObj.action = a:action
  581              0.001038     let newObj.params = a:params
  581              0.000685     return newObj

FUNCTION  269()
Called 581 times
Total time:   1.039297
 Self time:   0.014297

count  total (s)   self (s)
  581   0.011288   0.003570     let event = g:NERDTreeEvent.New(a:nerdtree, a:path, a:event, a:params)
                            
 1162   0.012254   0.003632     for listener in s:Notifier.GetListenersForEvent(a:event)
  581   1.012226   0.003566         call {listener}(event)
  581              0.000557     endfor

FUNCTION  gitgutter#utility#save_last_seen_change()
Called 7 times
Total time:   0.000083
 Self time:   0.000083

count  total (s)   self (s)
    7              0.000061   call setbufvar(s:bufnr, 'gitgutter_last_tick', getbufvar(s:bufnr, 'changedtick'))

FUNCTION  ale#cursor#EchoCursorWarning()
Called 589 times
Total time:   0.105610
 Self time:   0.093527

count  total (s)   self (s)
                                " Only echo the warnings in normal mode, otherwise we will get problems.
  589              0.019087     if mode() !=# 'n'
    2              0.000003         return
                                endif
                            
  587              0.012918     let l:buffer = bufnr('%')
                            
  587              0.009922     if !has_key(g:ale_buffer_info, l:buffer)
  247              0.000660         return
                                endif
                            
  340              0.003855     let l:pos = getcurpos()
  340              0.003351     let l:loclist = g:ale_buffer_info[l:buffer].loclist
  340   0.020002   0.007919     let l:index = ale#util#BinarySearch(l:loclist, l:pos[1], l:pos[2])
                            
  340              0.001008     if l:index >= 0
                                    let l:loc = l:loclist[l:index]
                                    let l:msg = s:GetMessage(l:loc.linter_name, l:loc.type, l:loc.text)
                                    call ale#cursor#TruncatedEcho(l:msg)
                                    let g:ale_buffer_info[l:buffer].echoed = 1
                                else
                                    " We'll only clear the echoed message when moving off errors once,
                                    " so we don't continually clear the echo line.
  340              0.003272         if get(g:ale_buffer_info[l:buffer], 'echoed')
                                        echo
                                        let g:ale_buffer_info[l:buffer].echoed = 0
                                    endif
  340              0.000400     endif

FUNCTION  gitgutter#diff#parse_diff()
Called 7 times
Total time:   0.001239
 Self time:   0.000498

count  total (s)   self (s)
    7              0.000018   let hunks = []
   23              0.000098   for line in split(a:diff, '\n')
   16   0.000911   0.000170     let hunk_info = gitgutter#diff#parse_hunk(line)
   16              0.000038     if len(hunk_info) == 4
   16              0.000043       call add(hunks, hunk_info)
   16              0.000024     endif
   16              0.000016   endfor
    7              0.000009   return hunks

FUNCTION  270()
Called 581 times
Total time:   0.004212
 Self time:   0.004212

count  total (s)   self (s)
  581              0.001924     if !exists("s:refreshListenersMap")
                                    let s:refreshListenersMap = {}
                                endif
  581              0.000765     return s:refreshListenersMap

FUNCTION  271()
Called 581 times
Total time:   0.008622
 Self time:   0.004410

count  total (s)   self (s)
  581   0.006297   0.002085     let listenersMap = s:Notifier.GetListenersMap()
  581              0.001982     return get(listenersMap, a:name, [])

FUNCTION  273()
Called 1 time
Total time:   0.000333
 Self time:   0.000109

count  total (s)   self (s)
    1              0.000010     if empty(get(self, 'current'))
                                  throw "timer.stop() called on a timer that was never started!"
                                endif
    1              0.000002     if s:has_reltime
    1   0.000244   0.000020       let elapsed_time_string = xolox#misc#str#trim(reltimestr(reltime(self.current)))
                                  " This is a bit silly (converting to a string and then parsing that) but
                                  " the value of reltime() is documented as being platform specific...
    1              0.000017       let [seconds, microseconds] = split(elapsed_time_string, '\.')
    1              0.000022       let self.total[0] += substitute(seconds, '^0*', '', '')
    1              0.000013       let self.total[1] += substitute(microseconds, '^0*', '', '')
    1              0.000004       let self.current = []
    1              0.000002     else
                                  let self.total[0] += localtime() - self.current
                                  let self.current = 0
                                endif

FUNCTION  275()
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000002     if s:has_reltime
    1              0.000005       let self.current = reltime()
    1              0.000002     else
                                  let self.current = localtime()
                                endif

FUNCTION  276()
Called 1 time
Total time:   0.000133
 Self time:   0.000094

count  total (s)   self (s)
    1              0.000008     if empty(get(self, 'current'))
                                  throw "timer.stop() called on a timer that was never started!"
                                endif
    1              0.000002     if s:has_reltime
    1   0.000059   0.000020       let elapsed_time_string = xolox#misc#str#trim(reltimestr(reltime(self.current)))
                                  " This is a bit silly (converting to a string and then parsing that) but
                                  " the value of reltime() is documented as being platform specific...
    1              0.000016       let [seconds, microseconds] = split(elapsed_time_string, '\.')
    1              0.000019       let self.total[0] += substitute(seconds, '^0*', '', '')
    1              0.000010       let self.total[1] += substitute(microseconds, '^0*', '', '')
    1              0.000003       let self.current = []
    1              0.000001     else
                                  let self.total[0] += localtime() - self.current
                                  let self.current = 0
                                endif

FUNCTION  xolox#misc#option#get()
Called 20 times
Total time:   0.000430
 Self time:   0.000430

count  total (s)   self (s)
                              " Expects one or two arguments: 1. The name of a variable and 2. the default
                              " value if the variable does not exist.
                              "
                              " Returns the value of the variable from a buffer local variable, global
                              " variable or the default value, depending on which is defined.
                              "
                              " This is used by some of my Vim plug-ins for option handling, so that users
                              " can customize options for specific buffers.
   20              0.000095   if exists('b:' . a:name)
                                " Buffer local variable.
                                return eval('b:' . a:name)
                              elseif exists('g:' . a:name)
                                " Global variable.
    6              0.000020     return eval('g:' . a:name)
                              elseif exists('a:1')
                                " Default value.
   12              0.000016     return a:1
                              endif

FUNCTION  <SNR>124_ShowMarks()
Called 29 times
Total time:   0.203100
 Self time:   0.092765

count  total (s)   self (s)
   29              0.000103 	if g:showmarks_enable == 0
                            		return
                            	endif
                            
   29              0.001430 	if   ((match(g:showmarks_ignore_type, "[Hh]") > -1) && (&buftype    == "help"    )) || ((match(g:showmarks_ignore_type, "[Qq]") > -1) && (&buftype    == "quickfix")) || ((match(g:showmarks_ignore_type, "[Pp]") > -1) && (&pvw        == 1         )) || ((match(g:showmarks_ignore_type, "[Rr]") > -1) && (&readonly   == 1         )) || ((match(g:showmarks_ignore_type, "[Mm]") > -1) && (&modifiable == 0         ))
    2              0.000004 		return
                            	endif
                            
   27              0.000078 	let n = 0
   27   0.002509   0.000392 	let s:maxmarks = strlen(s:IncludeMarks())
 1404              0.002229 	while n < s:maxmarks
 1377   0.073774   0.007959 		let c = strpart(s:IncludeMarks(), n, 1)
 1377   0.022583   0.006368 		let nm = s:NameOfMark(c)
 1377              0.005295 		let id = n + (s:maxmarks * winbufnr(0))
                            		"let ln = line("'".c)
 1377   0.034021   0.007833 		let ln = s:GetMarkLine("'".c)
                            
 1377              0.006062 		if ln == 0 && (exists('b:placed_'.nm) && b:placed_{nm} != ln)
                            			exe 'sign unplace '.id.' buffer='.winbufnr(0)
                            		elseif ln > 1 || c !~ '[a-zA-Z]'
                            			" Have we already placed a mark here in this call to ShowMarks?
                            			if exists('mark_at'.ln)
                            				" Already placed a mark, set the highlight to multiple
                            				if c =~# '[a-zA-Z]' && b:ShowMarksLink{mark_at{ln}} != 'ShowMarksHLm'
                            					let b:ShowMarksLink{mark_at{ln}} = 'ShowMarksHLm'
                            					exe 'hi link '.s:ShowMarksDLink{mark_at{ln}}.mark_at{ln}.' '.b:ShowMarksLink{mark_at{ln}}
                            				endif
                            			else
                            				if !exists('b:ShowMarksLink'.nm) || b:ShowMarksLink{nm} != s:ShowMarksDLink{nm}
                            					let b:ShowMarksLink{nm} = s:ShowMarksDLink{nm}
                            					exe 'hi link '.s:ShowMarksDLink{nm}.nm.' '.b:ShowMarksLink{nm}
                            				endif
                            				let mark_at{ln} = nm
                            				if !exists('b:placed_'.nm) || b:placed_{nm} != ln
                            					exe 'sign unplace '.id.' buffer='.winbufnr(0)
                            					exe 'sign place '.id.' name=ShowMark'.nm.' line='.ln.' buffer='.winbufnr(0)
                            					let b:placed_{nm} = ln
                            				endif
                            			endif
                            		endif
 1377              0.002746 		let n = n + 1
 1377              0.001343 	endw

FUNCTION  <SNR>267_job_buffer()
Called 7 times
Total time:   0.000121
 Self time:   0.000121

count  total (s)   self (s)
    7              0.000032   return s:jobs[a:id].buffer

FUNCTION  xolox#misc#os#can_use_dll()
Called 2 times
Total time:   0.006606
 Self time:   0.006606

count  total (s)   self (s)
                              " If a) we're on Microsoft Windows, b) the vim-shell plug-in is installed
                              " and c) the compiled DLL included in vim-shell works, we can use the
                              " vim-shell plug-in to execute external commands! Returns 1 (true)
                              " if we can use the DLL, 0 (false) otherwise.
    2              0.000005   let can_use_dll = 0
    2              0.000003   try
    2              0.006506     let can_use_dll = xolox#shell#can_use_dll()
                              catch /^Vim\%((\a\+)\)\=:E117/
                                " Silence E117.
    2              0.000009   endtry
    2              0.000009   return can_use_dll

FUNCTION  <SNR>267_job_finished()
Called 7 times
Total time:   0.000139
 Self time:   0.000139

count  total (s)   self (s)
    7              0.000050   if has_key(s:jobs, a:id)
    7              0.000067     unlet s:jobs[a:id]
    7              0.000007   endif

FUNCTION  50()
Called 1 time
Total time:   0.000082
 Self time:   0.000031

count  total (s)   self (s)
    1   0.000015   0.000004     let lead = s:Path.Slash()
                            
                                "if we are running windows then slap a drive letter on the front
    1   0.000010   0.000002     if nerdtree#runningWindows()
                                    let lead = self.drive . '\'
                                endif
                            
    1   0.000016   0.000005     let toReturn = lead . join(self.pathSegments, s:Path.Slash())
                            
    1   0.000010   0.000003     if !nerdtree#runningWindows()
    1   0.000024   0.000010         let toReturn = escape(toReturn, self._escChars())
    1              0.000000     endif
    1              0.000001     return toReturn

FUNCTION  xolox#easytags#autoload()
Called 1 time
Total time:   0.182491
 Self time:   0.001865

count  total (s)   self (s)
    1              0.000002   try
    1   0.000014   0.000010     let session_loading = xolox#easytags#session_is_loading() && a:event == 'BufReadPost'
    1   0.000033   0.000012     let do_update = xolox#misc#option#get('easytags_auto_update', 1) && !session_loading
    1   0.000026   0.000009     let do_highlight = xolox#misc#option#get('easytags_auto_highlight', 1) && &eventignore !~? '\<syntax\>'
                                " Don't execute this function for unsupported file types (doesn't load
                                " the list of file types if updates and highlighting are both disabled).
    1   0.063853   0.001639     if (do_update || do_highlight) && !empty(xolox#easytags#filetypes#canonicalize(&filetype))
                                  " Update entries for current file in tags file?
    1              0.000002       if do_update
    1              0.000007         let buffer_read = (a:event =~? 'BufReadPost')
    1              0.000005         let buffer_written = (a:event =~? 'BufWritePost')
    1              0.000003         if buffer_written || (buffer_read && xolox#misc#option#get('easytags_always_enabled', 0))
    1   0.066563   0.000088           call xolox#easytags#update(1, 0, [])
    1              0.000002         endif
    1              0.000001       endif
                                  " Apply highlighting of tags to current buffer?
    1              0.000002       if do_highlight
    1              0.000007         if !exists('b:easytags_last_highlighted')
    1   0.051923   0.000028           call xolox#easytags#highlight()
    1              0.000001         else
                                      for tagfile in tagfiles()
                                        if getftime(tagfile) > b:easytags_last_highlighted
                                          call xolox#easytags#highlight()
                                          break
                                        endif
                                      endfor
                                    endif
    1              0.000010         let b:easytags_last_highlighted = localtime()
    1              0.000002       endif
    1              0.000001     endif
    1              0.000001   catch
                                call xolox#misc#msg#warn("easytags.vim %s: %s (at %s)", g:xolox#easytags#version, v:exception, v:throwpoint)
                              endtry

FUNCTION  244()
Called 25 times
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
   25              0.000034     return self._showBookmarks

FUNCTION  gitgutter#utility#using_xolox_shell()
Called 8 times
Total time:   0.000181
 Self time:   0.000181

count  total (s)   self (s)
    8              0.000023   if s:using_xolox_shell == -1
                                if !g:gitgutter_avoid_cmd_prompt_on_windows
                                  let s:using_xolox_shell = 0
                                " Although xolox/vim-shell works on both windows and unix we only want to use
                                " it on windows.
                                elseif has('win32') || has('win64') || has('win32unix')
                                  let s:using_xolox_shell = exists('g:xolox#misc#version') && exists('g:xolox#shell#version')
                                else
                                  let s:using_xolox_shell = 0
                                endif
                              endif
    8              0.000013   return s:using_xolox_shell

FUNCTION  indent_guides#process_autocmds()
Called 14 times
Total time:   0.001337
 Self time:   0.000268

count  total (s)   self (s)
   14              0.000035   if g:indent_guides_autocmds_enabled
                                call indent_guides#enable()
                              else
   14   0.001213   0.000144     call indent_guides#disable()
   14              0.000012   end

FUNCTION  xolox#session#auto_save_periodic()
Called 1 time
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
                              " Automatically saves the current editing session every few minutes.
                              " Normally called by the [CursorHold] [] and [CursorHoldI] [] automatic
                              " command events.
                              "
                              " [CursorHold]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#CursorHold
                              " [CursorHoldI]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#CursorHoldI
    1              0.000002   if g:session_autosave_periodic > 0
                                let interval = g:session_autosave_periodic * 60
                                let next_save = s:session_last_flushed + interval
                                if localtime() > next_save
                                  let name = xolox#session#find_current_session()
                                  if !empty(name)
                                    if xolox#session#is_tab_scoped()
                                      let function = 'xolox#session#save_tab_cmd'
                                      let arguments = [name, '', 'SaveTabSession']
                                    else
                                      let function = 'xolox#session#save_cmd'
                                      let arguments = [name, '', 'SaveSession']
                                    endif
                                    if xolox#misc#option#get('session_autosave_silent', 0)
                                      " Silence informational messages perceived as noisy.
                                      " https://github.com/xolox/vim-session/issues/120
                                      silent call call(function, arguments)
                                    else
                                      call call(function, arguments)
                                    endif
                                  endif
                                endif
                              endif

FUNCTION  nerdtree#ui_glue#invokeKeyMap()
Called 1 time
Total time:   0.167463
 Self time:   0.000030

count  total (s)   self (s)
    1   0.167459   0.000026     call g:NERDTreeKeyMap.Invoke(a:key)

FUNCTION  <SNR>247_SetUpCompleteopt()
Called 25 times
Total time:   0.000563
 Self time:   0.000563

count  total (s)   self (s)
                              " Some plugins (I'm looking at you, vim-notes) change completeopt by for
                              " instance adding 'longest'. This breaks YCM. So we force our settings.
                              " There's no two ways about this: if you want to use YCM then you have to
                              " have these completeopt settings, otherwise YCM won't work at all.
                            
                              " We need menuone in completeopt, otherwise when there's only one candidate
                              " for completion, the menu doesn't show up.
   25              0.000175   set completeopt-=menu
   25              0.000069   set completeopt+=menuone
                            
                              " This is unnecessary with our features. People use this option to insert
                              " the common prefix of all the matches and then add more differentiating chars
                              " so that they can select a more specific match. With our features, they
                              " don't need to insert the prefix; they just type the differentiating chars.
                              " Also, having this option set breaks the plugin.
   25              0.000061   set completeopt-=longest
                            
   25              0.000044   if g:ycm_add_preview_to_completeopt
                                set completeopt+=preview
                              endif

FUNCTION  <SNR>119_repo_dir()
Called 2408 times
Total time:   0.018235
 Self time:   0.018235

count  total (s)   self (s)
 2408              0.017066   return join([self.git_dir]+a:000,'/')

FUNCTION  <SNR>272_AddModeExtra()
Called 3 times
Total time:   0.000081
 Self time:   0.000081

count  total (s)   self (s)
                                " TLogVAR a:comment_mode, a:extra
    3              0.000006     if a:beg == a:end
                                    let extra = substitute(a:extra, '\C[B]', '', 'g')
                                else
    3              0.000033         let extra = substitute(a:extra, '\C[IR]', '', 'g')
    3              0.000002     endif
    3              0.000008     if empty(extra)
    3              0.000005         return a:comment_mode
                                else
                                    let comment_mode = a:comment_mode
                                    if extra =~# 'B'
                                        let comment_mode = substitute(comment_mode, '\c[gir]', '', 'g')
                                    endif
                                    if extra =~# '[IR]'
                                        let comment_mode = substitute(comment_mode, '\c[gb]', '', 'g')
                                    endif
                                    if extra =~# '[BLIRK]' && comment_mode =~# 'G'
                                        let comment_mode = substitute(comment_mode, '\c[G]', '', 'g')
                                    endif
                                    let rv = substitute(comment_mode, '\c['. extra .']', '', 'g') . extra
                                    " TLogVAR a:comment_mode, a:extra, comment_mode, extra, rv
                                    return rv
                                endif

FUNCTION  gitgutter#async#handle_diff_job_vim_close()
Called 7 times
Total time:   0.019188
 Self time:   0.001091

count  total (s)   self (s)
    7   0.000859   0.000513   call gitgutter#debug#log('channel: '.a:channel)
                            
    7   0.000156   0.000058   let channel_id = s:channel_id(a:channel)
    7   0.000196   0.000075   let job_bufnr = s:job_buffer(channel_id)
                            
    7              0.000032   if bufexists(job_bufnr)
    7   0.000263   0.000074     let current_buffer = gitgutter#utility#bufnr()
    7   0.000198   0.000044     call gitgutter#utility#set_buffer(job_bufnr)
                            
    7   0.001070   0.000034     if gitgutter#utility#is_active()
    7   0.015957   0.000105       call gitgutter#handle_diff(s:job_output(channel_id))
    7              0.000005     endif
                            
    7   0.000206   0.000044     call gitgutter#utility#set_buffer(current_buffer)
    7              0.000009   endif
    7   0.000186   0.000047   call s:job_finished(channel_id)

FUNCTION  xolox#misc#os#find_vim()
Called 1 time
Total time:   0.000252
 Self time:   0.000103

count  total (s)   self (s)
                              " Returns the program name of Vim as a string. On Windows and UNIX this just
                              " [v:progname] [] as an absolute pathname while on Mac OS X there is
                              " some special magic to find MacVim's executable even though it's usually
                              " not on the executable search path. If you want, you can override the
                              " value returned from this function by setting the global variable
                              " `g:xolox#misc#os#vim_progname`.
                              "
                              " By default the choice of console Vim vs graphical Vim is made based on
                              " the value of [v:progname] [], but if you have a preference you can pass
                              " the string `vim` or `gvim` as the first and only argument.
                              "
                              " [v:progname]: http://vimdoc.sourceforge.net/htmldoc/eval.html#v:progname
    1              0.000003   if exists('a:1')
    1              0.000003     let program_name = a:1
    1              0.000001   else
                                let program_name = v:progname
                              endif
    1              0.000003   if exists('g:xolox#misc#os#vim_progname')
                                let pathname = g:xolox#misc#os#vim_progname
                              else
    1              0.000001     let pathname = ''
    1              0.000000   endif
    1   0.000037   0.000008   if empty(pathname) && xolox#misc#os#is_mac()
                                " Special handling for Mac OS X where MacVim is usually not on the $PATH.
                                " This always returns the "Vim" executable and not "MacVim" (regardless of
                                " the caller's preference) because "MacVim" has funky dock magic going on.
    1   0.000017   0.000006     call xolox#misc#msg#debug("vim-misc %s: Trying MacVim workaround to find Vim executable ..", g:xolox#misc#version)
    1   0.000071   0.000006     let segments = xolox#misc#path#split($VIMRUNTIME)
    1              0.000008     if segments[-3:] == ['Resources', 'vim', 'runtime']
    1   0.000038   0.000015       let pathname = xolox#misc#path#join(segments[0:-4] + ['MacOS', 'Vim'])
    1   0.000019   0.000008       call xolox#misc#msg#debug("vim-misc %s: The MacVim workaround resulted in the Vim executable %s.", g:xolox#misc#version, string(pathname))
    1              0.000001     endif
    1              0.000001   endif
    1              0.000002   if empty(pathname)
                                " Default logic.
                                call xolox#misc#msg#debug("vim-misc %s: Looking for Vim executable named %s on search path ..", g:xolox#misc#version, string(program_name))
                                let candidates = xolox#misc#path#which(program_name)
                                if !empty(candidates)
                                  call xolox#misc#msg#debug("vim-misc %s: Found %i candidate(s) on search path: %s.", g:xolox#misc#version, len(candidates), string(candidates))
                                  let pathname = candidates[0]
                                endif
                              endif
    1   0.000017   0.000007   call xolox#misc#msg#debug("vim-misc %s: Reporting Vim executable %s.", g:xolox#misc#version, string(pathname))
    1              0.000001   return pathname

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
Called 745 times
Total time:   0.052879
 Self time:   0.052879

count  total (s)   self (s)
                                " Do nothing for blacklisted files.
  745              0.010981     if index(g:ale_filetype_blacklist, &filetype) >= 0
   43              0.000091         return
                                endif
                            
  702              0.002145     if s:cursor_timer != -1
  652              0.003207         call timer_stop(s:cursor_timer)
  652              0.003111         let s:cursor_timer = -1
  652              0.000730     endif
                            
  702              0.008433     let l:pos = getcurpos()[0:2]
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
  702              0.002121     if l:pos != s:last_pos
  652              0.002347         let s:last_pos = l:pos
  652              0.006061         let s:cursor_timer = timer_start(10, function('ale#cursor#EchoCursorWarning'))
  652              0.000786     endif

FUNCTION  xolox#misc#async#callback_to_parent()
Called 1 time
Total time:   0.000210
 Self time:   0.000064

count  total (s)   self (s)
                              " When Vim was compiled with client/server support this function (in the
                              " parent process) will be called by `xolox#misc#async#inside_child()` (in
                              " the child process) after the user defined function has returned. This
                              " enables more or less instant callbacks after running an asynchronous
                              " function.
    1              0.000009   let unique_number = a:response['number']
    1              0.000008   let request = g:xolox#misc#async#requests[unique_number]
    1   0.000032   0.000014   call xolox#misc#timer#stop("vim-misc %s: Processing asynchronous callback #%i after %s ..", g:xolox#misc#version, unique_number, request['starttime'])
    1              0.000005   call remove(g:xolox#misc#async#requests, unique_number)
    1              0.000004   let callback = get(request, 'callback')
    1              0.000003   if !empty(callback)
    1   0.000141   0.000013     call call(callback, [a:response])
    1              0.000001   endif

FUNCTION  gitgutter#handle_diff()
Called 7 times
Total time:   0.015731
 Self time:   0.001744

count  total (s)   self (s)
    7   0.000336   0.000033   call gitgutter#debug#log(a:diff)
                            
    7   0.000085   0.000074   call setbufvar(gitgutter#utility#bufnr(), 'gitgutter_tracked', 1)
                            
    7   0.001653   0.000153   call gitgutter#hunk#set_hunks(gitgutter#diff#parse_diff(a:diff))
    7   0.003399   0.000246   let modified_lines = gitgutter#diff#process_hunks(gitgutter#hunk#hunks())
                            
    7              0.000028   if len(modified_lines) > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once('exceeded maximum number of signs (configured by g:gitgutter_max_signs).', 'max_signs')
                                call gitgutter#sign#clear_signs()
                                return
                              endif
                            
    7              0.000014   if g:gitgutter_signs || g:gitgutter_highlight_lines
    7   0.009031   0.000094     call gitgutter#sign#update_signs(modified_lines)
    7              0.000007   endif
                            
    7   0.000150   0.000067   call gitgutter#utility#save_last_seen_change()

FUNCTION  136()
Called 475 times
Total time:   0.223427
 Self time:   0.194556

count  total (s)   self (s)
  475              0.000665     let output = ""
  475              0.000534     if a:drawText ==# 1
                            
  450              0.001332         let treeParts = repeat('  ', a:depth - 1)
                            
  450              0.000650         if !self.path.isDirectory
  175              0.000294             let treeParts = treeParts . '  '
  175              0.000128         endif
                            
  450   0.028475   0.002027         let line = treeParts . self.displayString()
                            
  450              0.001046         let output = output . line . "\n"
  450              0.000329     endif
                            
                                "if the node is an open dir, draw its children
  475              0.000704     if self.path.isDirectory ==# 1 && self.isOpen ==# 1
                            
   25   0.064717   0.000321         let childNodesToDraw = self.getVisibleChildren()
                            
   25   0.067086   0.000209         if self.isCascadable() && a:depth > 0
                            
                                        let output = output . childNodesToDraw[0]._renderToString(a:depth, 0)
                            
                                    elseif len(childNodesToDraw) > 0
  475              0.000503             for i in childNodesToDraw
  450              0.001642                 let output = output . i._renderToString(a:depth + 1, 1)
  450              0.000359             endfor
   25              0.000018         endif
   25              0.000013     endif
                            
  475              0.000466     return output

FUNCTION  gitgutter#hunk#set_hunks()
Called 7 times
Total time:   0.000261
 Self time:   0.000261

count  total (s)   self (s)
    7              0.000257   let s:hunks = a:hunks

FUNCTION  xolox#easytags#highlight()
Called 1 time
Total time:   0.051895
 Self time:   0.027789

count  total (s)   self (s)
                              " TODO This is a mess; Re-implement Python version in Vim script, benchmark, remove Python version.
    1              0.000003   try
    1   0.000027   0.000011     call g:xolox#easytags#highlight_timer.start()
    1   0.000148   0.000013     let filetype = xolox#easytags#filetypes#canonicalize(&filetype)
    1              0.000011     let tagkinds = get(s:tagkinds, filetype, [])
    1              0.000011     if exists('g:syntax_on') && !empty(tagkinds) && !exists('b:easytags_nohl')
    1   0.000021   0.000010       let starttime = xolox#misc#timer#start()
    1              0.000003       let used_python = 0
    5              0.000014       for tagkind in tagkinds
    4              0.000016         let hlgroup_tagged = tagkind.hlgroup . 'Tag'
                                    " Define style on first run, clear highlighting on later runs.
    4              0.000097         if !hlexists(hlgroup_tagged)
    4              0.000091           execute 'highlight def link' hlgroup_tagged tagkind.hlgroup
    4              0.000005         else
                                      execute 'syntax clear' hlgroup_tagged
                                    endif
                                    " Try to perform the highlighting using the fast Python script.
                                    " TODO The tags files are read multiple times by the Python script
                                    "      within one run of xolox#easytags#highlight()
    4   0.023843   0.000064         if s:highlight_with_python(hlgroup_tagged, tagkind)
    4              0.000012           let used_python = 1
    4              0.000004         else
                                      " Fall back to the slow and naive Vim script implementation.
                                      if !exists('taglist')
                                        " Get the list of tags when we need it and remember the results.
                                        let ctags_filetypes = xolox#easytags#filetypes#find_ctags_aliases(filetype)
                                        let filetypes_pattern = printf('^\(%s\)$', join(map(ctags_filetypes, 'xolox#misc#escape#pattern(v:val)'), '\|'))
                                        call g:xolox#easytags#syntax_filter_stage_1_timer.start()
                                        let taglist = filter(taglist('.'), "get(v:val, 'language', '') =~? filetypes_pattern")
                                        call g:xolox#easytags#syntax_filter_stage_1_timer.stop()
                                      endif
                                      " Filter a copy of the list of tags to the relevant kinds.
                                      if has_key(tagkind, 'tagkinds')
                                        let filter = 'v:val.kind =~ tagkind.tagkinds'
                                      else
                                        let filter = tagkind.vim_filter
                                      endif
                                      call g:xolox#easytags#syntax_filter_stage_2_timer.start()
                                      let matches = filter(copy(taglist), filter)
                                      call g:xolox#easytags#syntax_filter_stage_2_timer.stop()
                                      if matches != []
                                        " Convert matched tags to :syntax commands and execute them.
                                        let use_keywords_when = xolox#misc#option#get('easytags_syntax_keyword', 'auto')
                                        let has_default_pattern_prefix = (tagkind.pattern_prefix == g:xolox#easytags#default_pattern_prefix)
                                        let has_default_pattern_suffix = (tagkind.pattern_suffix == g:xolox#easytags#default_pattern_suffix)
                                        let has_non_default_patterns = !(has_default_pattern_prefix && has_default_pattern_suffix)
                                        if use_keywords_when == 'always' || (use_keywords_when == 'auto' && !has_non_default_patterns)
                                          " Vim's ":syntax keyword" command doesn't use the regular
                                          " expression engine and the resulting syntax highlighting is
                                          " therefor much faster. Because of this we use the syntax
                                          " keyword command when 1) we can do so without sacrificing
                                          " accuracy or 2) the user explicitly chose to sacrifice
                                          " accuracy in order to make the highlighting faster.
                                          call g:xolox#easytags#syntax_keyword_timer.start()
                                          let keywords = {}
                                          for tag in matches
                                            if s:is_keyword_compatible(tag)
                                              let keywords[tag.name] = 1
                                            endif
                                          endfor
                                          if !empty(keywords)
                                            let template = 'syntax keyword %s %s containedin=ALLBUT,%s'
                                            let command = printf(template, hlgroup_tagged, join(keys(keywords)), xolox#easytags#syntax_groups_to_ignore())
                                            call xolox#misc#msg#debug("easytags.vim %s: Executing command '%s'.", g:xolox#easytags#version, command)
                                            execute command
                                            " Remove the tags that we just highlighted from the list of
                                            " tags that still need to be highlighted.
                                            call filter(matches, "!s:is_keyword_compatible(v:val)")
                                          endif
                                          call g:xolox#easytags#syntax_keyword_timer.stop()
                                        endif
                                        if !empty(matches)
                                          call g:xolox#easytags#syntax_match_timer.start()
                                          let matches = xolox#misc#list#unique(map(matches, 'xolox#misc#escape#pattern(get(v:val, "name"))'))
                                          let pattern = tagkind.pattern_prefix . '\%(' . join(matches, '\|') . '\)' . tagkind.pattern_suffix
                                          let template = 'syntax match %s /%s/ containedin=ALLBUT,%s'
                                          let command = printf(template, hlgroup_tagged, escape(pattern, '/'), xolox#easytags#syntax_groups_to_ignore())
                                          call xolox#misc#msg#debug("easytags.vim %s: Executing command '%s'.", g:xolox#easytags#version, command)
                                          try
                                            execute command
                                          catch /^Vim\%((\a\+)\)\=:E339/
                                            let msg = "easytags.vim %s: Failed to highlight %i %s tags because pattern is too big! (%i KB)"
                                            call xolox#misc#msg#warn(msg, g:xolox#easytags#version, len(matches), tagkind.hlgroup, len(pattern) / 1024)
                                          endtry
                                          call g:xolox#easytags#syntax_match_timer.stop()
                                        endif
                                      endif
                                    endif
    4              0.000004       endfor
                                  " Avoid flashing each highlighted buffer in front of the user when
                                  " loading a session.
    1   0.000017   0.000006       if !xolox#easytags#session_is_loading()
    1              0.026695         redraw
    1              0.000012       endif
    1              0.000060       let bufname = expand('%:p:~')
    1              0.000005       if bufname == ''
                                    let bufname = 'unnamed buffer #' . bufnr('%')
                                  endif
    1              0.000004       let msg = "easytags.vim %s: Highlighted tags in %s in %s%s."
    1   0.000043   0.000022       call xolox#misc#timer#stop(msg, g:xolox#easytags#version, bufname, starttime, used_python ? " (using Python)" : "")
    1              0.000002       return 1
                                endif
                              catch
                                call xolox#misc#msg#warn("easytags.vim %s: %s (at %s)", g:xolox#easytags#version, v:exception, v:throwpoint)
                              finally
    1   0.000155   0.000022     call g:xolox#easytags#highlight_timer.stop()
    1              0.000002   endtry

FUNCTION  xolox#easytags#get_dynamic_tagsfile()
Called 1 time
Total time:   0.000547
 Self time:   0.000067

count  total (s)   self (s)
                              " Get the pathname of the dynamic tags file to use. If the user configured
                              " dynamic tags files this function returns the pathname of the applicable
                              " dynamic tags file (which may not exist yet), otherwise it returns an empty
                              " string.
    1              0.000002   let tagsfile = ''
                              " Look for a suitable project specific tags file?
    1   0.000022   0.000006   let dynamic_files = xolox#misc#option#get('easytags_dynamic_files', 0)
    1              0.000002   if dynamic_files == 1
                                let tagsfile = get(tagfiles(), 0, '')
                              elseif dynamic_files == 2
    1   0.000266   0.000013     let tagsfile = xolox#misc#option#eval_tags(&tags, 1)
    1              0.000005     let directory = fnamemodify(tagsfile, ':h')
    1              0.000013     if filewritable(directory) != 2
                                  " If the directory of the dynamic tags file is not writable, we fall
                                  " back to another type of tags file.
                                  call xolox#misc#msg#warn("easytags.vim %s: Dynamic tags files enabled but %s not writable so falling back.", g:xolox#easytags#version, directory)
                                  let tagsfile = ''
                                endif
    1              0.000001   endif
    1              0.000002   if !empty(tagsfile)
    1   0.000220   0.000009     return s:select_tags_file(tagsfile, 'dynamic')
                              endif
                              return ''

FUNCTION  lightline#statusline()
Called 14 times
Total time:   0.017990
 Self time:   0.000357

count  total (s)   self (s)
   14              0.000054   if a:inactive && !has_key(s:highlight, 'inactive')
                                call lightline#highlight('inactive')
                              endif
   14   0.017873   0.000240   return s:line(0, a:inactive)

FUNCTION  indent_guides#clear_matches()
Called 14 times
Total time:   0.000905
 Self time:   0.000681

count  total (s)   self (s)
   14   0.000475   0.000251   call indent_guides#init_matches()
   14              0.000041   if !empty(w:indent_guides_matches)
                                let l:index = 0
                                for l:match_id in w:indent_guides_matches
                                  try
                                    call matchdelete(l:match_id)
                                  catch /E803:/
                                    " Do nothing
                                  endtry
                                  call remove(w:indent_guides_matches, l:index)
                                  let l:index += l:index
                                endfor
                              endif

FUNCTION  xolox#misc#async#call()
Called 1 time
Total time:   0.059878
 Self time:   0.000354

count  total (s)   self (s)
                              " Call a Vim script function asynchronously by starting a hidden Vim process
                              " in the background. Once the function returns the hidden Vim process
                              " terminates itself. This function takes a single argument which is a
                              " dictionary with the following key/value pairs:
                              "
                              "  - **function** (required): The name of the Vim function to call inside
                              "    the child process (a string). I suggest using an [autoload][] function
                              "    for this, see below.
                              "
                              "  - **arguments** (optional): A list of arguments to pass to the function.
                              "    This list is serialized to a string using [string()][] and deserialized
                              "    using [eval()][].
                              "
                              "  - **callback** (optional): The name of a Vim function to call in the
                              "    parent process when the child process has completed (a string).
                              "
                              "  - **clientserver** (optional): If this is true (1) the child process will
                              "    notify the parent process when it has finished (the default is true).
                              "    This works using Vim's client/server support which is not always
                              "    available. As a fall back Vim's [CursorHold][] automatic command is
                              "    also supported (although the effect is not quite as instantaneous :-).
                              "
                              " This functionality is experimental and non trivial to use, so consider
                              " yourself warned :-).
                              "
                              " **Limitations**
                              "
                              " I'm making this functionality available in [vim-misc][] because I think it
                              " can be useful to other plug-ins, however if you are going to use it you
                              " should be aware of the following limitations:
                              "
                              "  - Because of the use of multiple processes this functionality is only
                              "    suitable for 'heavy' tasks.
                              "
                              "  - The function arguments are serialized to a string which is passed to
                              "    the hidden Vim process as a command line argument, so the amount of
                              "    data you can pass will be limited by your operating environment.
                              "
                              "  - The hidden Vim process is explicitly isolated from the user in several
                              "    ways (see below for more details). This is to make sure that the hidden
                              "    Vim processes are fast and don't clobber the user's editing sessions in
                              "    any way.
                              "
                              " **Changes to how Vim normally works**
                              "
                              " You have to be aware that the hidden Vim process is initialized in a
                              " specific way that is very different from your regular Vim editing
                              " sessions:
                              "
                              "  - Your [vimrc][] file is ignored using the `-u NONE` command line option.
                              "
                              "  - Your [gvimrc][] file (if you even knew it existed ;-) is ignored using
                              "    the `-U NONE` command line option.
                              "
                              "  - Plug-in loading is skipped using the `--noplugin` command line option.
                              "
                              "  - Swap files (see [swap-file][]) are disabled using the `-n` command line
                              "    option. This makes sure asynchronous Vim processes don't disturb the
                              "    user's editing session.
                              "
                              "  - Your [viminfo][] file is ignored using the `-i NONE` command line
                              "    option. Just like with swap files this makes sure asynchronous Vim
                              "    processes don't disturb the user's editing session.
                              "
                              "  - No-compatible mode is enabled using the `-N` command line option
                              "    (usually the existence of your vimrc script would have achieved the
                              "    same effect but since we disable loading of your vimrc we need to spell
                              "    things out for Vim).
                              "
                              " **Use an auto-load function**
                              "
                              " The function you want to call is identified by its name which has to be
                              " defined, but I just explained above that all regular initialization is
                              " disabled for asynchronous Vim processes, so what gives? The answer is to
                              " use an [autoload][] function. This should work fine because the
                              " asynchronous Vim process 'inherits' the value of the ['runtimepath'][]
                              " option from your editing session.
                              "
                              " ['runtimepath']: http://vimdoc.sourceforge.net/htmldoc/options.html#'runtimepath'
                              " [autoload]: http://vimdoc.sourceforge.net/htmldoc/eval.html#autoload
                              " [CursorHold]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#CursorHold
                              " [eval()]: http://vimdoc.sourceforge.net/htmldoc/eval.html#eval()
                              " [gvimrc]: http://vimdoc.sourceforge.net/htmldoc/gui.html#gvimrc
                              " [string()]: http://vimdoc.sourceforge.net/htmldoc/eval.html#string()
                              " [swap-file]: http://vimdoc.sourceforge.net/htmldoc/recover.html#swap-file
                              " [vim-misc]: http://peterodding.com/code/vim/misc/
                              " [viminfo]: http://vimdoc.sourceforge.net/htmldoc/starting.html#viminfo
                              " [vimrc]: http://vimdoc.sourceforge.net/htmldoc/starting.html#vimrc
    1              0.000005   let unique_number = g:xolox#misc#async#counter
    1              0.000003   let g:xolox#misc#async#counter += 1
    1              0.000004   let request = {'function': a:options['function']}
    1              0.000006   let request['arguments'] = get(a:options, 'arguments', [])
    1   0.000018   0.000008   let request['starttime'] = xolox#misc#timer#start()
    1              0.000003   let request['number'] = unique_number
    1              0.000003   let callback = get(a:options, 'callback')
    1              0.000003   if !empty(callback)
    1              0.000003     let request['callback'] = callback
    1              0.000001   endif
    1              0.000006   if get(a:options, 'clientserver', 1) && !empty(v:servername)
    1              0.000002     let request['servername'] = v:servername
    1              0.000001   else
                                let temporary_file = tempname()
                                let request['temporary_file'] = temporary_file
                              endif
    1              0.000166   let vim_command = printf('let &rtp = %s | call xolox#misc#async#inside_child(%s)', string(&rtp), string(request))
    1   0.000023   0.000010   call xolox#misc#msg#debug("vim-misc %s: Generated asynchronous Vim command #%i: %s", g:xolox#misc#version, unique_number, vim_command)
    1   0.000301   0.000015   let quoted_program = xolox#misc#escape#shell(xolox#misc#os#find_vim('vim'))
    1   0.000195   0.000006   let quoted_command = xolox#misc#escape#shell(vim_command)
    1              0.000014   let shell_command = printf('%s -u NONE -U NONE --noplugin -n -N -i NONE --cmd %s', quoted_program, quoted_command)
    1   0.000018   0.000008   call xolox#misc#msg#debug("vim-misc %s: Generated asynchronous shell command #%i: %s", g:xolox#misc#version, unique_number, shell_command)
    1   0.059042   0.000026   call xolox#misc#os#exec({'command': shell_command, 'async': 1})
    1              0.000012   let g:xolox#misc#async#requests[unique_number] = request

FUNCTION  <SNR>247_OnCursorMovedNormalMode()
Called 716 times
Total time:   0.351730
 Self time:   0.061674

count  total (s)   self (s)
  716   0.041115   0.004365   if !s:AllowedToCompleteInCurrentBuffer()
   39              0.000036     return
                              endif
                            
  677   0.258447   0.005141   call s:OnFileReadyToParse()
  677              0.049248   exec s:python_command "ycm_state.OnCursorMoved()"

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
  299   2.261382   1.235385  166()
   29   1.937560   0.002115  <SNR>158_CursorHoldUpdate()
  557   1.749628   0.006361  44()
  581   1.039297   0.014297  269()
  581   1.008660   0.013877  NERDTreeGitStatusRefreshListener()
  581   0.989894   0.040796  NERDTreeGetGitStatusPrefix()
 9527   0.850239   0.408480  46()
   13   0.817174   0.019481  NERDTreeGitStatusRefresh()
  581   0.807002   0.054513  12()
 4092   0.746783   0.024883  38()
  257   0.441912   0.001691  133()
    7   0.410474   0.012031  <SNR>247_OnBufferEnter()
 9501   0.410333   0.137889  51()
    4   0.395468             UltiSnips#SnippetsInCurrentScope()
  716   0.351730   0.061674  <SNR>247_OnCursorMovedNormalMode()
   16   0.336598   0.000501  <SNR>189_TmuxWinCmd()
   16   0.335908   0.001669  <SNR>189_VimNavigate()
 1774   0.318108   0.030511  MyFugitive()
 1774   0.287597   0.028044  fugitive#head()
  706   0.266140   0.259240  <SNR>247_OnFileReadyToParse()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  299   2.261382   1.235385  166()
 9527   0.850239   0.408480  46()
    4              0.395468  UltiSnips#SnippetsInCurrentScope()
  706   0.266140   0.259240  <SNR>247_OnFileReadyToParse()
29790              0.223129  nerdtree#runningWindows()
  475   0.223427   0.194556  136()
 9501   0.410333   0.137889  51()
   13   0.178138   0.133620  165()
  725              0.104183  <SNR>217_Highlight_Matching_Pair()
  589   0.105610   0.093527  ale#cursor#EchoCursorWarning()
 1204   0.111013   0.092778  <SNR>119_repo_head_ref()
   29   0.203100   0.092765  <SNR>124_ShowMarks()
 2408              0.076934  <SNR>119_repo()
 1404              0.067932  <SNR>124_IncludeMarks()
  716   0.351730   0.061674  <SNR>247_OnCursorMovedNormalMode()
19585   0.208435   0.060830  40()
  581   0.807002   0.054513  12()
  745              0.052879  ale#cursor#EchoCursorWarningWithDelay()
 1204   0.216734   0.050991  <SNR>119_repo_head()
 1156   0.117049   0.045010  33()

